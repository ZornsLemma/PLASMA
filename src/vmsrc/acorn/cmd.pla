// OK, this is a bit ugly... We (mis)use the C preprocessor to allow
// this file to be conditionally compiled to build PLASMA ("PLAS32") and
// PLAS128, based on whether PLAS128 is defined or not. plvmbb.s also
// uses an ACME constant called PLAS128 to provide conditional assembly there.
// Because this file contains inline ACME assembler which wants to be able to
// say things like '!IFDEF PLAS128', it's important that PLAS128 is defined to
// be 'PLAS128', so that the C preprocessor effectively leaves those !IFDEF
// lines alone. We could simply make sure we define it to the appropriate value
// in the makefile, but it seems safest and slightly cleaner (since it gives us
// a place to write this comment) to enforce this here.
#ifdef PLAS128
    #undef PLAS128
    #define PLAS128 PLAS128
#endif
// Ditto for JIT
#ifdef JIT
    #undef JIT
    #define JIT JIT
#endif

// If TIME is defined, additional code is included to print the time spend
// executing a module. This is a development-only feature but it's useful
// enough to leave the code around to be conditionally included as required.
// #define TIME

// If ALLOCXHEAPTEST is defined, some test code is run instead of the command
// prompt loop.
// #define ALLOCXHEAPTEST

include "vmsrc/acorn/plvmzp.plh"
include "inc/acornc.plh"
#include "vmsrc/acorn/vmconstants.plh"

// Where the VM generates errors which are PLASMA-specific, these should of
// course be in the range 0-127 as they are language errors. I've decided to
// informally allocate 0-15 to the low-level VM code in plvm*.s and 16-127 to
// the code in this file.

// TODO: Weird - *SPOOL Z then *PLAS128 *immediately* closes the *SPOOL file.
// *PLASMA doesn't exhibit this. Note that there's no need to load a module,
// the startup banner and prompt don't make it into the spool file. Oh no,
// this is a consequence of the current futzing around to try to make it
// run on I/O processor when 2P is active. If that works out in the end,
// this is probably acceptable. (However, possibly not. Does this cause
// problems if a *EXEC-able !BOOT file wants to do something like:
// *PLAS128
// +MYPROG
// If it does this might be unacceptable. Possibly it would be nice to allow
// a command to be executed to be given as an argument to PLAS128 - then you
// could do '*PLAS128 +MYPROG' - but even then losing the flexibility of the
// *EXEC !BOOT option isn't ideal. I haven't tested to see if this does break
// that case yet.) OK, I have now tested - yes, on a second processor such a
// !BOOT does stop without "typing" in the +MYPROG. It *does* work fine if you
// don't have a second processor turned on, so arguably this is not too big a
// deal - the alternatives are "if there is a second processor, do we refuse to
// run PLAS128 or run it but refuse to accept any commands via *EXEC"

const RELADDR      = $1000

// Note that we cannot rely on initialisation of non-constant globals; on
// PLAS32 running on a second processor, the VM is re-entered on BREAK and
// any globals will have their post-modification values, not the original
// values.

const freemem      = src 	// 'SRC' zp, used to indicate heap start SFTOOD NOT ALWAYS ANY MORE

#ifndef STANDALONE

const maxpathlen = 256
#endif
const false = 0
const true = not false
// TODO: allocheap_fail_threshold should probably be a non-constant
// and be modifiable under program control (if so, '+foo' should
// probably reset it to a default on successful or unsuccessful
// execution). While we're developing, we just stick with this.
const allocheap_fail_threshold = $FFFF
//
// Module don't free memory
//
const modkeep     = $2000
const modinitkeep = $4000 // SFTODO: WHY IS modinitkeep EVER USEFUL? ASK DAVE?
//
// System flags: memory allocator screen holes.
//
const nojitc      = $0100
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    #ifdef JIT
        byte callcount
        byte bytecodesize
    #endif
end
//
// SFTODO: PROB A DUP COMMENT, BUT LATER ON I NEED TO TIDY UP MY ZP AND PAGE 4
// USE, TO MAKE THIS AS CLEAN AS POSSIBLE, I'D LIKE ZP 70-8F FREE FOR USER JUST
// AS THEY ARE IN BASIC
//
// Predefined functions.
//
// TODO: It would be nice if these could be omitted and we could 'include
// "inc/cmdsys.plh"' instead, but this doesn't seem to work. Perhaps try this
// kind of thing with upstream compiler and ask Dave.
predef syscall(cmd,params)#1, call(addr,areg,xreg,yreg,status)#1
predef putln()#0, putc(c)#0, puts(s)#0, getc()#1, gets(p)#1
predef heapmark()#1, heapalloc(size)#1, xheapalloc(size)#1, heapallocalign(size, pow2, freeaddr), heaprelease(newheap)#1, heapavail()#1
predef memset(addr,value,size)#0, memcpy(dst,src,size)#0
predef strcpy(dst,src)#1, strcat(dst,src)#1
predef isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1, sext(a)#1
predef modload(mod)#1, modexec(modfile)#1
predef except(b)#1, except2(bptr)#1, throw(b, val)#0
predef putb(b)#0, puth(w)#0
predef oserror(n, msg)#0
predef call_oscli(str)#0
predef stocr(str, cr)#0
predef mode(n)#1
predef callalloca
predef divmod(dividend, divisor)#2
predef puti(i)#0
predef toupper(c)#1
//
// Exported CMDSYS table
//
word version     = $0200 // 02.00 Dev
word syspath // SFTODO? NEED THIS ANYWAY FOR INC/CMDSYS.PLH
word syscmdln   = inbuff
word            = @modexec
// SFTODO: Apple II version now exports @open, @close, @read, @write, not sure
// what to do about that. For the moment I am going to at least have to include
// them as null pointers because I need to expose jitcount and jitsize, and
// cmdsys.plh is a shared header so I have to have them at the same relative
// offset.
word = 0, 0, 0, 0 // dummy open, close, read, write
byte perr
#ifdef JIT
// jitcount and jitsize are declared in the common cmdsys.plh header, but JITUNE
// checks *jitcomp and won't try to alter them on a non-JIT VM so I think it's
// safe to not have them on non-JIT VMs. This isn't really any different than
// the Apple ///-specific refcons and devcons; see below.
// SFTODO: I don't think I can rely on initialisation of these globals due to the
// way the VM is re-entered on the Tube on BREAK, but for now let's just not
// care about that. (I would want to test, but I think it's fine - this would
// simply preserve any JITTUNE tweaks across BREAK if we stop re-loading JITC
// from disk on BREAK, and if we do reload JITC it will reset these itself.)
byte jitcount    = 0
byte jitsize     = 0
#endif
// Like the Apple II VMs, we don't have the Apple ///-specific refcons and
// devcons variables, even though they are declared in the common cmdsys.plh
// header; if not having them is good enough for the Apple II, it's good enough
// for us.
// byte refcons     = 0
// byte devcons     = 0
//
// Globals
//
// We don't need systemflags; even the Apple II VM handles nojitc separately and
// none of the other flags are relevant to the Acorn VM.
// word systemflags = 0
const heapptr = heapl
#ifdef PLAS128
    // We leave $8000-$8008 inclusive free in each 16K sideways RAM bank
    // to avoid the risk of the data accidentally looking like a valid
    // sideways ROM header.
    const xheap_bank_start = $09
    const xheap_bank_size = 16 * 1024
    word xheap = xheap_bank_start
#endif
#ifndef STANDALONE
word symtblchunk
word lastsym
//
// String pool.
// We don't strictly speaking need this, now that the CS opcode uses string
// pooling in PLAS128 in a way which works even if there's a mode change
// between two executions of the same CS opcode. However, not using this
// manual string pool only saves 12 bytes in PLAS32 and it costs 5 bytes in
// PLAS128, because we need a copy of the string in the binary and on the
// parameter stack (the binary is in main RAM here, not in sideways
// RAM), so we stick with it. TODO: We could in principle conditionally
// compile this, but it's awfully fiddly. SFTODO: Perhaps reconsider this
// tradeoff and switch to literal strings instead of this pool
// SFTODO: Probably not worth it, but we could make PLAS128's CS opcode
// recognise if IPH is <$80 and behave like PLAS32's CS opcode in that case -
// this would bloat the VM code slightly but might be worth it if it simplifies
// string handling for this file.
//
byte verstr[]     = "PLASMA "
byte freestr[]    = "MEM FREE:$"
#ifdef PLAS128
    byte xfreestr[]	  = ", AUX FREE:$"
#endif
byte errorstr[]   = "ERR:$"
byte prompt[]     = "PLASMA"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte colonstr[]   = ": "
#endif
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
#ifdef TIME
    byte start_time[osword_read_time_block_size]
    byte end_time[osword_read_time_block_size]
#endif
//
// Exported Machine ID. We somewhat arbitrarily assign the apparently free code
// $C8 for all Acorn machines; once you know you're on an Acorn machine you can
// use something like OSBYTE 0 to determine the exact model.
//
export byte machid       = $C8
#ifndef STANDALONE
//
// File handle used by modload (so we can close it if an error occurs)
//
byte modload_handle
//
// Pointer to function used to transform a module name into a filename; used to
// allow a user to load a resident module to override the default
// small-but-simplistic implementation.
//
word modname
#endif
//
// Global variables for use by mode()
//
word gm_himem_delta
word gm_new_frame_start
#ifdef PLAS128
    word gm_new_ifp
#endif
word gm_copy_from
word gm_copy_size
byte gm_new_mode
#ifndef STANDALONE
//
// Standard Library exported functions.
//
include "vmsrc/acorn/symtab.pla"
#endif
//
// CALL 6502 ROUTINE
// CALL(ADDR, AREG, XREG, YREG, STATUS)
//
export asm call(addr,areg,xreg,yreg,status)#1
REGVALS =   SRC
        PHP
        LDA     ESTKL+4,X
        STA     TMPL
        LDA     ESTKH+4,X
        STA     TMPH
        LDA     ESTKL,X
        PHA
        LDY     ESTKL+1,X
        LDA     ESTKL+3,X
        PHA
        LDA     ESTKL+2,X
        INX
        INX
        INX
        INX
        STX     ESP
        TAX
        PLA
        PLP
        JSR     JMPTMP
        PHP
        STA     REGVALS+0
        STX     REGVALS+1
        STY     REGVALS+2
        PLA
        STA     REGVALS+3
        LDX     ESP
        LDA     #<REGVALS
        LDY     #>REGVALS
        STA     ESTKL,X
        STY     ESTKH,X
        PLP
        RTS
end
//
// SET MEMORY TO VALUE
// MEMSET(ADDR, VALUE, SIZE)
//   With optimizations from Peter Ferrie
//
export asm memset(addr,value,size)#0
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	LDY     ESTKL,X
	BEQ     +
	INC     ESTKH,X
	LDY     #$00
+	LDA     ESTKH,X
	BEQ     SETMEX
SETMLPL	CLC
	LDA     ESTKL+1,X
SETMLPH	STA     (DST),Y
	DEC     ESTKL,X
	BEQ     ++
-	INY
	BEQ     +
--	BCS     SETMLPL
	SEC
	LDA     ESTKH+1,X
	BCS     SETMLPH
+	INC     DSTH
	BNE     --
++	DEC     ESTKH,X
	BNE     -
SETMEX	INX
	INX
	INX
	RTS
end
#ifdef PLAS128
//
// COPY FROM MAIN MEM TO AUX MEM.
//
// MEMXCPY(DST, SRC, SIZE)
//
// Assumes that DST to DST+SIZE-1 all lie in the same 16K bank; this will
// be true given how allocxheap() works.
asm memxcpy(dst,src,size)#0
	;* This code must be kept consistent with IINTERP
	LDA	ESTKH+2,X
        ROL
        ROL
        ROL
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+2,X
	AND	#$BF
	ORA	#$80
	STA 	ESTKH+2,X

        ;* !IF * <> MEMCPY {
        ;*    !ERROR "memcpy() must follow memxcpy()"
        ;* }
        ;* fall through into memcpy()
MEMXCPYEND
end
#endif
//
// COPY MEMORY
// MEMCPY(DSTADDR, SRCADDR, SIZE)
//
export asm memcpy(dst,src,size)#0
#ifdef PLAS128
        !IF MEMXCPYEND <> * {
           !ERROR "memcpy() must follow memxcpy()"
        }
#endif
	INX
	INX
	INX
	LDA	ESTKL-3,X
	ORA	ESTKH-3,X
	BEQ	CPYMEX
	LDA	ESTKL-2,X
	CMP	ESTKL-1,X
	LDA	ESTKH-2,X
	SBC	ESTKH-1,X
 	BCC	REVCPY
;
; FORWARD COPY
;
	LDA	ESTKL-1,X
	STA 	DSTL
	LDA	ESTKH-1,X
	STA 	DSTH
	LDA	ESTKL-2,X
	STA 	SRCL
	LDA	ESTKH-2,X
	STA 	SRCH
MEMCPY2
	LDY	ESTKL-3,X
	BEQ	FORCPYLP
	INC 	ESTKH-3,X
	LDY	#$00
FORCPYLP LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL-3,X
	BNE	FORCPYLP
	DEC	ESTKH-3,X
	BNE	FORCPYLP
	RTS
;
; REVERSE COPY
;
REVCPY	;CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-1,X
	STA	DSTL
	LDA	ESTKH-3,X
	ADC	ESTKH-1,X
	STA	DSTH
	CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-2,X
	STA	SRCL
	LDA	ESTKH-3,X
	ADC	ESTKH-2,X
	STA	SRCH
	DEC	DSTH
	DEC	SRCH
	LDY	#$FF
	LDA 	ESTKL-3,X
	BEQ	REVCPYLP
	INC 	ESTKH-3,X
REVCPYLP LDA	(SRC),Y
	STA	(DST),Y
	DEY
	CPY	#$FF
	BNE	+
	DEC	DSTH
	DEC	SRCH
+	DEC 	ESTKL-3,X
	BNE	REVCPYLP
	DEC	ESTKH-3,X
	BNE	REVCPYLP
CPYMEX	RTS
end
//
// result, remainder = divmod(dividend, divisor)
//
export asm divmod(a,b)#2
        JSR     INTERP          ; CALL INTERP
        !BYTE   $36, $5C        ; DIVMOD, RET
end
export asm sext(a)#1
        LDY     #$00
        LDA     ESTKL,X
        BPL     +
        DEY
+       STY     ESTKH,X
        RTS
end
//
// Unsigned word comparisons.
//
export asm isuge(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isule(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isugt(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isult(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
#ifndef STANDALONE
// 
// A DCI string is one that has the high bit set for every character except the last.
// More efficient than C or Pascal strings.
//
//def dcitos(dci, str)
//    byte len, c
//    len = 0
//    repeat
//        c = (dci).[len]
//        len = len + 1
//        (str).[len] = c & $7F
//    until !(c & $80)
//    ^str = len
//    return len
//end
asm dcitos(dci, str)#1
	JSR	INITDSTSRCY
-	LDA	(SRC),Y
	CMP	#$80
	AND	#$7F
	INY
	STA	(DST),Y
	BCS	-
	TYA
	LDY	#$00
	STA	(DST),Y
        INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
//def stodci(str, dci)
//    byte len, c
//    len = ^str
//    if len == 0
//        return 0
//    fin
//    c = toupper((str).[len]) & $7F
//    len = len - 1
//    (dci).[len] = c
//    while len
//    	c = toupper((str).[len]) | $80
//    	len = len - 1
//    	(dci).[len] = c
//    loop
//    return ^str
//end
asm stodci(str,dci)#1
	JSR	INITDSTSRCY
        INX
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+           ; always branch; this assumes TOUPR returns with Z clear, which is
                            ; true if 'z'+1 is not present in the symbol (a reasonable assumption)
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
#endif
export asm toupper(c)#1
	LDA     ESTKL,X
TOUPR	AND     #$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SBC     #$1F
+	STA     ESTKL,X
	RTS
end
#ifndef STANDALONE
// Convert a DCI string to an Acorn OS-style string terminated by CR
// int dcitocr(dci, cr) - returns length (of DCI string/excluding CR)
asm dcitocr(dci, cr)#1
	JSR	INITDSTSRCY
	INX
	STY	ESTKH,X
-	LDA	(SRC),Y
	CMP	#$80		; set C iff >= $80
	AND	#$7F
	STA	(DST),Y
	INY
	BCS	-
	LDA	#$0D
	STA	(DST),Y
	STY	ESTKL,X
	RTS
end
#endif
// Converts a PLASMA string to an Acorn OS-style string terminated by CR
// void stocr(str, cr)
export asm stocr(str, cr)#0
	JSR	INITDSTSRCY
        INX
	INX
	STX	ESP
	LDA	(SRC),Y
	BEQ	+
	TAX
-	INY
	LDA	(SRC),Y
	DEY
	STA	(DST),Y
	INY
	DEX
	BNE	-
+	LDA	#$0D
	STA	(DST),Y
	LDX	ESP
	RTS
INITDSTSRCY
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
        RTS
end

#ifndef STANDALONE
//
// Lookup routines.
//
asm lookuptbl(dci, tbl)#1
	JSR	INITDSTSRCY
.NEXT	LDY	#$00
.NEXTY	LDA	(DST),Y
	BEQ	.TABLEEND
        CMP	#$01
        BEQ	.CHUNKEND
	CMP	(SRC),Y
	BNE	.NOTMATCH
	INY
	ASL
	BCS	.NEXTY
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
.EXIT	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
.TABLEEND
        TAY
        BEQ	.EXIT
.NOTMATCH
	LDY	#$00
.SKIP	LDA	(DST),Y
	INC	DSTL
	BEQ	.DSTCARRY
.DSTCARRYDONE
	ASL
	BCS	.SKIP
	LDA	#$02
	ADC	DSTL
	STA	DSTL
	BCC	.NEXTY
	INC	DSTH
	BCS	.NEXTY
.DSTCARRY
	INC	DSTH
	BNE	.DSTCARRYDONE
.CHUNKEND 
	LDY	#$02
	LDA	(DST),Y
	PHA
	DEY
	LDA	(DST),Y
	STA	DSTL
	PLA
	STA	DSTH
	BNE	.NEXT
end
// def lookupidx(esd, index)
//    word sym
//    while ^esd
//        sym = esd
//        esd = sym + dcitos(sym, @str)
//        if esd->0 & $10 and esd->1 == index
//            return sym
//        fin
//        esd = esd + 3
//    loop
//end
asm lookupidx(esd, index)#1
        LDA     ESTKL,X
        STA     TMPL
        INX
---     LDA     ESTKH,X
        STA     SRCH
        LDA     ESTKL,X
--      STA     SRCL
        LDY     #$00
-       LDA     (SRC),Y
        BPL     +
        INY
        BNE     -
+       BEQ     ++              ; END OF ESD
        INY
        LDA     (SRC),Y
        INY
        AND     #$10            ; EXTERN FLAG?
        BEQ     +
        LDA     (SRC),Y
        CMP     TMPL
        BEQ     +++             ; MATCH
+       INY
        TYA
        SEC
        ADC     SRCL
        STA     ESTKL,X         ; SYM PTRL
        BCC     --
        INC     ESTKH,X         ; SYM PTRH
        BNE     ---
++      STA     ESTKL,X         ; END OF ESD
        STA     ESTKH,X
+++     RTS
end
//def lookupdef(addr, deftbl)#1
//    while deftbl->interpjsr == $20
//        if deftbl=>bytecodeaddr == addr
//            return deftbl
//        fin
//        deftbl = deftbl + t_defentry
//    loop
//    return 0
//end
asm lookupdef(addr, deftbl)#1
        LDA     ESTKH,X
        STA     SRCH
        LDA     ESTKL,X
        STA     SRCL
        INX
-       LDY     #$00
        LDA     (SRC),Y
        CMP     #$20            ; JSR OPCODE?
        BNE     ++
        LDY     #$03
        LDA     (SRC),Y
        CMP     ESTKL,X
        BNE     +
        INY
        LDA     (SRC),Y
        CMP     ESTKH,X
        BNE     +
        LDA     SRCL            ; MATCH
        STA     ESTKL,X
        LDA     SRCH
        STA     ESTKH,X
        RTS
+
        ; TODO: It would be nice if we could somehow access t_defentry here...
!IFDEF JIT {
        LDA     #$07
} ELSE {
        LDA     #$05
}
        CLC
        ADC     SRCL
        STA     SRCL
        BCC     -
        INC     SRCH
        BNE     -
++      STY     ESTKL,X
        STY     ESTKH,X
        RTS
end
//
// Reloc internal data
//
//def reloc(modfix, modofst, bytecode, rld)#3
//    word addr, fixup
//    while ^rld
//        addr = rld=>1 + modfix
//        if ^rld & $10 // EXTERN reference.
//            return rld, addr, fixup
//        fin
//        fixup = *addr + modofst
//        if uword_isge(fixup, bytecode) // Bytecode address.
//            return rld, addr, fixup
//        fin
//        *addr = fixup
//        rld = rld + 4
//    loop
//    return rld, addr, fixup
//end
asm reloc(modfix, modofst, bytecode, rld)#3
        LDA     ESTKL,X
        STA     SRCL
        LDA     ESTKH,X
        STA     SRCH
        LDY     #$00
-       LDA     (SRC),Y
        BEQ     RLDEX       ; END OF RLD
        PHA
        INY
        LDA     (SRC),Y
        INY
        CLC
        ADC     ESTKL+3,X   ; ADDR=ENTRY=>1+MODFIX
        STA     DSTL
        LDA     (SRC),Y
        ADC     ESTKH+3,X
        STA     DSTH
        PLA
        AND     #$10        ; EXTERN REF - EXIT
        BNE     RLDEX
        TAY                 ; FIXUP=*ADDR+MODOFST
        LDA     (DST),Y
        INY
        CLC
        ADC     ESTKL+2,X
        STA     TMPL
        LDA     (DST),Y
        ADC     ESTKH+2,X
        CMP     ESTKH+1,X   ; FIXUP >= BYTECODE?
        BCC     +
        STA     TMPH
        BNE     RLDEX       ; YEP, EXIT
        LDA     TMPL
        CMP     ESTKL+1,X
        BCS     RLDEX       ; YEP, EXIT
        LDA     TMPH
+       STA     (DST),Y     ; *ADDR=FIXUP
        DEY
        LDA     TMPL
        STA     (DST),Y
        LDA     SRCL        ; NEXT ENTRY
;       CLC
        ADC     #$04
        STA     SRCL
        BCC     -
        INC     SRCH
        BNE     -
RLDEX   INX
        LDA     TMPL
        STA     ESTKL,X
        LDA     TMPH
        STA     ESTKH,X
        LDA     DSTL
        STA     ESTKL+1,X
        LDA     DSTH
        STA     ESTKH+1,X
        LDA     SRCL
        STA     ESTKL+2,X
        LDA     SRCH
        STA     ESTKH+2,X
        RTS
end
#endif

//
// Large frame allocation API
// 
// This is effectively a varargs function; given a function foo: // 	def foo(a, b, c)
// if you execute:
//	x = (@callalloca)(5, 25, @foo, 512)
// it behaves 'as if' you wrote:
//	byte tmp[512]
//	x = foo(5, 25, @tmp)
// and then 'tmp' is immediately freed on exit from foo().
// This is useful because normal local variables are restricted to a total
// of 256 bytes per function.
//
// Note that if the function being called has a #n on its definition with n!=1,
// the same #n must be appended to the call to callalloca(), otherwise things
// will go wrong - callalloca() actually leaves the expression stack alone after
// calling the specified function.
//
// Note also that to avoid the compiler's validation of function call arguments,
// callalloca must be called via a function pointer as in the example above.
// (callalloca is declared with no arguments and one return value, but it
// actually has as many arguments and return values as the function it calls.)
// The optimiser turns this into a standard function call so there is no space
// or time penalty to doing this.
export asm callalloca
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH

        ; We can't save IFP/PP directly in case mode() gets called by a child
        ; function; instead we save the delta we're applying to IFP/PP so we can
        ; reverse it when our child function returns.
        LDA	ESTKH,X
        PHA
        LDA	ESTKL,X
        PHA

	SEC
!IFNDEF PLAS128 {
	LDA	IFPL
	SBC	ESTKL,X
	STA	IFPL
	STA	ESTKL+1,X
	LDA	IFPH
	SBC	ESTKH,X
	STA	IFPH
	STA	ESTKH+1,X
	+CHECKVSHEAP IFP
} ELSE {
	LDA	PPL
	SBC	ESTKL,X
	STA	PPL
	STA	ESTKL+1,X
	LDA	PPH
	SBC	ESTKH,X
	STA	PPH
	STA	ESTKH+1,X
	+CHECKVSHEAP PP
	; We don't need to update IFP; if the called function uses the frame
	; stack, ENTER will set IFP=PP-frame_size.
}
	INX

	JSR	JMPTMP

	CLC
!IFNDEF PLAS128 {
	PLA
        ADC	IFPL
	STA	IFPL
	PLA
        ADC	IFPH
	STA	IFPH
} ELSE {
	PLA
        ADC	PPL
	STA	PPL
	PLA
        ADC	PPH
	STA	PPH
}

	RTS
end

//
// ACORN OS ERROR GENERATION
//
export asm oserror(n, msg)#0
	LDA	ESTKL+1,X
	STA	$101
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	TAY
	LDA	#0
	STA	$100 ; BRK opcode
	STA	$102,Y
-	LDA	(TMP),Y
	STA	$101,Y
	DEY
	BNE	-
	JMP	$100
end

//
// NONLOCAL GOTO
//

// except(jmp_buf *b) -> 0 on save, throw val otherwise
export asm except(b)#1
	STX	ESP

	LDY	#0
	LDA	ESTKL,X
	STA	TMPL
	STY	ESTKL,X
	LDA	ESTKH,X
	STA	TMPH
	STY	ESTKH,X

	TXA
	STA	(TMP),Y
	INY

	; Note that we know there's at least one element on ESTK as
	; we received our 'b' argument on it. We could avoid saving
	; that but it seems simplest just to include it.
----	LDA	ESTKL,X
	STA	(TMP),Y
	INY
	LDA	ESTKH,X
	STA	(TMP),Y
	INY
	INX
    	CPX	#ESTKSZ/2
	BNE	----

	;* We store IFP and PP as a delta from HIMEM to avoid problems
	;* where we do except(); mode(); throw().
#ifndef PLAS128
        SEC
	LDA	#0
	SBC	IFPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	IFPH
	STA	(TMP),Y
	INY
#else
   	LDX     #IFPL
        JSR     SAVEDELTA
        LDX     #PPL
        JSR     SAVEDELTA
#endif
	;* We don't need to save IP, IPY or (for PLAS128) the current bank at 
	;* $F4; CALL/ICAL save and restore these themselves. (Remember that
	;* when throw() reaches its RTS, control returns to just after the
	;* JSR inside the CALL/ICAL which called except.)

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	+
	INC	TMPH
+	LDY	#0

	TSX
	TXA
	STA	(TMP),Y
        ; Y=0 at this point; we assume the CPU stack is not completely full
        ; (X=$FF) at this point (if it is, we're in trouble, because an
        ; interrupt could occur and push more onto the stack) and therefore we
        ; know that Y can't wrap round during the following loop.
--	INX
	BEQ	++
	LDA	$0100,X
	INY
	STA	(TMP),Y
        BNE     --              ; always branches

++	LDX	ESP
	RTS

#ifdef PLAS128
SAVEDELTA
        SEC
	LDA	#0
	SBC	$00,X
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	$01,X
	STA	(TMP),Y
	INY
        RTS
#endif
end

// throw(jmp_buf *b, word val)
// Control never returns to caller; we declare this to return no values so the
// caller doesn't waste space on a redundant DROP opcode after the CALL.
export asm throw(b, val)#0
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH
	LDA	ESTKL,X
	PHA
	LDA	ESTKH,X
	PHA

	LDY	#0
	LDA	(TMP),Y
	STA	ESP
	TAX
	INY
-	LDA	(TMP),Y
	STA	ESTKL,X
	INY
	LDA	(TMP),Y
	STA	ESTKH,X
	INY
	INX
	CPX 	#ESTKSZ/2
	BNE	-
        LDX	ESP

	PLA
	STA	ESTKH,X
	PLA
	STA	ESTKL,X
	;* if val is 0, force it to be 1
	ORA	ESTKH,X
	BNE	++++
	INC	ESTKL,X
++++

#ifndef PLAS128
 	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	IFPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	IFPH
	INY
#else
        LDX     #IFPL
        JSR     APPLYDELTA
        LDX     #PPL
        JSR     APPLYDELTA
#endif

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	++
	INC	TMPH
++	LDY	#0

	LDA	(TMP),Y
	TAX
	TXS

        ;* As in except(), we can assume X is not $FF and so we know Y can't
        ;* wrap round during this loop.
--	INX
	BEQ	+++
        INY
	LDA	(TMP),Y
	STA	$0100,X
        JMP	--

+++	

	;* PLAS128: CS may have allocated some constant strings after except()
	;* was called, but when we restore the value of PP saved by except()
	;* we effectively just reset the pool back to the state at the except()
	;* point.

	LDX	ESP
	RTS

#ifdef PLAS128
APPLYDELTA
 	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	$00,X
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	$01,X
	INY
        RTS
#endif
end

//
// CONSOLE I/O
//
export asm putln()#0
        ; Since this is so simple, it's highly tempting to try to do away with
        ; it and have code call OSNEWL directly. This is possible for loaded
        ; modules - we can simply arrange for the "putln" entry in the symbol
        ; table to point to OSNEWL. However, it's trickier to make it work here
        ; in the core VM. We can omit this definition and do 'const putln =
        ; osnewl' but calling through a function pointer (as this effectively
        ; is) requires the call site to specify '#0' (we can't attach that type
        ; information to the function pointer itself) - I haven't actually tried
        ; that but it would probably work, but it would be a bit intrusive.
        ; Since this JMP OSNEWL therefore "has" to exist, I haven't bothered
        ; making the symbol table just refer directly to OSNEWL lest it cause
        ; confusion - the performance overhead is negligible.
	JMP	OSNEWL
end
export asm putc(c)#0
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
// Just a helper function for mode(); smaller than writing it in PLASMA.
asm putc22(n)#0
	LDA	#22
	JSR	OSWRCH
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
export asm getc()#1
	DEX
	JSR	OSRDCH
        BCS	ESCAPE
	STA	ESTKL,X
	LDA	#$00
	STA	ESTKH,X
	RTS
end
export asm gets(p)#1
	STX	ESP
	LDA	ESTKL,X
	JSR	OSWRCH
	LDA	#<INBUFF
	STA	ESTKL,X
	LDA	#>INBUFF
	STA	ESTKH,X
        LDA	#0
        LDX	#<OSWORD0BLK
        LDY	#>OSWORD0BLK
	JSR	OSWORD
	BCS	ESCAPE
	STY	INBUFF
	LDX	ESP
	RTS
ESCAPE
	LDA	#osbyte_acknowledge_escape
	JSR	OSBYTE
	BRK
	!BYTE	17
	!TEXT	"Escape"
	BRK
OSWORD0BLK
	!WORD	INBUFF+1
        !BYTE	INBUFFSZ-1  ; -1 as OSWORD 0 will store a trailing CR after this many characters
        !BYTE	32
        !BYTE	255
end
// def puts(str)
export asm puts(s)#0
	STX	ESP
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	BEQ	+
	TAX
-	INY
	LDA	(TMP),Y
	JSR	OSASCI
	DEX
	BNE	- 
+	LDX	ESP
	INX
	RTS
end
//
// Cheap and dirty print integer SFTODO: USE THIS INSTEAD OF TESTLIB VERSION WHERE IT'S SUITABLE
//
export def puti(i)#0
    if i < 0; putc('-'); i = -i; fin
    if i >= 10; puti(i / 10); fin
    putc(i % 10 + '0')
end
export def putb(b)#0
    putc(hexchar[(b >> 4) & $0F])
    putc(hexchar[b & $0F])
end
export def puth(w)#0
    putb(w >> 8)
    putb(w)
end

// TODO: export this?
// TODO: get rid of this and inline it in except2()?
def jmpbufsz(jb)#1
	const esp_size = 1
	const esp_offset = 0
#ifdef PLAS128
	const pp_size = 2
#else
	const pp_size = 0
#endif
	const ifp_size = 2
	const stack_ptr_size = 1
	const estksz_elems = estksz / 2
	word size
	word stack_ptr
	size = esp_size + 2 * (estksz_elems - jb->esp_offset) + ifp_size + pp_size
	stack_ptr = ^(jb + size)
	size = size + stack_ptr_size + (255 - stack_ptr)
	return size
end
// int except2(jmp_buf **b) { *b = new jmp_buf; return except(*b); }
// except() wrapper which dynamically allocates a jmp_buf of just the right size
// to avoid wasting memory.
export def except2(bptr)#1
    word b
    word result
    b = *heapptr
    *bptr = b
    result = except(b)
    if result == 0
        xheapalloc(jmpbufsz(b))
    fin
    return result
end
// Change the screen mode
//
// Care must be taken when calling mode(). The parameter stack starts at the
// bottom of screen memory (HIMEM) and grows downwards. If a mode change
// alters HIMEM, the parameter stack needs to be relocated in memory. mode()
// takes care of this, but any code which has taken the address of local
// variables on the parameter stack (or, on PLAS128, constant strings, which
// also live on the parameter stack) will have an invalid address after
// the relocation. (This isn't an issue if changing between modes which doesn't
// alter HIMEM.)
//
// TL;DR: Call mode() as early as possible and with as few nested function
// calls in effect as possible and you'll probably be safe.
//
// Returns true if the mode change was successful and false if not (typically
// caused by insufficient memory).
export def mode(n)#1
    word new_himemh, himem, new_himem

    // If the mode change doesn't alter HIMEM, it's trivial. We need to check
    // specifically for the second processor case here; see the code just
    // above INITFP.
    new_himemh = call(osbyte, osbyte_read_himem_for_mode, n, 0, 0).2
    if new_himemh == ^himemh or ^himemh > $80
        putc22(n)
	return true
    fin

    himem = ^himemh << 8
    new_himem = new_himemh << 8
    gm_himem_delta = new_himem - himem
#ifdef PLAS128
    gm_new_frame_start = *pp + gm_himem_delta
    // Because we use gm_new_frame_start below, it's important that PP doesn't
    // move between now and then - which means none of the following code can
    // use constant strings. (We could redo this calculation at that point, but
    // it's nicer not to have to.)
#else
    gm_new_frame_start = *ifp + gm_himem_delta
#endif
    // Insist on 512 bytes free afterwards, so that an application has a
    // chance to not crash after a mode change when memory is tight.
    if isult(gm_new_frame_start - 512, *heapptr)
	return false
    fin

    ^himemh = new_himemh

    // We're now going to copy the parameter frame stack and adjust IFP (and
    // PP for PLAS128) accordingly. We need a temporary parameter frame
    // stack so we can call memcpy(); once we've switched to that we can't
    // access any local variables, so we copy everything into globals first.
#ifdef PLAS128
    gm_new_ifp = *ifp + gm_himem_delta
    gm_copy_from = *pp
#else
    gm_copy_from = *ifp
#endif
    gm_copy_size = himem - gm_copy_from
    gm_new_mode = n
    *ifp = *heapptr + 256 // we know there's at least 512 bytes available

    if gm_himem_delta >= 0
	putc22(gm_new_mode)
    fin
    memcpy(gm_new_frame_start, gm_copy_from, gm_copy_size)
    if gm_himem_delta < 0
	putc22(gm_new_mode)
    fin
#ifdef PLAS128
    *pp = gm_new_frame_start
    *ifp = gm_new_ifp
#else
    *ifp = gm_new_frame_start
#endif
    return true
end

//
// FILE I/O
//
#ifndef STANDALONE
#endif
def oserror_heap_full()#0
    oserror(16, "Heap full")
end
#ifndef STANDALONE
def oserror_bad_module()#0
    oserror(17, "Bad module")
end
def oserror_not_found(moddci)#0
    byte error[maxnamelen + 16 + 1]
    dcitos(moddci, @error)
    strcat(@error, " not found")
    oserror(214, @error)
end
def oserror_bad_name()#0
    oserror(204, "Bad name") // SFTODO: SHOULD THIS BE USING THIS ERR NUM? WOULD ONE IN THE 0-127 RANGE BE BETTER? NOT THINKING NOW, JUST CHECK LATER... MAY WELL BE FINE
end
#endif
//
// Heap routines.
//
export def heapavail()#1
    byte fp
    return @fp - *heapptr
end
// heapalloc() generates an OS error if the allocation fails and is
// no larger than allocheap_fail_threshold; failures otherwise return
// 0. The idea here is that as well as allowing "always" and "never"
// generating an OS error, a program may take more care to check big
// allocations (e.g. loading a file containing user data) than it will
// do with small allocations (where it might not be able to do much
// except die even if it checks and notices that they failed).
export def heapalloc(size)#1
    word addr
    if isugt(size, heapavail())
	if isule(size, allocheap_fail_threshold)
	    oserror_heap_full()
	fin
	return 0
    fin
    addr = *heapptr
    *heapptr = *heapptr + size
    return addr
end
// Like heapalloc(), but *always* generates an error if the allocation
// fails, regardless of the size requested and the fail threshold.
export def xheapalloc(size)#1
    word addr
    addr = heapalloc(size)
    if addr == 0
	oserror_heap_full()
    fin
    return addr
end
export def heapallocalign(size, pow2, freeaddr)#1
    word align, addr
    if freeaddr
        *freeaddr = *heapptr
    fin
    align = (1 << pow2) - 1
    addr = *heapptr
    if addr & align
        addr = (addr | align) + 1
    fin
    if !heapalloc(size + (addr - *heapptr))
        return 0
    fin
    return addr
end
export def heapmark()#1
    return *heapptr
end
export def heaprelease(newheap)#1
    *heapptr = newheap
    return @newheap - *heapptr
end
// SFTODO: On tube, JIT module is reloaded from disc on soft break - can we
// avoid this?
#ifdef PLAS128
// The value returned by this is slightly misleading as it may include some
// unusable space at the start of each bank, but this behaviour is exactly what
// we want in allocxheap() and it's not a problem for showing the free memory to
// the user.
def xheapfree(localxheap)#1
    word xheapsize
    xheapsize = ^rambankcount * xheap_bank_size
    if xheapsize == 0
        // If we have 4x16K banks, we have to waste the last byte, otherwise
        // there's no way with a 16-bit result to distinguish completely full
        // and completely empty. (Just possibly we could play games relating to
        // the fact that we know xheap starts at xheap_bank_start rather than 0,
        // but I think this just makes allocxheap() even more tricky to get
        // right.) SFTODO: COMMENT OK? REVIEW LATER WHEN FRESH...
        xheapsize = $FFFF
    fin
    return xheapsize - localxheap
end
// TODO: I've rewritten this - review it when fresh, I think I have tested it
// fairly well via ALLOCXHEAPTEST but if I make any code changes make sure to
// retest.
def allocxheap(size)#1
    word xheapcopy
    xheapcopy = xheap
    while true
        if size == 0 or isult(xheapfree(xheapcopy), size)
            return 0
        elsif (xheapcopy & (xheap_bank_size - 1)) == 0
            // xheapcopy is at the start of a 16K bank; we know we have at least one
            // free bank as xheapfree > size > 0. So skip past the initial
            // xheap_bank_start bytes and try again on the next pass round the
            // loop.
            xheapcopy = xheapcopy + xheap_bank_start
        elsif (xheapcopy & $C000) == ((xheapcopy + size - 1) & $C000)
            // We have enough space at xheapcopy without straddling a bank boundary.
            xheap = xheapcopy + size
            return xheapcopy
        else
            // A naive allocation at xheapcopy would straddle a bank boundary, so
            // move up to the next boundary and try again on the next pass round
            // the loop. This can't wrap around to $0000 because if we're in our
            // last bank xheapfree is the space free in the last bank and therefore
            // either xheapfree < size or we have enough space at xheapcopy
            // without straddling a bank boundary, so this case can't occur.
            xheapcopy = (xheapcopy & $C000) + xheap_bank_size
        fin
    loop
end
#endif

//
// Acorn MOS API
//

def call_oscli_internal(str, str_cr)#0
    stocr(str, str_cr)
    call(oscli, 0, str_cr, str_cr >> 8, 0)
end

// call_oscli(str)
export def call_oscli(str)#0
    (@callalloca)(str, @call_oscli_internal, ^str + 1)#0
end

#ifndef STANDALONE
//
// Symbol table routines.
//
// The symbol table is a "chunked array"; the first chunk is at symtbl and
// each chunk consists of a number of entries, each of which consists of:
// - symbol name (as DCI string)
// - symbol address (2 bytes)
//
// If the symbol name's first byte is 0, that marks the end of the symbol
// table.
//
// If the symbol name's first byte is 1, that marks the end of the current
// chunk but not the symbol table; it is followed by two bytes which are
// the address of the next chunk.
//
// The first chunk is a different size than later chunks but this is only
// relevant to addsym(); it makes no difference to lookuptbl().
//
// TODO: lookupsym has only one caller, inline it??
def lookupsym(sym)#1
    return lookuptbl(sym, @symtbl)
end
def addsym(sym, addr)#0
    byte str[maxnamelen+1]
    word entrysz
    const addrsz = 2
    const nextchunkptrsz = 3 // end of chunk marker followed by two byte pointer
    
    // We must always have room for the symbol name, two bytes for the
    // address associated with that name and another three bytes for the
    // 'next chunk' pointer. (Initially we only need one byte for the 'end
    // of table' marker, but sooner or later another chunk will be added
    // so we need to allocate three bytes. Those extra two bytes are not
    // *touched* yet, which is important for the assumptions we make about
    // symbol table growth in modload().)
    entrysz = addrsz + nextchunkptrsz + dcitos(sym, @str)
    if (symtblchunk <> lowsymtblchunk) or (lastsym - lowsymtblchunk + entrysz > lowsymtblchunksz)
    	symtblchunk = xheapalloc(entrysz)
	if lastsym + nextchunkptrsz == symtblchunk
	    // This allocation is contiguous with the previous chunk; we
            // therefore don't need a chunk end marker and a symbol table
            // pointer. This is important when we're called in modload(), as
	    // otherwise the assumption about the growth of the symbol table
	    // per addsym() call wouldn't be true. Because this is the common
	    // case, we can get away with allocating only the exact number of
	    // bytes required every time without this wasting space by causing
            // us to have one symbol table chunk per symbol.
	    symtblchunk = lastsym
            heaprelease(symtblchunk + entrysz)
	else
            lastsym->0 = 1 // end of chunk but not end of table
	    lastsym=>1 = symtblchunk // next chunk
	    lastsym = symtblchunk
	fin
    fin
    // We don't have a 'copy DCI string' function, but since we copied the DCI
    // string into str[] above using dcitos(), we can get the same effect by
    // copying that using stodci() here.
    lastsym = lastsym + stodci(@str, lastsym)
    lastsym=>0 = addr
    lastsym    = lastsym + 2
    ^lastsym   = 0 // end of table
end
#endif
//
// String routines.
//
export def strcpy(dstSFTODO, srcSFTODO)#1
    memcpy(dstSFTODO+1, srcSFTODO+1, ^srcSFTODO)
    ^dstSFTODO = ^srcSFTODO
    return dstSFTODO
end
export def strcat(dstSFTODO, srcSFTODO)#1
    memcpy(dstSFTODO + ^dstSFTODO + 1, srcSFTODO + 1, ^srcSFTODO)
    ^dstSFTODO = ^dstSFTODO + ^srcSFTODO
    return dstSFTODO
end
#ifndef STANDALONE
// TODO: If this has only one caller we might be as well to inline it - but
// maybe that's over-optimisation.
def lookupextern(esd, index)#1
    word sym, addr
    byte str[maxnamelen+1]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if esd->0 & $10 and esd->1 == index
            addr = lookupsym(sym)
	    if !addr
                perr = $81
	        putc('?')
		puts(@str)
		putln
	    fin
            return addr
        fin
        esd = esd + 3
    loop
    return 0
end
//
// Indirect interpreter DEFinition entrypoint
//
// SFTODO: It's probably fine, but for my own satisfaction should later check to
// see that the last DEF in a module *is* still eligible for being JITted
// despite the "patch up the previous entry to use the JIT entry point"
// approach.
#ifndef JIT
def adddef(addr, deflast)#1
    word defentry
    defentry = *deflast
    *deflast = defentry + 5
    defentry->0 = $20
    defentry=>1 = *iinterpptr
    defentry=>3 = addr
    defentry->5 = 0 // NULL out next entry
    return defentry
end
#else
def adddef(isfirst, addr, deflast)#1
    word preventry, defentry, defsize

    defentry = *deflast
    *deflast = defentry + t_defentry
    if not isfirst
        preventry = defentry - t_defentry
        defsize   = addr - preventry=>bytecodeaddr
        if defsize <= jitsize and *jitcomp <> 0
            preventry=>interpaddr   = *jitiinterpptr // JSR JITIINTERP
            preventry->callcount    = jitcount // Set JIT countdown
            preventry->bytecodesize = defsize  // Set size
        fin
    fin
    defentry->interpjsr    = $20
    defentry=>interpaddr   = *iinterpptr // JSR IINTERP
    defentry=>bytecodeaddr = addr
    defentry->t_defentry   = 0 // NULL out next entry
    return defentry
end
#endif
def modname_default(modcr)#0
    // Default implementation does nothing
end
// Load the module whose name is 'moddci' (a DCI string) from the file 'modcr'
// (a CR-terminated string); modcr points to at least maxpathlen bytes of space to
// allow modname() to generate a long filename in place if it wants to.
def modloadcr_internal(moddci, modcr)#1
    word rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr
    word modaddr, modfix, modend
    word modofst, defaddr, codefix
    word deftbl, deflast
    word moddep, rld, esd, sym
#ifdef JIT
    byte deffirst, skipjit
#endif
    byte str[maxnamelen+1]
    const header_size = 128
    byte header[header_size]
    byte handle
    byte block[osfile_block_size] // osgbpb_block_size is smaller
    byte file_length[4]

    perr = 0

    // We use OSGBPB to read the first header_size bytes of the module, but we
    // use OSFILE to load the entire module later; tests on Acorn DFS 2.24 on
    // BeebEm suggest OSFILE can load 6.25K in 1.74s compared with 4.47s for
    // OSGBPB. So it's well worth the "waste" of reading the header twice.

    //
    // Perform any transformations on the filename we are going to load from.
    //
    // SFTODO: If modname is ever to be really used, should it return both an
    // open file handle and the filename? Otherwise I would imagine any
    // non-default implementation is going to need to try to open the file from
    // some kind of "library" directory to see if it exists there, and maybe
    // from another location or two before/after, and if it just has to close
    // the file so we can re-open it below that's extra disk activity.
    modname(modcr)#0

    //
    // Read the RELocatable module header (first header_size bytes); we also
    // get the file length while we have the file open.
    //
    handle = call(osfind, osfind_input, modcr, modcr >> 8, 0).0
    if handle == 0
    	// SFTODO: A2 IMPL NOW ATTEMPTS TO OPEN USING A 'SYSTEM PATH' - IS THIS
	// SOMETHING I SHOULD CONSIDER PORTING?
        oserror_not_found(moddci)
    fin
    modload_handle = handle
    block.0 = handle
    block:1 = @header
    block:3 = 0 // second processor if we are running on one, host otherwise
    block:5 = header_size
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    rdlen = header_size - block:5
    call(osargs, osargs_read_ext, scratch, handle, 0)
    file_length:0 = scratch:0; file_length:2 = scratch:2
    modload_handle = 0; call(osfind, osfind_close, 0, handle, 0)

    if rdlen <= 16 or header:2 <> $6502 // magic number
        oserror_bad_module()
    fin

    modsize = header:0
    //
    // This is an EXTended RELocatable (data+bytecode) module.
    //
    // systemflags = header:4 | systemflags
#ifdef JIT
    skipjit  = header.5 & (nojitc >> 8)
#endif
    defofst  = header:6
    defcnt   = header:8
    init     = header:10
    moddep   = @header.12
    //
    // Load module dependencies.
    //
    while ^moddep
        if !lookuptbl(moddep, @symtbl)
            if modload(moddep) < 0
                return -perr
            fin
        fin
        moddep = moddep + dcitos(moddep, @str)
        // Just to be paranoid, let's check for the case where a module has
        // loads of dependencies and they overflow the header. This won't
        // catch everything, as it doesn't check the call to dcitocr()
        // inside the above modload() hasn't overflowed, but it should be
        // fairly reliable in practice.
        if (moddep - @header) >= rdlen
            oserror_bad_module()
        fin
    loop
    //
    // Init def table.
    //
    deftbl   = xheapalloc(defcnt * t_defentry + 1)
    deflast  = deftbl
    ^deflast = 0 // SFTODO: APPLE II JIT CMD.PLA DOESN'T DO THIS, IT MAY WELL BE REDUNDANT BUT I THINK IT'S HARMLESS SO LET'S LEAVE IT IN FOR THE MOMENT AND DELETE IT LATER (THE APPLE II NON-JIT VM DOES DO THIS, I DON'T KNOW IF THIS IS RANDOM OR SOMEHOW RELATED TO JIT FUNCTIONALITY, NEED TO ANALYSE CODE PROPERLY LATER)
    //
    // Add module to symbol table. This may grow the symbol table, so we
    // do it before we allocate space on the heap for the module. Unfortunately
    // that means we don't have the address the module available to pass to
    // addsym(), so we need to patch it up afterwards.
    //
    addsym(moddci, $0000)
    *(lastsym - 2) = *heapptr // modaddr below will be the current *heapptr
    //
    // Check there's room for the entire file onto the heap now any
    // dependencies have been loaded.
    //
    addr = 0
    if file_length:2 <> 0 // if file is >=64K
        oserror_heap_full()
    fin
    rdlen = file_length:0
    addr = xheapalloc(rdlen)
    //
    // Load the file
    //
    block:0 = modcr
    block:2 = addr
    block:4 = 0 // second processor if we are running on one, host otherwise
    block:6 = 0 // ignore file's load address, use our own
    // We check specifically for file found; a directory is no good to us. In
    // reality we don't expect any problems as we already opened the file using
    // OSFILE to read the header.
    if call(osfile, osfile_load_file, @block, @block >> 8, 0).0 <> osfile_file_found
        oserror_not_found(moddci)
    fin
    // To test module loading I/O performance alone, do this here: return 0
    //
    // Release the claim we just made; we really did it only to see if it
    // would fail. The code immediately following will shift the loaded
    // module down to avoid wasting space on the header and claim the
    // required amount of space for the module's data and code.
    //
    heaprelease(addr)
    //
    // Alloc heap space for relocated module (data + bytecode).
    //
    moddep  = moddep  + 1 - @header + *heapptr
    modfix  = moddep  - (*heapptr + 2) // Adjust to skip header
    modsize = modsize - modfix
    rdlen   = rdlen   - modfix - 2
    modaddr = xheapalloc(modsize) // can't fail anyway
    memcpy(modaddr, moddep, rdlen)
    //
    // Apply all fixups and symbol import/export.
    //
    modfix   = modaddr - modfix
    modofst  = modfix  - RELADDR
    modend   = modaddr + modsize
    bytecode = defofst + modofst
    rld      = modend  // Re-Locatable Directory
    esd      = rld     // Extern+Entry Symbol Directory
    while ^esd         // Scan to start of ESD
        esd = esd + 4
    loop
    esd = esd + 1
#ifdef PLAS128
    //
    // Locate bytecode defs in appropriate bank.
    //
    defaddr = allocxheap(rld - bytecode)
    // TODO: If there's only one caller of allocxheap(), might as well fold
    // the following test into allocxheap() itself.
    if defaddr == 0
        oserror_heap_full()
    fin
    modend  = bytecode
#else
    // SFTODO: MAY BE POSSIBLE TO HAND-OPTIMISE AWAY SOME VARIABLES IN THIS CASE, BUT LET'S JUST DO THIS FOR NOW TO BE LIKE A2 CODE WHILE I GET THE LATEST PORT GOING
    defaddr = bytecode
#endif
    codefix = defaddr - bytecode
    defofst = defaddr - defofst
    //
    // Free up the end-of-module data in main memory. We have to do this now
    // as otherwise any symbol table allocations which claim memory from the
    // heap would trap the end-of-module data. However, we still want to use
    // that end-of-module data (the RLD/ESD) below, even after we've freed
    // it. We get away with this because only addsym() is going to allocate
    // from the heap. Any one addsym() call can only touch len(symbol_name) +
    // 2 (symbol address) + 1 (end-of-symbol-table marker) new bytes (it may
    // allocate an extra 2 bytes, to allow for an end-of-symbol-table-chunk
    // marker, but it won't touch them), and each ESD entry is len(symbol_name)
    // + 3 bytes, so even if there are no RLD entries we will not overwrite an
    // ESD entry before it's been consumed. TODO: Double check this reasoning!
    //
    heaprelease(modend)    
    //
    // Run through the DeFinition Dictionary.
    //
#ifdef JIT
    deffirst = 1
#endif
    while ^rld == $02
	//
	// This is a bytecode def entry - add it to the def directory.
	//
#ifndef JIT
	adddef(rld=>1 + defofst, @deflast)
#else
	adddef(deffirst, rld=>1 + defofst, @deflast)
        deffirst = skipjit // Calculate JIT potential or not
#endif
	rld = rld + 4
    loop
    //
    // Run through the Re-Location Dictionary.
    //
    while ^rld
	rld, addr, fixup = reloc(modfix, modofst, bytecode, rld)
	if ^rld
	    *addr = ^rld & $10 ?? *addr + lookupextern(esd, rld->3) :: lookupdef(fixup + codefix, deftbl)
	    rld   = rld + 4
	fin
    loop
#ifdef PLAS128
    //
    // Move bytecode to AUX bank.
    //
    memxcpy(defaddr, bytecode, modsize - (bytecode - modaddr))
#endif
    //
    // Run through the External/Entry Symbol Directory.
    //
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if ^esd & $08
            //
            // EXPORT symbol - add it to the global symbol table.
            //
            addr = esd=>1 + modofst
            if isuge(addr, bytecode)
                //
                // Use the def directory address for bytecode.
                //
                addr = lookupdef(addr + codefix, deftbl)
            fin
            addsym(sym, addr)
            // TODO: The following test could be removed eventually.
            // Assert that the last byte written in the symbol table
            // (lastsym) hasn't trampled over the next ESD entry
            // (at esd + 3).
            if isuge(lastsym, esd + 3)
                oserror(0, "Symbol table clash") // TODO: non-0 error number if (probably won't) lives
            fin
        fin
        esd = esd + 3
    loop
    if perr
        return -perr
    fin
    //
    // Call init routine if it exists.
    //
    fixup = 0
    if init
        init  = init + defofst
        puts("CALLING INIT\n")
#ifndef JIT
	fixup = adddef(init, @deflast)()
#else
	fixup = adddef(deffirst, init, @deflast)()
#endif
        puts("CALLED INIT\n")
	if fixup < modinitkeep
	    //
	    // Free init routine unless initkeep. Because we grow our symbol
	    // table dynamically, we aren't as flexible as the Apple code here.
	    // On PLAS128 we're fine, because the symbol table lives in
	    // main RAM and the bytecode lives in the 'AUX' RAM. On PLAS32
	    // we may have allocated space for a symbol table chunk on top
	    // of the module's RLD/ESD, and that comes *after* the module's
	    // init. However, even on PLAS32 we can free the init code if we
	    // haven't yet exhausted the low symbol table chunk (and therefore
	    // haven't dynamically allocated a new symbol table chunk).
	    //
#ifdef PLAS128
            xheap = init
#else
            if symtblchunk == lowsymtblchunk
                heaprelease(init)
            fin
#endif
	    if fixup < 0
		perr = -fixup
	    fin
	else
	    fixup = fixup & ~modinitkeep
	fin
    fin
#if 0 // TODO: Temporary code for forcing multiple 16K banks to be used for PLAS128 testing
    #ifdef PLAS128
        puth(allocxheap(7000)); putln()
    #endif
#endif
    return fixup
end
def modloadpstr_internal(modpstr, modcr)#1
    byte moddci[maxnamelen]
    if ^modpstr == 0 or ^modpstr > maxnamelen
        oserror_bad_name()
    fin
    stodci(modpstr, @moddci)
    stocr(modpstr, modcr)
    return modloadcr_internal(@moddci, modcr)
end
// Load the module named by the PLASMA string modpstr; this is taken from a
// command line and may be overlong or invalid in some other way.
// For the moment at least, I am going to work on the model that what you type
// after the + sign at the prompt is a module name - never a path of any
// description. modname() allows custom "module name to filename" conversion
// (including potentially locating the module in a directory other than the
// current one and therefore returning a filename with path components), but the
// user input is just a module name. We can therefore validate modpstr and
// convert it to a DCI module name quite naively. It's tempting to replace
// modname() with a function which returns an open file handle, but that isn't
// compatible with our desire to be able to use both OSGBPB and OSFILE to load
// the module.
def modloadpstr(modpstr)#1
    return (@callalloca)(modpstr, @modloadpstr_internal, maxpathlen)#1
end
def modload_internal(moddci, modcr)#1
    dcitocr(moddci, modcr)
    return modloadcr_internal(moddci, modcr)
end
// Load the module named by the DCI string moddci; this is taken from a module
// reference in another module and therefore should be valid (e.g. not
// arbitrarily long).
export def modload(moddci)#1 // SFTODO: IS THIS NO LONGER EXPORTED ON APPLE?
    return (@callalloca)(moddci, @modload_internal, maxpathlen)#1
end
#endif
#ifndef STANDALONE
//
// Command mode
//
def parsemodname()#1
    byte seenplus, skipspaces, i, c
    // We can get away with using scratch to hold the module name because it's not needed
    // for very long; modloadpstr_internal() copies/converts it before anything else
    // can overwrite scratch.
    const buf = scratch

    ^buf = 0
    seenplus = false
    skipspaces = true
    for i = 1 to ^syscmdln
        c = ^(syscmdln + i)
        if not seenplus
            seenplus = (c == '+')
        elsif c == ' '
            if not skipspaces
                break
            fin
        else
            skipspaces = false
            ^buf = ^buf + 1
            if ^buf > maxnamelen
                oserror_bad_name()
            fin
            ^(buf + ^buf) = c
        fin
    next
    return buf
end
def parsecmd(strptr)#1
    byte i, cmd

    for i = 1 to ^strptr
        cmd = ^(strptr + i)
        if cmd > ' ' 
            return cmd
        fin
    next
    return 0
end
#endif
// User code could choose to install an alternate error handler, but
// it's probably not a good idea; most of the time user code should
// restrict itself to manipulating *errjb.
def error_handler()#0
  // The error number is available to the target at ^errnum; throw() naturally
  // passes along a value so it's tempting to pass the error number using it,
  // but it can't send a value of 0 (which is a valid error number) so we don't
  // do that as it just adds to the temptation to write not-quite-correct client
  // code. (Passing 0 saves a few bytes in the VM; this will be turned into 1
  // by throw() internally, not that anything is likely to examine the value.)
  throw(*errjb, 0)
end
#ifndef STANDALONE
def modexec(modfile)#1
    word saveheap
#ifdef PLAS128
    word savexheap
#endif
    word savesym, savesymtblchunk
    // word saveflags
#ifdef JIT
    word savejit
#endif
    word error, action, olderrjb, jb

    saveheap  = *heapptr
#ifdef PLAS128
    savexheap = xheap
#endif
    savesym   = lastsym
    savesymtblchunk = symtblchunk
    // saveflags = systemflags
#ifdef JIT
    savejit = *jitcodeptr
#endif
    modload_handle = 0
    olderrjb = *errjb
    // We allocate a jmp_buf on the heap using except2(); it will get trapped
    // and leaked if the module being executed remains resident, but that can't
    // really be helped (and it will be fairly small). We can't allocate a
    // local jmp_buf because the address of it would change if the executed
    // module changes mode and thereby alters HIMEM; mode() will relocate
    // the frame stack but it won't patch up the address at *errjb.
    error = except2(@jb)
    if error == 0
        *errjb = jb
        puts("CALLING MODLOAD\n");
        action = modloadpstr(modfile)
        puts("CALLED MODLOAD\n");
    fin
    *errjb = olderrjb
    if error <> 0 or action < modkeep
        if modload_handle <> 0
            call(osfind, osfind_close, 0, modload_handle, 0)
        fin

        lastsym     = savesym
        symtblchunk = savesymtblchunk
        ^lastsym    = 0
        lastsym=>1  = 0
#ifdef PLAS128
        xheap       = savexheap
#endif
        *heapptr    = saveheap
    fin
    // systemflags = saveflags
#ifdef JIT
    *jitcodeptr = savejit
#endif
    if error <> 0
        error_handler()
    fin
    return -perr
end
#endif
#ifndef STANDALONE
// The parsing in here is deliberately naive to avoid bloating the virtual
// machine too much. It also works in our favour because parsecmd() only pays
// attention to the first character, so this means that "M7" and "MODE 7" both
// work (as, in fact, will things like " M O D E    1 3  5").
def modechange(cmdptr)#0
    word n, i
    byte c
    n = 0
    i = 1
    while i <= ^cmdptr
	c = ^(cmdptr + i)
	if c >= '0' and c <= '9'
	    n = (n * 10) + (c - '0')
	fin
	i++
    loop
    if not mode(n)
        // It doesn't really matter (the error is only shown to the user at the
        // prompt, not seen by any code which might check it) but we use the
        // same error number as BASIC here. (Code changes mode using mode()
        // which returns a boolean success/failure indicator instead of raising
        // an error.)
	oserror(25, "Bad mode")
    fin
end
#endif
#ifdef TIME
def time(t)#0
    call(osword, osword_read_time, t, t >> 8, 0)
end
#endif 
//
// Command line processor
//
def docmds#0
    #if defined(PLAS128) && defined(ALLOCXHEAPTEST)
    word size, ptr
    #endif
    //
    // Set up error handler
    //
    if except2(errjb) == 0
      *errfp = @error_handler
    else
    #ifndef STANDALONE
      putln
      puts(@errorstr)
      putb(^errnum)
      puts(@colonstr)
      puts(errstr)
      putln
      // We must put a zero-length string at syscmdln so we don't try to interpret the
      // junk at syscmdln/inbuff (in practice, the error number) as a command to execute;
      // that's only relevant when we first start up.
      ^syscmdln = 0
    #endif
    fin
    #ifndef STANDALONE
    perr = 0
    //
    // Print some startup info.
    //
    // startup somehow?
    if not ^syscmdln
        // SFTODO: Will we print this banner every time an OS error occurs? I am not sure that's really right, should re-print the prompt but not the banner.
        // SFTODO: Should I vary the banner with PLAS128 and/or JIT flags? Don't
        // really want to bloat the VM with this really, so perhaps not. Also remember
        // the JIT module prints "JITC enabled" itself.
        // SFTODO: SHOULD I RENAME PLAS128 AS PLASSWR? I FEEL AN ODD AFFECTINO FOR THE OLD NAME THO
        puts("PLASMA 2.0 Dev\n") //puts(@verstr); putb(version.1); putc('.'); putb(version.0); putln
        // TODO: Temporarily moved this to prompt instead of only displaying it
        // on startup; this makes it more obvious if heap gets leaked.
        //puts(@freestr)
        //puth(heapavail)
    #ifdef PLAS128
        //puts(@xfreestr)
        //puth(xheapfree(xheap))
    #endif
        //putln
    fin

    #ifdef JIT
        // On startup *jitcomp is set to 1; this triggers one attempt to load the JIT module, if
        // that fails for any reason (we don't have enough heap, the JIT module can't be found, etc)
        // an OS error will occur and *jitcomp will be 0 so the JIT will simply be disabled. (The
        // OS error isn't necessarily all that clear, but we don't expect this to happen - the main
        // thing is that we don't go into an infinite loop or similar.)
        if *jitcomp == 1
            *jitcomp = 0
            #ifndef PLAS128
                modloadpstr("JIT")
            #else
                // SFTODO: On P128JIT, the presence of this "JIT128" string in the string pool
                // means the memory free is 7 bytes *lower* than it is after the first error!
                // This worried me until I figured out why. Is there anything I can do about
                // this? Obviously if I add more code to cause that memory to be freed up
                // then I am just burning off the 7 bytes saved *anyway*, but just possibly
                // some alternative (perhaps using the manual "string pool" method for this
                // string) would be worth it. Probably not, but I should at least have a
                // permanent comment about this to avoid figuring it out a second time.
                modloadpstr("JIT128")
                // Allocate the remainder of the first sideways RAM bank to JITted
                // machine code.
                *jitcodeptr = $8000 + xheap
                // SFTODO: We could just do "xheap = xheap_bank_size" here and that
                // may well be best in the long run, but let's stick with this for
                // now as that way we avoid making any assumptions about how exactly
                // allocxheap() chooses to manage xheap "at" the page boundaries.
                allocxheap(xheap_bank_size - xheap)
            #endif
        fin
    #endif
    #if defined(PLAS128) && defined(ALLOCXHEAPTEST)
    size = $50
    while 1
        puts("xheap=$"); puth(xheap)
        puts(", xheapfree()=$"); puth(xheapfree(xheap))
        ptr = allocxheap(size)
        puts(", allocxheap($"); puth(size); puts(")=$"); puth(ptr)
        putln()
        if ptr == 0 and size > 0
            size = size - 1
        fin
    loop
    #endif
    // Note that the Apple II VM copies the command line to @cmdln (==syscmdln),
    // leaves it alone and then modifies the original copy of the command line
    // in place while parsing it here in the core VM. In order to avoid needing
    // an extra 256 bytes of memory for a copy, the Acorn port doesn't do that;
    // syscmdln points directly to the gets() buffer and this code does *not*
    // modify it at all, so it's in a fit state for parsing by the args.pla
    // module. Apart from causing a few small differences here in the VM code,
    // the main user-visible implication of this is that on the Acorn VM code
    // which calls gets() or experiences an OS error and catches it via except()
    // before parsing the command line arguments with the args module will
    // find they have been corrupted. I don't think either of these cases is
    // terribly likely (note that experiencing an OS error and *not* catching
    // it will cause the module to stop executing and return control to the VM,
    // which works fine) and unless/until some good use case for this comes up I
    // think it's better to save the 256 bytes. (I suppose we could potentially
    // allocate just enough space for the copy on the heap, but that would be
    // extra code and still waste some space which this approach saves.)
    // (Incidentally, Dave told me the reason the Apple II copies the command
    // line is that the input buffer is lost when loading files; it's still true
    // that the Apple code allows the possibility of using gets() without
    // destroying the command line, but this wasn't the motivation for it.)
    while 1
        // SFTODO TEMP HACK
        puts("TOP OF DOCMDS LOOP\n")
        // SFTODO END TEMP HACK
        if ^syscmdln
            // SFTODO: I SHOULD PROB "NEVER" PASS syscmdln OR "ALWAYS" PASS IT - AT THE MOMENT PARSEMODNAME IS AN EXCEPTION
            when toupper(parsecmd(syscmdln))
                is 'M'
                    modechange(syscmdln)
                    break
                is '+'
    #ifdef TIME
                    time(@start_time)
    #endif
                    modexec(parsemodname())
                    // SFTODO: THE A2 VERSION ALSO CLOSES ALL FILES HERE; I SUSPECT THAT'S NOT REALLY A VERY "ACORN" THING TO DO (EG IT BREAKS USE OF *SPOOL) BUT THINK ABOUT IT AND MAYBE LEAVE PERMANENT COMMENT IN IF I DON'T IMPLEMENT THIS - IT FEELS HORRIBLY HACKY, BUT COULD WE JUST CLOSE ALL FILE HANDLES EXCEPT THE *EXEC AND *SPOOL HANDLES? THOSE ARE AVAILABLE IN LOW MEM ON HOST AND WE CAN PROB READ THEM SOMEHOW IN A TUBE COMPATIBLE WAY. NOT SURE I LIKE THIS BUT THINK ABOUT IT, MAYBE ASK ON STARDOT FOR ADVICE. - OK, PERHAPS THE WAY TO DO THIS (IF IT DOESN'T BLOAT THINGS TOO MUCH) IS TO SET ASIDE 256/8=32 BYTES OF RAM FOR A BITMAP OF "OPEN FILES" AND HAVE FILEIO UPDATE THAT AND THEN THE VM CAN USE IT TO CLOSE FILES AUTOMATICALLY AFTER EXECUTING A MODULE - I SUPPOSE ALTERNATIVELY IT COULD STORE THE ACTUAL FILE HANDLES IN A FEW BYTES OF RAM, SINCE WE HAVE MAX_IOBUFS = 4 - THAT MEANS IF WE ALWAYS KEEP "UNUSED" BYTES AT 0 WE ONLY NEED 4 BYTES OF (PROBABLY) PAGE 4 FOR THIS
    #ifdef TIME
                    time(@end_time)
                    // We don't want to use the dword library here so we just accept we can
                    // only return small time deltas correctly using 16-bit arithmetic and
                    // signed output.
                    puts("\nTook "); puti(end_time:0 - start_time:0); puts(" cs\n")
    #endif
                    break
                is '*'
                    call_oscli(syscmdln)
                    break
                otherwise
                    puts(@huhstr)
            wend
            if perr
                puts(@errorstr)
                putb(perr)
                perr = 0
            else
                puts(@okstr)
            fin
            putln()
        fin
        puts(@freestr)
        puth(heapavail)
    #ifdef PLAS128
        puts(@xfreestr)
        puth(xheapfree(xheap))
    #endif
        putln
        puts(@prompt)
        gets(':') // we know this returns string at inbuff == syscmdln
    loop
    #endif
end
//
// Dummy definition to get free heap
// SFTODO: ANNOYINGLY ALL THIS DOCMDS SUPPORT STUFF *SAVES* 29-30 BYTES ON NON-TUBE BUT *COSTS* 30 BYTES ON TUBE; PROBABLY NOTHING I CAN DO ABOUT IT BUT CAN'T HELP WONDERING IF I SHOULDN'T DO IT. I REALLY DON'T WANT TO FORK OFF A HIPLASMA BINARY (GIVING ME 5 IN TOTAL!) THOUGH, EVEN IF IT WOULD ALLOW ME TO AVOID MAKING TUBE PAY FOR STUFF IT DOESN'T NEED (AT THE COST OF PERHAPS UNACCEPTABLE MACHINATIONS TO "MOVE" THE CONTENTS OF DOCMD INTO THE RIGHT PLACE ON ALL BUILDS
//
def lastdef#0
end
//
// Get heap start. If we're not running on a second processor, we can start it at @lastdef
// to allow us to avoid wasting RAM on this one-off initialisation bytecode. On a second
// processor we must start the heap at the location the assembly language startup code has
// stored for us at *freemem, because the "one-off" initialisation code needs to be
// available for execution on soft break.
//
if *freemem == 0
    *heapptr = @lastdef
else
    *heapptr = *freemem
fin
#ifndef STANDALONE
//
// Init globals; see note at top about why we have to do this.
//
symtblchunk = lowsymtblchunk
lastsym = lowsymtblchunk
modname = @modname_default
#ifndef JIT
    *jitcomp = 2 // indicates non-JIT VM to JIT module if it is loaded by user
#else
    *jitcomp = 1
#endif
//
// Init symbol table.
//
^lastsym = 0 // end of symbol table
#endif
docmds()
done

// SFTODO: General comment - I should probably review the code to see that if an OS error occurs during module loading, we do not leak any heap. We *don't* reset the heap to the initial pointer when an OS error reaches the top level exception handler - this is correct, because we might have a resident module loaded on the heap - but it does mean we need to be careful not to allow memory to be leaked. To be fair, since I print the heap free at the prompt I'd probably notice if this was happening and I don't think I have, but it would be good to review the code anyway. And perhaps leave a permanent comment somewhere about the importance of this, and why we don't just reset the heap pointer in the top-level error handler.
