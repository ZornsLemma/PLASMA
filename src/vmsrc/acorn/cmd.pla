// OK, this is a bit ugly... We (mis)use the C preprocessor to allow
// this file to be conditionally compiled to build PLASMA ("PLAS32") and
// PLAS128, based on whether PLAS128 is defined or not. plvmbb.s also
// uses an ACME constant called PLAS128 to provide conditional assembly there.
// Because this file contains inline ACME assembler which wants to be able to
// say things like '!IFDEF PLAS128', it's important that PLAS128 is defined to
// be 'PLAS128', so that the C preprocessor effectively leaves those !IFDEF
// lines alone. We could simply make sure we define it to the appropriate value
// in the makefile, but it seems safest and slightly cleaner (since it gives us
// a place to write this comment) to enforce this here.
#ifdef PLAS128
    #undef PLAS128
    #define PLAS128 PLAS128
#endif

// If TIME is defined, additional code is included to print the time spend
// executing a module. This is a development-only feature but it's useful
// enough to leave the code around to be conditionally included as required.
// #define TIME

include "inc/acornc.plh"

// Where the VM generates errors which are PLASMA-specific, these should of
// course be in the range 0-127 as they are language errors. I've decided to
// informally allocate 0-15 to the low-level VM code in plvmbb*.s and 16-127 to
// the code in this file.

// TODO: Weird - *SPOOL Z then *PLAS128 *immediately* closes the *SPOOL file.
// *PLASMA doesn't exhibit this. Note that there's no need to load a module,
// the startup banner and prompt don't make it into the spool file. Oh no,
// this is a consequence of the current futzing around to try to make it
// run on I/O processor when 2P is active. If that works out in the end,
// this is probably acceptable. (However, possibly not. Does this cause
// problems if a *EXEC-able !BOOT file wants to do something like:
// *PLAS128
// +MYPROG
// If it does this might be unacceptable. Possibly it would be nice to allow
// a command to be executed to be given as an argument to PLAS128 - then you
// could do '*PLAS128 +MYPROG' - but even then losing the flexibility of the
// *EXEC !BOOT option isn't ideal. I haven't tested to see if this does break
// that case yet.) OK, I have now tested - yes, on a second processor such a
// !BOOT does stop without "typing" in the +MYPROG. It *does* work fine if you
// don't have a second processor turned on, so arguably this is not too big a
// deal - the alternatives are "if there is a second processor, do we refuse to
// run PLAS128 or run it but refuse to accept any commands via *EXEC"

const RELADDR      = $1000

// The following constants must be kept in sync with vmsrc/plvmzp.inc and
// vmsrc/acornc.inc.

// Note that we cannot rely on initialisation of non-constant globals; on
// PLAS32 running on a second processor, the VM is re-entered on BREAK and
// any globals will have their post-modification values, not the original
// values.

const inbuff       = $0700
const errnum       = $0700
const errstr	   = $0701
const freemem      = $0006 	// 'SRC' zp, used to indicate heap start
const ifp          = $0071
#ifdef PLAS128
    const pp           = $0073
#endif
const himemh       = $0078
const scratch	   = $0079
#ifdef PLAS128
    const rambankcount = $0404
#endif
const errfp	   = $0405	// 2 bytes
const errjb	   = $0407	// 2 bytes

#ifndef STANDALONE
// TODO: I am currently very wasteful of memory in $400-$800; for
// now we just allot this little part of it for the initial symbol
// table, but this can probably be expanded later as the memory use
// is tided up
const lowsymtblchunk = $419 // SFTODO: SHOULD BE $0409, TEMPORARILY BLATTED UP RATHER ARBITRARILY TO GET SOME WORKING SPACE FOR INITIAL JIT HACKS....
const lowsymtblchunksz = $50 // $150 // TODO $02f7 (OR SHOULD PROBABLY BE '$0700 - lowsymtblchunk' OR SIMILAR)

const maxnamelen = 16 // characters; need +1 for PLASMA string
const maxpathlen = 256
#endif
const false = 0
const true = not false
// TODO: allocheap_fail_threshold should probably be a non-constant
// and be modifiable under program control (if so, '+foo' should
// probably reset it to a default on successful or unsuccessful
// execution). While we're developing, we just stick with this.
const allocheap_fail_threshold = $FFFF
//
// Module don't free memory
//
const modkeep     = $2000
const modinitkeep = $4000
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    byte callcount
    byte bytecodesize
end
//
// JIT compiler constants
//
const jitcomp     = $0409
const jitcodeptr  = $040B
//
// Predefined functions.
//
// TODO: It would be nice if these could be omitted and we could 'include
// "inc/cmdsys.plh"' instead, but this doesn't seem to work. Perhaps try this
// kind of thing with upstream compiler and ask Dave.
predef syscall(cmd,params)#1, call(addr,areg,xreg,yreg,status)#1
predef putln()#0, putc(c)#0, puts(s)#0, getc()#1, gets(p)#1
predef heapmark()#1, heapalloc(size)#1, xheapalloc(size)#1, heapallocalign(size, pow2, freeaddr), heaprelease(newheap)#1, heapavail()#1
predef memset(addr,value,size)#0, memcpy(dst,src,size)#0
predef strcpy(dst,src)#1, strcat(dst,src)#1
predef isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1, sext(a)#1
predef modload(mod)#1, modexec(modfile)#1
predef except(b)#1, except2(bptr)#1, throw(b, val)#0
predef prbyte(b)#0, prword(w)#0
predef oserror(n, msg)#0
predef call_oscli(str)#0
predef stocr(str, cr)#0
predef mode(n)#1
predef callalloca
predef divmod(dividend, divisor)#2
predef puti(i)#0
predef toupper(c)#1
//
// Exported CMDSYS table
//
word version     = $0200 // 02.00 Dev
word syspath // SFTODO? NEED THIS ANYWAY FOR INC/CMDSYS.PLH
word syscmdln // SFTODO? NEED THIS ANY WAY FOR INC/CMDSYS.PLH
word            = @modexec
// SFTODO: Apple II version now exports @open, @close, @read, @write, not sure
// what to do about that. For the moment I am going to at least have to include
// them as null pointers because I need to expose jitcount and jitsize, and
// cmdsys.plh is a shared header so I have to have them at the same relative
// offset.
word = 0, 0, 0, 0 // dummy open, close, read, write
byte perr // SFTODO: This is cmdsys's 'syserr', I am not sure I always write to perr so there may be an incompatibility here - for the moment I don't think anything cares and I am trying to get the JIT working, but this area needs revisiting later on
// SFTODO: I don't think I can rely on initialisation of these globals due to the
// way the VM is re-entered on the Tube on BREAK, but for now let's just not
// care about that.
byte jitcount    = 0
byte jitsize     = 0
// SFTODO: The Apple II VM doesn't seem to have refcons and devcons allocated
// here, and they are Apple /// specific, so maybe I don't need them either.
byte refcons     = 0 // SFTODO? NEED THIS ANYWAY FOR INC/CMDSYS.PLH
byte devcons     = 0 // SFTODO? NEED THIS ANYWAY FOR INC/CMDSYS.PLH
//
// Globals
//
// word systemflags = 0 TODO: delete this? commented out for now
// SFTOD: We probably need to reinstance systemflags (perhaps it can be a byte
// though?) now as we probably want to support nojitc. Maybe there's some other
// way to handle this, let's not worry about it for now.
const heapptr = $0089
#ifdef PLAS128
    word xheapsize
    // We leave $8000-$8008 inclusive free in each 16K sideways RAM bank
    // to avoid the risk of the data accidentally looking like a valid
    // sideways ROM header.
    const xheap_bank_start = $09
    const xheap_bank_size = 16 * 1024
    word xheap = xheap_bank_start
#endif
#ifndef STANDALONE
word symtblchunk
word lastsym
//
// String pool.
// We don't strictly speaking need this, now that the CS opcode uses string
// pooling in PLAS128 in a way which works even if there's a mode change
// between two executions of the same CS opcode. However, not using this
// manual string pool only saves 12 bytes in PLAS32 and it costs 5 bytes in
// PLAS128, because we need a copy of the string in the binary and on the
// parameter stack (the binary is in main RAM here, not in sideways
// RAM), so we stick with it. TODO: We could in principle conditionally
// compile this, but it's awfully fiddly.
//
byte verstr[]     = "PLASMA "
byte freestr[]    = "MEM FREE:$"
#ifdef PLAS128
    byte xfreestr[]	  = ", AUX FREE:$"
#endif
byte errorstr[]   = "ERR:$"
byte prompt[]     = "PLASMA"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte colonstr[]   = ": "
#endif
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
#ifdef TIME
byte start_time[osword_read_time_block_size]
byte end_time[osword_read_time_block_size]
#endif
//
// Exported Machine ID. We somewhat arbitrarily assign the apparently free code
// $C8 for all Acorn machines; once you know you're on an Acorn machine you can
// use something like OSBYTE 0 to determine the exact model.
//
export byte machid       = $C8
#ifndef STANDALONE
//
// Command line pointer
//
word cmdptr
//
// File handle used by modload (so we can close it if an error occurs)
//
byte modload_handle
//
// Pointer to function used to transform a module name into a filename; used to
// allow a user to load a resident module to override the default
// small-but-simplistic implementation.
//
word modname
#endif
//
// Global variables for use by mode()
//
word gm_himem_delta
word gm_new_frame_start
#ifdef PLAS128
    word gm_new_ifp
#endif
word gm_copy_from
word gm_copy_size
byte gm_new_mode
#ifndef STANDALONE
//
// Standard Library exported functions.
//
include "vmsrc/acorn/symtab.pla"
#endif
// TODO: DO I NEED saveX/restoreX AS IN CMD.PLA? (THESE HAVE NOW BEEN REMOVED
// FROM LATEST APPLE CMD.PLA, SO MAYBE NOT)
//
// CALL 6502 ROUTINE
// CALL(ADDR, AREG, XREG, YREG, STATUS)
//
export asm call(addr,areg,xreg,yreg,status)#1
REGVALS =   SRC
        PHP
        LDA     ESTKL+4,X
        STA     TMPL
        LDA     ESTKH+4,X
        STA     TMPH
        LDA     ESTKL,X
        PHA
        LDY     ESTKL+1,X
        LDA     ESTKL+3,X
        PHA
        LDA     ESTKL+2,X
        INX
        INX
        INX
        INX
        STX     ESP
        TAX
        PLA
        PLP
        JSR     JMPTMPX
        PHP
        STA     REGVALS+0
        STX     REGVALS+1
        STY     REGVALS+2
        PLA
        STA     REGVALS+3
        LDX     ESP
        LDA     #<REGVALS
        LDY     #>REGVALS
        STA     ESTKL,X
        STY     ESTKH,X
        PLP
        RTS
end
//
// SET MEMORY TO VALUE
// MEMSET(ADDR, VALUE, SIZE)
//   With optimizations from Peter Ferrie
//
export asm memset(addr,value,size)#0
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	LDY     ESTKL,X
	BEQ     +
	INC     ESTKH,X
	LDY     #$00
+	LDA     ESTKH,X
	BEQ     SETMEX
SETMLPL	CLC
	LDA     ESTKL+1,X
SETMLPH	STA     (DST),Y
	DEC     ESTKL,X
	BEQ     ++
-	INY
	BEQ     +
--	BCS     SETMLPL
	SEC
	LDA     ESTKH+1,X
	BCS     SETMLPH
+	INC     DSTH
	BNE     --
++	DEC     ESTKH,X
	BNE     -
SETMEX	INX
	INX
	INX
	RTS
end
//
// COPY MEMORY
// MEMCPY(DSTADDR, SRCADDR, SIZE)
//
export asm memcpy(dst,src,size)#0
	INX
	INX
	INX
	LDA	ESTKL-3,X
	ORA	ESTKH-3,X
	BEQ	CPYMEX
	LDA	ESTKL-2,X
	CMP	ESTKL-1,X
	LDA	ESTKH-2,X
	SBC	ESTKH-1,X
 	BCC	REVCPY
;
; FORWARD COPY
;
	LDA	ESTKL-1,X
	STA 	DSTL
	LDA	ESTKH-1,X
	STA 	DSTH
	LDA	ESTKL-2,X
	STA 	SRCL
	LDA	ESTKH-2,X
	STA 	SRCH
	LDY	ESTKL-3,X
	BEQ	FORCPYLP
	INC 	ESTKH-3,X
	LDY	#$00
FORCPYLP LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL-3,X
	BNE	FORCPYLP
	DEC	ESTKH-3,X
	BNE	FORCPYLP
	RTS
;
; REVERSE COPY
;
REVCPY	;CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-1,X
	STA	DSTL
	LDA	ESTKH-3,X
	ADC	ESTKH-1,X
	STA	DSTH
	CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-2,X
	STA	SRCL
	LDA	ESTKH-3,X
	ADC	ESTKH-2,X
	STA	SRCH
	DEC	DSTH
	DEC	SRCH
	LDY	#$FF
	LDA 	ESTKL-3,X
	BEQ	REVCPYLP
	INC 	ESTKH-3,X
REVCPYLP LDA	(SRC),Y
	STA	(DST),Y
	DEY
	CPY	#$FF
	BNE	+
	DEC	DSTH
	DEC	SRCH
+	DEC 	ESTKL-3,X
	BNE	REVCPYLP
	DEC	ESTKH-3,X
	BNE	REVCPYLP
CPYMEX	RTS
end
//
// result, remainder = divmod(dividend, divisor)
//
export asm divmod(a,b)#2
        JSR     INTERP          ; CALL INTERP
        !BYTE   $36, $5C        ; DIVMOD, RET
end
export asm sext(a)#1
        LDY     #$00
        LDA     ESTKL,X
        BPL     +
        DEY
+       STY     ESTKH,X
        RTS
end
//
// Unsigned word comparisons.
//
export asm isuge(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isule(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isugt(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isult(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
#ifndef STANDALONE
//
// Addresses of internal routines.
//
asm iinterp()#1
	DEX
	LDA	#<IINTERP
	STA	ESTKL,X
	LDA	#>IINTERP
	STA	ESTKH,X
	RTS
end
asm jitiinterp()#1
	DEX
	LDA	#<JITIINTERP
	STA	ESTKL,X
	LDA	#>JITIINTERP
	STA	ESTKH,X
	RTS
end 
// 
// A DCI string is one that has the high bit set for every character except the last.
// More efficient than C or Pascal strings.
//
//def dcitos(dci, str)
//    byte len, c
//    len = 0
//    repeat
//        c = (dci).[len]
//        len = len + 1
//        (str).[len] = c & $7F
//    until !(c & $80)
//    ^str = len
//    return len
//end
asm dcitos(dci, str)#1
	JSR	INITDSTSRCY
-	LDA	(SRC),Y
	CMP	#$80
	AND	#$7F
	INY
	STA	(DST),Y
	BCS	-
	TYA
	LDY	#$00
	STA	(DST),Y
        INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
//def stodci(str, dci)
//    byte len, c
//    len = ^str
//    if len == 0
//        return 0
//    fin
//    c = toupper((str).[len]) & $7F
//    len = len - 1
//    (dci).[len] = c
//    while len
//    	c = toupper((str).[len]) | $80
//    	len = len - 1
//    	(dci).[len] = c
//    loop
//    return ^str
//end
asm stodci(str,dci)#1
	JSR	INITDSTSRCY
        INX
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
#endif
export asm toupper(c)#1
	LDA     ESTKL,X
TOUPR	AND     #$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SBC     #$1F
+	STA     ESTKL,X
	RTS
end
#ifndef STANDALONE
// Convert a DCI string to an Acorn OS-style string terminated by CR
// int dcitocr(dci, cr) - returns length (of DCI string/excluding CR)
asm dcitocr(dci, cr)#1
	JSR	INITDSTSRCY
	INX
	STY	ESTKH,X
-	LDA	(SRC),Y
	CMP	#$80		; set C iff >= $80
	AND	#$7F
	STA	(DST),Y
	INY
	BCS	-
	LDA	#$0D
	STA	(DST),Y
	STY	ESTKL,X
	RTS
end
#endif
// Converts a PLASMA string to an Acorn OS-style string terminated by CR
// void stocr(str, cr)
export asm stocr(str, cr)#0
	JSR	INITDSTSRCY
        INX
	INX
	STX	ESP
	LDA	(SRC),Y
	BEQ	+
	TAX
-	INY
	LDA	(SRC),Y
	DEY
	STA	(DST),Y
	INY
	DEX
	BNE	-
+	LDA	#$0D
	STA	(DST),Y
	LDX	ESP
	RTS
INITDSTSRCY
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
        RTS
end

#ifndef STANDALONE
//
// Module symbols are entered into the symbol table
// pre-pended with a '#' to differentiate them
// from normal symbols.
//
//def modtosym(mod, dci)
//    byte len, c
//    (dci).0 = '#'|$80
//    len = 0
//    repeat
//        c = (mod).[len]
//        len = len + 1
//        (dci).[len] = c
//    until !(c & $80)
//    return dci
//end
// SFTODO: THIS MAY HAVE BEEN REMOVED FROM APPLE 2 PORT, NOT SURE YET
asm modtosym(mod,dci)#1
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDA	ESTKL,X
	STA	ESTKL+1,X
	STA	DSTL
	LDA	ESTKH,X
	STA	ESTKH+1,X
	STA	DSTH
	INX
	LDY	#$00
	LDA	#'#'+$80
-	STA	(DST),Y
	ASL
	LDA	(SRC),Y
	INY
	BCS	-
	RTS
end
//
// Lookup routines.
//
asm lookuptbl(dci, tbl)#1
	JSR	INITDSTSRCY
.NEXT	LDY	#$00
.NEXTY	LDA	(DST),Y
	BEQ	.TABLEEND
        CMP	#$01
        BEQ	.CHUNKEND
	CMP	(SRC),Y
	BNE	.NOTMATCH
	INY
	ASL
	BCS	.NEXTY
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
.EXIT	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
.TABLEEND
        TAY
        BEQ	.EXIT
.NOTMATCH
	LDY	#$00
.SKIP	LDA	(DST),Y
	INC	DSTL
	BEQ	.DSTCARRY
.DSTCARRYDONE
	ASL
	BCS	.SKIP
	LDA	#$02
	ADC	DSTL
	STA	DSTL
	BCC	.NEXTY
	INC	DSTH
	BCS	.NEXTY
.DSTCARRY
	INC	DSTH
	BNE	.DSTCARRYDONE
.CHUNKEND 
	LDY	#$02
	LDA	(DST),Y
	PHA
	DEY
	LDA	(DST),Y
	STA	DSTL
	PLA
	STA	DSTH
	BNE	.NEXT
end
// def lookupidx(esd, index)
//    word sym
//    while ^esd
//        sym = esd
//        esd = sym + dcitos(sym, @str)
//        if esd->0 & $10 and esd->1 == index
//            return sym
//        fin
//        esd = esd + 3
//    loop
//end
asm lookupidx(esd, index)#1
        LDA     ESTKL,X
        STA     TMPL
        INX
---     LDA     ESTKH,X
        STA     SRCH
        LDA     ESTKL,X
--      STA     SRCL
        LDY     #$00
-       LDA     (SRC),Y
        BPL     +
        INY
        BNE     -
+       BEQ     ++              ; END OF ESD
        INY
        LDA     (SRC),Y
        INY
        AND     #$10            ; EXTERN FLAG?
        BEQ     +
        LDA     (SRC),Y
        CMP     TMPL
        BEQ     +++             ; MATCH
+       INY
        TYA
        SEC
        ADC     SRCL
        STA     ESTKL,X         ; SYM PTRL
        BCC     --
        INC     ESTKH,X         ; SYM PTRH
        BNE     ---
++      STA     ESTKL,X         ; END OF ESD
        STA     ESTKH,X
+++     RTS
end
//def lookupdef(addr, deftbl)#1
//    while deftbl->interpjsr == $20
//        if deftbl=>bytecodeaddr == addr
//            return deftbl
//        fin
//        deftbl = deftbl + t_defentry
//    loop
//    return 0
//end
asm lookupdef(addr, deftbl)#1
        LDA     ESTKH,X
        STA     SRCH
        LDA     ESTKL,X
        STA     SRCL
        INX
-       LDY     #$00
        LDA     (SRC),Y
        CMP     #$20            ; JSR OPCODE?
        BNE     ++
        LDY     #$03
        LDA     (SRC),Y
        CMP     ESTKL,X
        BNE     +
        INY
        LDA     (SRC),Y
        CMP     ESTKH,X
        BNE     +
        LDA     SRCL            ; MATCH
        STA     ESTKL,X
        LDA     SRCH
        STA     ESTKH,X
        RTS
+       LDA     #$07            ; NEXT ENTRY SFTODO: THIS IS $05 IN NON-JIT, WOULD NEED TO CONDITIONALLY COMPILE OR SOMETHING IN A FINAL VSN
        CLC
        ADC     SRCL
        STA     SRCL
        BCC     -
        INC     SRCH
        BNE     -
++      STY     ESTKL,X
        STY     ESTKH,X
        RTS
end
//
// Reloc internal data
//
//def reloc(modfix, modofst, bytecode, rld)#3
//    word addr, fixup
//    while ^rld
//        if ^rld & $10 // EXTERN reference.
//            return rld, addr, fixup
//        fin
//        addr = rld=>1 + modfix
//        fixup = *addr + modofst
//        if uword_isge(fixup, bytecode) // Bytecode address.
//            return rld, addr, fixup
//        fin
//        *addr = fixup
//        rld = rld + 4
//    loop
//    return rld, addr, fixup
//end
asm reloc(modfix, modofst, bytecode, rld)#3
        LDA     ESTKL,X
        STA     SRCL
        LDA     ESTKH,X
        STA     SRCH
        LDY     #$00
-       LDA     (SRC),Y
        BEQ     RLDEX       ; END OF RLD
        PHA
        INY
        LDA     (SRC),Y
        INY
        CLC
        ADC     ESTKL+3,X   ; ADDR=ENTRY=>1+MODFIX
        STA     DSTL
        LDA     (SRC),Y
        ADC     ESTKH+3,X
        STA     DSTH
        PLA
        AND     #$10        ; EXTERN REF - EXIT
        BNE     RLDEX
        TAY                 ; FIXUP=*ADDR+MODOFST
        LDA     (DST),Y
        INY
        CLC
        ADC     ESTKL+2,X
        STA     TMPL
        LDA     (DST),Y
        ADC     ESTKH+2,X
        CMP     ESTKH+1,X   ; FIXUP >= BYTECODE?
        BCC     +
        STA     TMPH
        BNE     RLDEX       ; YEP, EXIT
        LDA     TMPL
        CMP     ESTKL+1,X
        BCS     RLDEX       ; YEP, EXIT
        LDA     TMPH
+       STA     (DST),Y     ; *ADDR=FIXUP
        DEY
        LDA     TMPL
        STA     (DST),Y
        LDA     SRCL        ; NEXT ENTRY
;       CLC
        ADC     #$04
        STA     SRCL
        BCC     -
        INC     SRCH
        BNE     -
RLDEX   INX
        LDA     TMPL
        STA     ESTKL,X
        LDA     TMPH
        STA     ESTKH,X
        LDA     DSTL
        STA     ESTKL+1,X
        LDA     DSTH
        STA     ESTKH+1,X
        LDA     SRCL
        STA     ESTKL+2,X
        LDA     SRCH
        STA     ESTKH+2,X
        RTS
end
#endif

//
// Large frame allocation API
// 
// This is effectively a varargs function; given a function foo:
// 	def foo(a, b, c)
// if you execute:
//	x = (@callalloca)(5, 25, @foo, 512)
// it behaves 'as if' you wrote:
//	byte tmp[512]
//	x = foo(5, 25, @tmp)
// and then 'tmp' is immediately freed on exit from foo().
// This is useful because normal local variables are restricted to a total
// of 256 bytes per function.
//
// Note that if the function being called has a #n on its definition with n!=1,
// the same #n must be appended to the call to callalloca(), otherwise things
// will go wrong - callalloca() actually leaves the expression stack alone after
// calling the specified function.
//
// Note also that to avoid the compiler's validation of function call arguments,
// callalloca must be called via a function pointer as in the example above.
// (callalloca is declared with no arguments and one return value, but it
// actually has as many arguments and return values as the function it calls.)
// The optimiser turns this into a standard function call so there is no space
// or time penalty to doing this.
export asm callalloca
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH

        ; We can't save IFP/PP directly in case mode() gets called by a child
        ; function; instead we save the delta we're applying to IFP/PP so we can
        ; reverse it when our child function returns.
        LDA	ESTKH,X
        PHA
        LDA	ESTKL,X
        PHA

	SEC
!IFNDEF PLAS128 {
	LDA	IFPL
	SBC	ESTKL,X
	STA	IFPL
	STA	ESTKL+1,X
	LDA	IFPH
	SBC	ESTKH,X
	STA	IFPH
	STA	ESTKH+1,X
	+CHECKVSHEAP IFP
} ELSE {
	LDA	PPL
	SBC	ESTKL,X
	STA	PPL
	STA	ESTKL+1,X
	LDA	PPH
	SBC	ESTKH,X
	STA	PPH
	STA	ESTKH+1,X
	+CHECKVSHEAP PP
	; We don't need to update IFP; if the called function uses the frame
	; stack, ENTER will set IFP=PP-frame_size.
}
	INX

	JSR	JMPTMPX

	CLC
!IFNDEF PLAS128 {
	PLA
        ADC	IFPL
	STA	IFPL
	PLA
        ADC	IFPH
	STA	IFPH
} ELSE {
	PLA
        ADC	PPL
	STA	PPL
	PLA
        ADC	PPH
	STA	PPH
}

	RTS
end

//
// ACORN OS ERROR GENERATION
//
export asm oserror(n, msg)#0
	LDA	ESTKL+1,X
	STA	$101
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	TAY
	LDA	#0
	STA	$100 ; BRK opcode
	STA	$102,Y
-	LDA	(TMP),Y
	STA	$101,Y
	DEY
	BNE	-
	JMP	$100
end

//
// NONLOCAL GOTO
//
// SFTODO: Need to think carefully about whether except()/throw() need to be updated to reflect the new style of ENTER/LEAVE/INTERP in the latest version

// except(jmp_buf *b) -> 0 on save, throw val otherwise
export asm except(b)#1
	STX	ESP

	LDY	#0
	LDA	ESTKL,X
	STA	TMPL
	STY	ESTKL,X
	LDA	ESTKH,X
	STA	TMPH
	STY	ESTKH,X

	TXA
	STA	(TMP),Y
	INY

	; Note that we know there's at least one element on ESTK as
	; we received our 'b' argument on it. We could avoid saving
	; that but it seems simplest just to include it.
----	LDA	ESTKL,X
	STA	(TMP),Y
	INY
	LDA	ESTKH,X
	STA	(TMP),Y
	INY
	INX
    	CPX	#ESTKSZ/2
	BNE	----

	;* We store IFP and PP as a delta from HIMEM to avoid problems
	;* where we do except(); mode(); throw().
+++	SEC
	LDA	#0
	SBC	IFPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	IFPH
	STA	(TMP),Y
	INY
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	PPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	PPH
	STA	(TMP),Y
	INY
#endif

	;* We don't need to save IP, IPY or (for PLAS128) the current bank at 
	;* $F4; CALL/ICAL save and restore these themselves. (Remember that
	;* when throw() reaches its RTS, control returns to just after the
	;* JSR inside the CALL/ICAL which called except.)

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	+
	INC	TMPH
+	LDY	#0

	TSX
	TXA
	STA	(TMP),Y
        ; Y=0 at this point; we assume the CPU stack is not completely full
        ; (X=$FF) at this point (if it is, we're in trouble, because an
        ; interrupt could occur and push more onto the stack) and therefore we
        ; know that Y can't wrap round during the following loop.
--	INX
	BEQ	++
	LDA	$0100,X
	INY
	STA	(TMP),Y
        BNE     --              ; always branches

++	LDX	ESP
	RTS
end

// throw(jmp_buf *b, word val)
// Control never returns to caller; we declare this to return no values so the
// caller doesn't waste space on a redundant DROP opcode after the CALL.
export asm throw(b, val)#0
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH
	LDA	ESTKL,X
	PHA
	LDA	ESTKH,X
	PHA

	LDY	#0
	LDA	(TMP),Y
	STA	ESP
	TAX
	INY
-	LDA	(TMP),Y
	STA	ESTKL,X
	INY
	LDA	(TMP),Y
	STA	ESTKH,X
	INY
	INX
	CPX 	#ESTKSZ/2
	BNE	-
        LDX	ESP

	PLA
	STA	ESTKH,X
	PLA
	STA	ESTKL,X
	;* if val is 0, force it to be 1
	ORA	ESTKH,X
	BNE	++++
	INC	ESTKL,X
++++

 	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	IFPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	IFPH
	INY
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	PPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	PPH
	INY
#endif

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	++
	INC	TMPH
++	LDY	#0

	LDA	(TMP),Y
	TAX
	TXS

        ;* As in except(), we can assume X is not $FF and so we know Y can't
        ;* wrap round during this loop.
--	INX
	BEQ	+++
        INY
	LDA	(TMP),Y
	STA	$0100,X
        JMP	--

+++	

	;* PLAS128: CS may have allocated some constant strings after except()
	;* was called, but when we restore the value of PP saved by except()
	;* we effectively just reset the pool back to the state at the except()
	;* point.

	LDX	ESP
	RTS
end

#ifdef PLAS128
//
// COPY FROM MAIN MEM TO AUX MEM.
//
// MEMXCPY(DST, SRC, SIZE)
//
// Assumes that DST to DST+SIZE-1 all lie in the same 16K bank; this will
// be true given how allocxheap() works.
asm memxcpy(dst,src,size)#0
	LDA	ESTKH,X
	ORA	ESTKL,X
	BEQ	MEMXCPYEX

	STY 	IPY

	;* This code must be kept consistent with IINTERP
	LDA	ESTKH+2,X
        ROL
        ROL
        ROL
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+2,X
	AND	#$BF
	ORA	#$80
	STA 	DSTH
	LDA	ESTKL+2,X
	STA	DSTL

	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	
	LDY	ESTKL,X
	BEQ	MEMXCPYLP
	INC 	ESTKH,X
	LDY	#$00
MEMXCPYLP 
	LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	MEMXCPYLP
	DEC	ESTKH,X
	BNE	MEMXCPYLP

	LDY	IPY
MEMXCPYEX
	INX
	INX
	INX
	RTS
end
#endif

//
// CONSOLE I/O
//
export asm putln()#0
        ; Since this is so simple, it's highly tempting to try to do away with
        ; it and have code call OSNEWL directly. This is possible for loaded
        ; modules - we can simply arrange for the "putln" entry in the symbol
        ; table to point to OSNEWL. However, it's trickier to make it work here
        ; in the core VM. We can omit this definition and do 'const putln =
        ; osnewl' but calling through a function pointer (as this effectively
        ; is) requires the call site to specify '#0' (we can't attach that type
        ; information to the function pointer itself) - I haven't actually tried
        ; that but it would probably work, but it would be a bit intrusive.
        ; Since this JMP OSNEWL therefore "has" to exist, I haven't bothered
        ; making the symbol table just refer directly to OSNEWL lest it cause
        ; confusion - the performance overhead is negligible.
	JMP	OSNEWL
end
export asm putc(c)#0
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
// Just a helper function for mode(); smaller than writing it in PLASMA.
asm putc22(n)#0
	LDA	#22
	JSR	OSWRCH
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
export asm getc()#1
	DEX
	JSR	OSRDCH
        BCS	ESCAPE
	STA	ESTKL,X
	LDA	#$00
	STA	ESTKH,X
	RTS
end
export asm gets(p)#1
	STX	ESP
	LDA	ESTKL,X
	JSR	OSWRCH
	LDA	#<INBUFF
	STA	ESTKL,X
	LDA	#>INBUFF
	STA	ESTKH,X
        LDA	#0
        LDX	#<OSWORD0BLK
        LDY	#>OSWORD0BLK
	JSR	OSWORD
	BCS	ESCAPE
	STY	INBUFF
	LDX	ESP
	RTS
ESCAPE
	LDA	#osbyte_acknowledge_escape
	JSR	OSBYTE
	BRK
	!BYTE	17
	!TEXT	"Escape"
	BRK
OSWORD0BLK
	!WORD	INBUFF+1
        !BYTE	INBUFFSZ-1
        !BYTE	32
        !BYTE	255
end
// def puts(str)
export asm puts(s)#0
	STX	ESP
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	BEQ	+
	TAX
-	INY
	LDA	(TMP),Y
	JSR	OSASCI
	DEX
	BNE	- 
+	LDX	ESP
	INX
	RTS
end
//
// Cheap and dirty print integer SFTODO: USE THIS INSTEAD OF TESTLIB VERSION WHERE IT'S SUITABLE
//
export def puti(i)#0
    if i < 0; putc('-'); i = -i; fin
    if i >= 10; puti(i / 10); fin
    putc(i % 10 + '0')
end
export def prbyte(b)#0
    putc(hexchar[(b >> 4) & $0F])
    putc(hexchar[b & $0F])
end
def prword(w)#0 // SFTODO: PROBABLY NEEDS TO BE EXPORTED NOW
    prbyte(w >> 8)
    prbyte(w)
end

// TODO: export this?
// TODO: get rid of this and inline it in except2()?
def jmpbufsz(jb)#1
	const esp_size = 1
	const esp_offset = 0
#ifdef PLAS128
	const pp_size = 2
#else
	const pp_size = 0
#endif
	const ifp_size = 2
	const stack_ptr_size = 1
	const estksz = 32
	const estksz_elems = estksz / 2
	word size
	word stack_ptr
	size = esp_size + 2 * (estksz_elems - jb->esp_offset) + ifp_size + pp_size
	stack_ptr = ^(jb + size)
	size = size + stack_ptr_size + (255 - stack_ptr)
	return size
end
// int except2(jmp_buf **b) { *b = new jmp_buf; return except(*b); }
// except() wrapper which dynamically allocates a jmp_buf of just the right size
// to avoid wasting memory.
export def except2(bptr)#1
    word b
    word result
    b = *heapptr
    *bptr = b
    result = except(b)
    if result == 0
        xheapalloc(jmpbufsz(b))
    fin
    return result
end
// Change the screen mode
//
// Care must be taken when calling mode(). The parameter stack starts at the
// bottom of screen memory (HIMEM) and grows downwards. If a mode change
// alters HIMEM, the parameter stack needs to be relocated in memory. mode()
// takes care of this, but any code which has taken the address of local
// variables on the parameter stack (or, on PLAS128, constant strings, which
// also live on the parameter stack) will have an invalid address after
// the relocation. (This isn't an issue if changing between modes which doesn't
// alter HIMEM.)
//
// TL;DR: Call mode() as early as possible and with as few nested function
// calls in effect as possible and you'll probably be safe.
//
// Returns true if the mode change was successful and false if not (typically
// caused by insufficient memory).
export def mode(n)#1
    word new_himemh, himem, new_himem

    // If the mode change doesn't alter HIMEM, it's trivial. We need to check
    // specifically for the second processor case here; see the code just
    // above INITFP.
    new_himemh = call(osbyte, osbyte_read_himem_for_mode, n, 0, 0).2
    if new_himemh == ^himemh or ^himemh > $80
        putc22(n)
	return true
    fin

    himem = ^himemh << 8
    new_himem = new_himemh << 8
    gm_himem_delta = new_himem - himem
#ifdef PLAS128
    gm_new_frame_start = *pp + gm_himem_delta
    // Because we use gm_new_frame_start below, it's important that PP doesn't
    // move between now and then - which means none of the following code can
    // use constant strings. (We could redo this calculation at that point, but
    // it's nicer not to have to.)
#else
    gm_new_frame_start = *ifp + gm_himem_delta
#endif
    // Insist on 512 bytes free afterwards, so that an application has a
    // chance to not crash after a mode change when memory is tight.
    if isult(gm_new_frame_start - 512, *heapptr)
	return false
    fin

    ^himemh = new_himemh

    // We're now going to copy the parameter frame stack and adjust IFP (and
    // PP for PLAS128) accordingly. We need a temporary parameter frame
    // stack so we can call memcpy(); once we've switched to that we can't
    // access any local variables, so we copy everything into globals first.
#ifdef PLAS128
    gm_new_ifp = *ifp + gm_himem_delta
    gm_copy_from = *pp
#else
    gm_copy_from = *ifp
#endif
    gm_copy_size = himem - gm_copy_from
    gm_new_mode = n
    *ifp = *heapptr + 256 // we know there's at least 512 bytes available

    if gm_himem_delta >= 0
	putc22(gm_new_mode)
    fin
    memcpy(gm_new_frame_start, gm_copy_from, gm_copy_size)
    if gm_himem_delta < 0
	putc22(gm_new_mode)
    fin
#ifdef PLAS128
    *pp = gm_new_frame_start
    *ifp = gm_new_ifp
#else
    *ifp = gm_new_frame_start
#endif
    return true
end

//
// FILE I/O
//
#ifndef STANDALONE
def high_order_address()#1
    return call(osbyte, osbyte_read_high_order_address, 0, 0, 0):1
end
#endif
def oserror_heap_full()#0
    oserror(16, "Heap full")
end
#ifndef STANDALONE
def oserror_bad_module()#0
    oserror(17, "Bad module")
end
def oserror_not_found()#0
    oserror(214, "Not found")
end
#endif
//
// Heap routines.
//
export def heapavail()#1
    byte fp
    return @fp - *heapptr
end
// heapalloc() generates an OS error if the allocation fails and is
// no larger than allocheap_fail_threshold; failures otherwise return
// 0. The idea here is that as well as allowing "always" and "never"
// generating an OS error, a program may take more care to check big
// allocations (e.g. loading a file containing user data) than it will
// do with small allocations (where it might not be able to do much
// except die even if it checks and notices that they failed).
export def heapalloc(size)#1
    word addr
    if isugt(size, heapavail())
	if isule(size, allocheap_fail_threshold)
	    oserror_heap_full()
	fin
	return 0
    fin
    addr = *heapptr
    *heapptr = *heapptr + size
    return addr
end
// Like heapalloc(), but *always* generates an error if the allocation
// fails, regardless of the size requested and the fail threshold.
export def xheapalloc(size)#1
    word addr
    addr = heapalloc(size)
    if addr == 0
	oserror_heap_full()
    fin
    return addr
end
// SFTODO: A2 IMPL OF THIS IS A BIT DIFFERENT, QUITE POSSIBLY MINE IS FINE BUT IF THERE'S OPTIMISATION POTENTIAL GO WITH IT - JUST DON'T WANT TO GET INTO THESE TINY DETAILS WHILE TRYING TO MERGE ALL SORTS OF BIGGER STUFF
export def heapallocalign(size, pow2, freeaddr)#1
    word align, addr
    if freeaddr
        *freeaddr = *heapptr
    fin
    align = (1 << pow2) - 1
    addr = *heapptr
    if addr & align
        addr = (addr | align) + 1
    fin
    if !heapalloc(size + (addr - *heapptr))
        return 0
    fin
    return addr
end
export def heapmark()#1
    return *heapptr
end
export def heaprelease(newheap)#1
    *heapptr = newheap
    return @newheap - *heapptr
end
#ifdef PLAS128
// TODO: I've rewritten this - review it when fresh and test the various corner
// cases (I've only run a few sample programs under it so far)
def allocxheap(size)#1
    word xheapcopy, adjust, bankend, bankfree

    if isugt(size, xheap_bank_size - xheap_bank_start)
	return 0
    fin

    xheapcopy = xheap
    adjust = (4 - ^rambankcount) * xheap_bank_size
    repeat
        bankend = (xheapcopy & $C000) + xheap_bank_size
        bankfree = bankend - xheapcopy
        if size <= bankfree
            if size == bankfree
                size = size + xheap_bank_start
            fin
            xheap = xheapcopy + size
            return xheapcopy
        fin
        xheapcopy = bankend | xheap_bank_start
    until bankend + adjust == 0
    return 0
end
#endif

//
// Acorn MOS API
//

def call_oscli_internal(str, str_cr)#0
    stocr(str, str_cr)
    call(oscli, 0, str_cr, str_cr >> 8, 0)
end

// call_oscli(str)
export def call_oscli(str)#0
    (@callalloca)(str, @call_oscli_internal, ^str + 1)#0
end

#ifndef STANDALONE
//
// Symbol table routines.
//
// The symbol table is a "chunked array"; the first chunk is at symtbl and
// each chunk consists of a number of entries, each of which consists of:
// - symbol name (as DCI string)
// - symbol address (2 bytes)
//
// If the symbol name's first byte is 0, that marks the end of the symbol
// table.
//
// If the symbol name's first byte is 1, that marks the end of the current
// chunk but not the symbol table; it is followed by two bytes which are
// the address of the next chunk.
//
// The first chunk is a different size than later chunks but this is only
// relevant to addsym(); it makes no difference to lookuptbl().
//
// TODO: lookupsym has only one caller, inline it??
def lookupsym(sym)#1
    return lookuptbl(sym, @symtbl)
end
def addsym(sym, addr)#0
    byte str[maxnamelen+1]
    word entrysz
    const addrsz = 2
    const nextchunkptrsz = 3 // end of chunk marker followed by two byte pointer
    
    // We must always have room for the symbol name, two bytes for the
    // address associated with that name and another three bytes for the
    // 'next chunk' pointer. (Initially we only need one byte for the 'end
    // of table' marker, but sooner or later another chunk will be added
    // so we need to allocate three bytes. Those extra two bytes are not
    // *touched* yet, which is important for the assumptions we make about
    // symbol table growth in modload().)
    entrysz = addrsz + nextchunkptrsz + dcitos(sym, @str)
    if (symtblchunk <> lowsymtblchunk) or (lastsym - lowsymtblchunk + entrysz > lowsymtblchunksz)
    	symtblchunk = xheapalloc(entrysz)
	if lastsym + nextchunkptrsz == symtblchunk
	    // This allocation is contiguous with the previous chunk; we
            // therefore don't need a chunk end marker and a symbol table
            // pointer. This is important when we're called in modload(), as
	    // otherwise the assumption about the growth of the symbol table
	    // per addsym() call wouldn't be true. Because this is the common
	    // case, we can get away with allocating only the exact number of
	    // bytes required every time without this wasting space by causing
            // us to have one symbol table chunk per symbol.
	    symtblchunk = lastsym
            heaprelease(symtblchunk + entrysz)
	else
            lastsym->0 = 1 // end of chunk but not end of table
	    lastsym=>1 = symtblchunk // next chunk
	    lastsym = symtblchunk
	fin
    fin
    // We don't have a 'copy DCI string' function, but since we copied the DCI
    // string into str[] above using dcitos(), we can get the same effect by
    // copying that using stodci() here.
    lastsym = lastsym + stodci(@str, lastsym)
    lastsym=>0 = addr
    lastsym    = lastsym + 2
    ^lastsym   = 0 // end of table
end
#endif
//
// String routines.
//
def strcpy(dst, src)#1 // SFTODO: EXPORT?
    memcpy(dst+1, src+1, ^src)
    ^dst = ^src
    return dst
end
def strcat(dst, src)#1 // SFTODO: EXPORT?
    memcpy(dst + ^dst + 1, src + 1, ^src)
    ^dst = ^dst + ^src
    return dst
end
#ifndef STANDALONE
// TODO: If this has only one caller we might be as well to inline it - but
// maybe that's over-optimisation.
def lookupextern(esd, index)#1
    word sym, addr
    byte str[maxnamelen+1]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if esd->0 & $10 and esd->1 == index
            addr = lookupsym(sym)
	    if !addr
                perr = $81
	        putc('?')
		puts(@str)
		putln
	    fin
            return addr
        fin
        esd = esd + 3
    loop
    return 0
end
//
// Indirect interpreter DEFinition entrypoint
//
// SFTODO: It's probably fine, but for my own satisfaction should later check to
// see that the last DEF in a module *is* still eligible for being JITted
// despite the "patch up the previous entry to use the JIT entry point"
// approach.
def adddef(isfirst, addr, deflast)#1
    word preventry, defentry, defsize

    defentry = *deflast
    *deflast = defentry + t_defentry
    if not isfirst
        preventry = defentry - t_defentry
        defsize   = addr - preventry=>bytecodeaddr
        if defsize <= jitsize
            preventry=>interpaddr   = jitiinterp // JSR JITIINTERP
            preventry->callcount    = jitcount // Set JIT countdown
            preventry->bytecodesize = defsize  // Set size
        fin
    fin
    defentry->interpjsr    = $20
    defentry=>interpaddr   = iinterp // JSR IINTERP
    defentry=>bytecodeaddr = addr
    defentry->t_defentry   = 0 // NULL out next entry
    return defentry
end
def modname_default(modcr)#0
    // Default implementation does nothing
end
// Load the module whose name is 'moddci' (a DCI string) from the file 'modcr'
// (a CR-terminated string); modcr points to at least maxpathlen bytes of space to
// allow modname() to generate a long filename in place if it wants to.
def modloadcr_internal(moddci, modcr)#1
    // SFTODO: TIDY THE VARIABLES UP HERE (FOR BOTH PLAS128 AND PLAS32) ONCE I HAVE THINGS OTHERWISE WORKING - PROBABLY A BIT OF A MESS FOLLOWING PORTING ACROSS OF LATEST A2 CHANGES
    word rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr
#if 0 //SFTODO
#ifdef PLAS128
    word defaddr
#endif
#endif
    word modaddr, modfix, modend
    word modofst, defbank, defaddr, codefix
    word deftbl, deflast
    word moddep, rld, esd, sym
    byte deffirst, skipjit
    byte str[maxnamelen+1]
    const header_size = 128
    byte header[header_size]
    byte handle
    byte block[osfile_block_size] // osgbpb_block_size is smaller
    byte file_length[4]

    perr = 0

    // We use OSGBPB to read the first header_size bytes of the module, but we
    // use OSFILE to load the entire module later; tests on Acorn DFS 2.24 on
    // BeebEm suggest OSFILE can load 6.25K in 1.74s compared with 4.47s for
    // OSGBPB. So it's well worth the "waste" of reading the header twice.

    //
    // Perform any transformations on the filename we are going to load from.
    //
    modname(modcr)#0

    //
    // Read the RELocatable module header (first header_size bytes); we also
    // get the file length while we have the file open.
    //
    handle = call(osfind, osfind_input, modcr, modcr >> 8, 0).0
    if handle == 0
    	// SFTODO: A2 IMPL NOW ATTEMPTS TO OPEN USING A 'SYSTEM PATH' - IS THIS
	// SOMETHING I SHOULD CONSIDER PORTING?
        oserror_not_found()
    fin
    modload_handle = handle
    block.0 = handle
    block:1 = @header
    // SFTODO: Can we just use 0 instead of high_order_address()? I may be
    // getting confused, but if we don't have a second processor 0 will
    // obviously load into the host, and if we do have a second processor, 0
    // will load into it.
    block:3 = high_order_address()
    block:5 = header_size
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    rdlen = header_size - block:5
    call(osargs, osargs_read_ext, scratch, handle, 0)
    file_length:0 = scratch:0; file_length:2 = scratch:2
    modload_handle = 0; call(osfind, osfind_close, 0, handle, 0)

    if rdlen <= 16 or header:2 <> $6502 // magic number
        oserror_bad_module()
    fin

    modsize = header:0
    //
    // This is an EXTended RELocatable (data+bytecode) module.
    //
    // systemflags = header:4 | systemflags
    skipjit = 0 // SFTODO: Need to respect nojitc here
    defofst  = header:6
    defcnt   = header:8
    init     = header:10
    moddep   = @header.12
    //
    // Load module dependencies.
    //
    while ^moddep
        if !lookuptbl(moddep, @symtbl)
            if modload(moddep) < 0
                return -perr
            fin
        fin
        moddep = moddep + dcitos(moddep, @str)
        // Just to be paranoid, let's check for the case where a module has
        // loads of dependencies and they overflow the header. This won't
        // catch everything, as it doesn't check the call to dcitocr()
        // inside the above modload() hasn't overflowed, but it should be
        // fairly reliable in practice.
        if (moddep - @header) >= rdlen
            oserror_bad_module()
        fin
    loop
    //
    // Init def table.
    //
    deftbl   = xheapalloc(defcnt * t_defentry + 1)
    deflast  = deftbl
    ^deflast = 0 // SFTODO: APPLE II JIT CMD.PLA DOESN'T DO THIS, IT MAY WELL BE REDUNDANT BUT I THINK IT'S HARMLESS SO LET'S LEAVE IT IN FOR THE MOMENT AND DELETE IT LATER
    //
    // Add module to symbol table. This may grow the symbol table, so we
    // do it before we allocate space on the heap for the module. The
    // address of the module is not used (although it's important it's
    // not zero, otherwise lookupmod() will indicate the module isn't
    // loaded when it is) and due to the symbol table changes we don't
    // have modaddr available here (unlike the Apple code), so we just
    // use a non-zero constant. SFTODO: THIS IS NO LONGER WORKABLE, THE LATEST
    // CODE USES THE MODULE ADDRESS TO ACCESS A TABLE OF EXPORTED FUNCTIONS
    //
    addsym(moddci, $0001)
    // SFTODO: SEMI TEMP HACK - WE KNOW modaddr WILL BE *heapptr, SO WE CAN NOW
    // PATCH UP THE JUST-INSERTED SYMBOL ADDRESS. WE CAN'T JUST PASS *HEAPPTR
    // TO ADDSYM AS THAT WOULD BE THE VALUE BEFORE ADDSYM() DOES ANY
    // ALLOCATIONS. VARIOUS ALTERNATIVES HERE - E.G. WE COULD DO THIS PATCH VIA
    // LASTSYM LATER ONCE WE HAVE MODADDR, IT'S EQUIVALENT, JUST A TRADE OFF IN
    // CLARITY. WE COULD HAVE ADDSYM RETURN A POINTER TO THE NEW ADDRESS IN THE
    // SYMTAB. ALL SORTS OF THINGS...
    *(lastsym - 2) = *heapptr
    //
    // Check there's room for the entire file onto the heap now any
    // dependencies have been loaded.
    //
    addr = 0
    if file_length:2 <> 0 // if file is >=64K
        oserror_heap_full()
    fin
    rdlen = file_length:0
    addr = xheapalloc(rdlen)
    //
    // Load the file
    //
    block:0 = modcr
    block:2 = addr
    block:4 = high_order_address()
    block:6 = 0 // ignore file's load address, use our own
    // We check specifically for file found; a directory is no good to us. In
    // reality we don't expect any problems as we already opened the file using
    // OSFILE to read the header.
    if call(osfile, osfile_load_file, @block, @block >> 8, 0).0 <> osfile_file_found
        oserror_not_found()
    fin
    // To test module loading I/O performance alone, do this here: return 0
    //
    // Release the claim we just made; we really did it only to see if it
    // would fail. The code immediately following will shift the loaded
    // module down to avoid wasting space on the header and claim the
    // required amount of space for the module's data and code.
    //
    heaprelease(addr)
    //
    // Alloc heap space for relocated module (data + bytecode).
    //
    moddep  = moddep  + 1 - @header + *heapptr
    modfix  = moddep  - (*heapptr + 2) // Adjust to skip header
    modsize = modsize - modfix
    rdlen   = rdlen   - modfix - 2
    modaddr = xheapalloc(modsize) // can't fail anyway
    memcpy(modaddr, moddep, rdlen)
    //
    // Apply all fixups and symbol import/export.
    //
    modfix   = modaddr - modfix
    modofst  = modfix  - RELADDR
    modend   = modaddr + modsize
    bytecode = defofst + modofst
    rld      = modend  // Re-Locatable Directory
    esd      = rld     // Extern+Entry Symbol Directory
    while ^esd         // Scan to start of ESD
        esd = esd + 4
    loop
    esd = esd + 1
#ifdef PLAS128
    //
    // Locate bytecode defs in appropriate bank.
    //
    defaddr = allocxheap(rld - bytecode)
    // TODO: If there's only one caller of allocxheap(), might as well fold
    // the following test into allocxheap() itself.
    if defaddr == 0
        oserror_heap_full()
    fin
    modend  = bytecode
#else
    // SFTODO: MAY BE POSSIBLE TO HAND-OPTIMISE AWAY SOME VARIABLES IN THIS CASE, BUT LET'S JUST DO THIS FOR NOW TO BE LIKE A2 CODE WHILE I GET THE LATEST PORT GOING
    defaddr = bytecode
#endif
    codefix = defaddr - bytecode
    defofst = defaddr - defofst
    //
    // Free up the end-of-module data in main memory. We have to do this now
    // as otherwise any symbol table allocations which claim memory from the
    // heap would trap the end-of-module data. However, we still want to use
    // that end-of-module data (the RLD/ESD) below, even after we've freed
    // it. We get away with this because only addsym() is going to allocate
    // from the heap. Any one addsym() call can only touch len(symbol_name) +
    // 2 (symbol address) + 1 (end-of-symbol-table marker) new bytes (it may
    // allocate an extra 2 bytes, to allow for an end-of-symbol-table-chunk
    // marker, but it won't touch them), and each ESD entry is len(symbol_name)
    // + 3 bytes, so even if there are no RLD entries we will not overwrite an
    // ESD entry before it's been consumed. TODO: Double check this reasoning!
    //
    heaprelease(modend)    
    //
    // Run through the DeFinition Dictionary.
    //
    deffirst = 1
    while ^rld == $02
	//
	// This is a bytecode def entry - add it to the def directory.
	//
	adddef(deffirst, rld=>1 + defofst, @deflast)
        deffirst = skipjit // Calculate JIT potential or not
	rld = rld + 4
    loop
    //
    // Run through the Re-Location Dictionary.
    //
    while ^rld
	rld, addr, fixup = reloc(modfix, modofst, bytecode, rld)
	if ^rld
	    *addr = ^rld & $10 ?? *addr + lookupextern(esd, rld->3) :: lookupdef(fixup + codefix, deftbl)
	    rld   = rld + 4
	fin
    loop
#ifdef PLAS128
    //
    // Move bytecode to AUX bank.
    //
    memxcpy(defaddr, bytecode, modsize - (bytecode - modaddr))
#endif
    //
    // Run through the External/Entry Symbol Directory.
    //
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if ^esd & $08
            //
            // EXPORT symbol - add it to the global symbol table.
            //
            addr = esd=>1 + modofst
            if isuge(addr, bytecode)
                //
                // Use the def directory address for bytecode.
                //
                addr = lookupdef(addr + codefix, deftbl)
            fin
            addsym(sym, addr)
            // TODO: The following test could be removed eventually.
            // Assert that the last byte written in the symbol table
            // (lastsym) hasn't trampled over the next ESD entry
            // (at esd + 3).
            if isuge(lastsym, esd + 3)
                oserror(0, "Symbol table clash") // TODO: non-0 error number if (probably won't) lives
            fin
        fin
        esd = esd + 3
    loop
    if perr
        return -perr
    fin
    //
    // Call init routine if it exists.
    //
    fixup = 0
    if init
        init  = init + defofst
	fixup = adddef(deffirst, init, @deflast)()
	if fixup < modinitkeep
	    //
	    // Free init routine unless initkeep. Because we grow our symbol
	    // table dynamically, we aren't as flexible as the Apple code here.
	    // On PLAS128 we're fine, because the symbol table lives in
	    // main RAM and the bytecode lives in the 'AUX' RAM. On PLAS32
	    // we may have allocated space for a symbol table chunk on top
	    // of the module's RLD/ESD, and that comes *after* the module's
	    // init. However, even on PLAS32 we can free the init code if we
	    // haven't yet exhausted the low symbol table chunk (and therefore
	    // haven't dynamically allocated a new symbol table chunk).
	    //
#ifdef PLAS128
            xheap = init
#else
            if symtblchunk == lowsymtblchunk
                heaprelease(init)
            fin
#endif
	    if fixup < 0
		perr = -fixup
	    fin
	else
	    fixup = fixup & ~modinitkeep
	fin
    fin
#if 0 // TODO: Temporary code for forcing multiple 16K banks to be used for PLAS128 testing
    #ifdef PLAS128
        prword(allocxheap(7000)); putln()
    #endif
#endif
    return fixup
end
def modloadpstr_internal(modpstr, modcr)#1
    byte moddci[maxnamelen]
    if ^modpstr == 0 or ^modpstr > maxnamelen
        oserror(204, "Bad name")
    fin
    stodci(modpstr, @moddci)
    stocr(modpstr, modcr)
    return modloadcr_internal(@moddci, modcr)
end
// Load the module named by the PLASMA string modpstr; this is taken from a
// command line and may be overlong or invalid in some other way.
// For the moment at least, I am going to work on the model that what you type
// after the + sign at the prompt is a module name - never a path of any
// description. modname() allows custom "module name to filename" conversion
// (including potentially locating the module in a directory other than the
// current one and therefore returning a filename with path components), but the
// user input is just a module name. We can therefore validate modpstr and
// convert it to a DCI module name quite naively. It's tempting to replace
// modname() with a function which returns an open file handle, but that isn't
// compatible with our desire to be able to use both OSGBPB and OSFILE to load
// the module.
def modloadpstr(modpstr)#1
    return (@callalloca)(modpstr, @modloadpstr_internal, maxpathlen)#1
end
def modload_internal(moddci, modcr)#1
    dcitocr(moddci, modcr)
    return modloadcr_internal(moddci, modcr)
end
// Load the module named by the DCI string moddci; this is taken from a module
// reference in another module and therefore should be valid (e.g. not
// arbitrarily long).
export def modload(moddci)#1 // SFTODO: IS THIS NO LONGER EXPORTED ON APPLE?
    return (@callalloca)(moddci, @modload_internal, maxpathlen)#1
end
#endif
#ifndef STANDALONE
//
// Command mode
//
def stripspaces(strptr)#0
    while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr--
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr--
    loop
end
def striptrail(strptr)#1
    byte i

    for i = 1 to ^strptr
        if ^(strptr + i) <= ' '
	    ^strptr = i - 1
	    break
	fin
    next
    return strptr
end
def parsecmd(strptr)#1
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr--
    fin
    stripspaces(strptr)
    return cmd
end
#endif
// User code could choose to install an alternate error handler, but
// it's probably not a good idea; most of the time user code should
// restrict itself to manipulating *errjb.
def error_handler()#0
  // The error number is available to the target at ^errnum; throw() naturally
  // passes along a value so it's tempting to pass the error number using it,
  // but it can't send a value of 0 (which is a valid error number) so we don't
  // do that as it just adds to the temptation to write not-quite-correct client
  // code. (Passing 0 saves a few bytes in the VM; this will be turned into 1
  // by throw() internally, not that anything is likely to examine the value.)
  throw(*errjb, 0)
end
#ifndef STANDALONE
def modexec(modfile)#1
    word saveheap
#ifdef PLAS128
    word savexheap
#endif
    word savesym, savesymtblchunk
    // word saveflags SFTODO MAY NEED TO REINSTATE THIS
    word savejit
    word error, action, olderrjb, jb

    saveheap  = *heapptr
#ifdef PLAS128
    savexheap = xheap
#endif
    savesym   = lastsym
    savesymtblchunk = symtblchunk
    // saveflags = systemflags
    savejit = *jitcodeptr
    modload_handle = 0
    olderrjb = *errjb
    // We allocate a jmp_buf on the heap using except2(); it will get trapped
    // and leaked if the module being executed remains resident, but that can't
    // really be helped (and it will be fairly small). We can't allocate a
    // local jmp_buf because the address of it would change if the executed
    // module changes mode and thereby alters HIMEM; mode() will relocate
    // the frame stack but it won't patch up the address at *errjb.
    error = except2(@jb)
    if error == 0
        *errjb = jb
        action = modloadpstr(modfile)
    fin
    *errjb = olderrjb
    if error <> 0 or action < modkeep
        if modload_handle <> 0
            call(osfind, osfind_close, 0, modload_handle, 0)
        fin

        lastsym     = savesym
        symtblchunk = savesymtblchunk
        ^lastsym    = 0
        lastsym=>1  = 0
#ifdef PLAS128
        xheap       = savexheap
#endif
        *heapptr    = saveheap
    fin
    // systemflags = saveflags
    *jitcodeptr = savejit
    if error <> 0
        error_handler()
    fin
    return -perr
end
#endif
#ifndef STANDALONE
// The parsing in here is deliberately naive to avoid bloating the virtual
// machine too much. It also works in our favour because parsecmd() only pays
// attention to the first character, so this means that "M7" and "MODE 7" both
// work (as, in fact, will things like " M O D E    1 3  5").
def modechange(cmdptr)#0
    word n, i
    byte c
    n = 0
    i = 1
    while i <= ^cmdptr
	c = ^(cmdptr + i)
	if c >= '0' and c <= '9'
	    n = (n * 10) + (c - '0')
	fin
	i++
    loop
    if not mode(n)
        // It doesn't really matter (the error is only shown to the user at the
        // prompt, not seen by any code which might check it) but we use the
        // same error number as BASIC here. (Code changes mode using mode()
        // which returns a boolean success/failure indicator instead of raising
        // an error.)
	oserror(25, "Bad mode")
    fin
end
#endif
#ifdef TIME
def time(t)#0
    call(osword, osword_read_time, t, t >> 8, 0)
end
#endif 
//
// Command line processor
// SFTODO: THIS PROB WANTS TO BE OMITTED IFDEF STANDALONE
//
def docmds#0
    *jitcomp = 0 // SFTODO Not sure this is ideal but will work for now
    modloadpstr("JIT") // Cannot do this in init code - it will overwrite it!
    // SFTODO: See comment elsewhere about safety or otherwise of using *heapptr
    // to init cmdptr just one - for now I am just going to hack it like this
    // after loading the JIT and I think that will get things more or less
    // working OK.
    cmdptr = *heapptr
    ^cmdptr = 0
    // SFTODO: Apple II cmdjit.pla fiddles around with xheap here - I may need something equivalent but for the moment I'm concentrating on getting JIT working just on non-paged PLASMA on Tube for simplicity so I hope I can get away without that
    while 1
        if ^cmdptr
            //putc('X'); puts(cmdptr); putc('X'); putln() // SFTODO!
            when toupper(parsecmd(cmdptr))
                is 'M'
                    modechange(cmdptr)
                    break
                is '+'
    #ifdef TIME
                    time(@start_time)
    #endif
                    // SFTODO: THE A2 VERSION NOW USES SAVEX/RESTOREX AROUND THIS, WHICH MAY BE A GOOD THING FOR US TO DO TOO
                    ^(cmdptr + ^cmdptr + 1) = 0 // SFTODO SEMI TEMP HACK
                    modexec(striptrail(cmdptr))
                    // SFTODO: THE A2 VERSION ALSO CLOSES ALL FILES HERE; I SUSPECT THAT'S NOT REALLY A VERY "ACORN" THING TO DO (EG IT BREAKS USE OF *SPOOL) BUT THINK ABOUT IT AND MAYBE LEAVE PERMANENT COMMENT IN IF I DON'T IMPLEMENT THIS
    #ifdef TIME
                    time(@end_time)
                    // We don't want to use the dword library here so we just accept we can
                    // only return small time deltas correctly using 16-bit arithmetic and
                    // signed output.
                    puts("\nTook "); puti(end_time:0 - start_time:0); puts(" cs\n")
    #endif
                    break
                is '*'
                    call_oscli(cmdptr)
                    break
                otherwise
                    puts(@huhstr)
            wend
            if perr
                puts(@errorstr)
                prbyte(perr)
                perr = 0
            else
                puts(@okstr)
            fin
            putln()
        fin
        puts(@freestr)
        prword(heapavail)
    #ifdef PLAS128
        puts(@xfreestr)
        prword(xheapsize - 1 - xheap) // a bit approximate
    #endif
        putln
        puts(@prompt)
        cmdptr = gets(':')
        syscmdln = cmdptr // SFTODO: bit of a hack, be better to set this once but should work for now
    loop
end
//
// Get heap start.
//
*heapptr = *freemem
#ifdef PLAS128
    xheapsize = ^rambankcount * xheap_bank_size
#endif
#ifndef STANDALONE
//
// Init globals; see note at top about why we have to do this.
//
symtblchunk = lowsymtblchunk
lastsym = lowsymtblchunk
modname = @modname_default
//
// Init symbol table.
//
^lastsym = 0 // end of symbol table
#endif
//
// Set up error handler
//
if except2(errjb) == 0
  *errfp = @error_handler
else
#ifndef STANDALONE
  putln
  puts(@errorstr)
  prbyte(^errnum)
  puts(@colonstr)
  puts(errstr)
  putln
#endif
fin
#ifndef STANDALONE
//
// Initialise cmdptr
// SFTODO: I am not 100% sure this was safe even before my JIT efforts; wouldn't
// this risk corrupting resident modules? They are loaded onto the heap and
// cmdptr would not be updated to point to the new top of heap afterwards. Need
// to think about this later but not worrying about it right now.
//
cmdptr = *heapptr
^cmdptr = 0
perr = 0
//
// Print some startup info.
//
if not ^cmdptr
    puts("PLASMA 2.0 Dev\n") //puts(@verstr); prbyte(version.1); putc('.'); prbyte(version.0); putln
    // TODO: Temporarily moved this to prompt instead of only displaying it
    // on startup; this makes it more obvious if heap gets leaked.
    //puts(@freestr)
    //prword(heapavail)
#ifdef PLAS128
    //puts(@xfreestr)
    //prword(xheapsize - 1 - xheap) // a bit approximate
#endif
    //putln
fin
docmds // SFTODO: I'm sure there's a very good reason (though it just might be Apple-specific) why this code can't remain here at the end of the init code (I think it's related to the loadmod of the jit, but I don't understand why yet) but for the moment I am just doing it like this because the Apple cmdjit.pla does it without really understanding
#endif
done
