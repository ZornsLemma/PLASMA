// TODO: A lot of this is probably irrelevant and can be removed

const MODADDR      = $1000
const inbuff       = $0700
const errnum       = $0700
const errstr	   = $0701
const freemem      = $0006
const ifp          = $0071
const pp           = $0073
const himemh       = $0078
const cpu_stack	   = $0100
#ifdef PLAS128
    const rambankcount = $0404
#endif
const errfp	   = $0405	// 2 bytes
const errjb	   = $0407	// 2 bytes
const FALSE = 0
const TRUE = NOT FALSE
//
// System flags: memory allocator screen holes.
//
const restxt1     = $0001
const restxt2     = $0002
const resxtxt1    = $0004
const resxtxt2    = $0008
const reshgr1     = $0010
const reshgr2     = $0020
const resxhgr1    = $0040
const resxhgr2    = $0080
//
// Module don't free memory
//
const modkeep     = $1000
const modinitkeep = $2000
//
// CFFA1 addresses.
//
const CFFADest     = $00
const CFFAFileName = $02
const CFFAOldName  = $04
const CFFAFileType = $06
const CFFAAuxType  = $07
const CFFAFileSize = $09
const CFFAEntryPtr = $0B
//
// Pedefined functions.
//
predef crout, cout, prstr, cin, rdstr
predef call
predef markheap, allocheap, allocalignheap, releaseheap, availheap
predef memset, memcpy
predef uword_isgt, uword_isge, uword_islt, uword_isle
predef loadmod, execmod, lookupstrmod
predef setjmp, longjmp
predef prbyte
predef oserror, osfile, oscli
predef stocr
predef mode
//
// System variables.
//
word version     = $0092 // 00.92
word systemflags = 0
word heap
#ifdef PLAS128
    word xheapsize
    // We leave $8000-$8008 inclusive free in each 16K sideways RAM bank
    // to avoid the risk of the data accidentally looking like a valid
    // sideways ROM header.
    const xheap_bank_start = $09
    word xheap = xheap_bank_start
#endif
word symtbl, lastsym
byte perr, refauto
//
// String pool.
//
byte autorun[]    = "AUTORUN"
byte verstr[]     = "\nPLASMA "
byte freestr[]    = "MEM FREE:$"
#ifdef PLAS128
    byte xfreestr[]	  = ", AUX FREE:$"
#endif
byte errorstr[]   = "ERR:$"
byte prompt[]     = "PLASMA"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
byte colonstr[]   = ": "
//
// Exported Machine ID.
//
byte machid       = $BB // Arbitrary value
//
// Command line pointer
//
word cmdptr       = @hexchar // make it point to a zero
//
// Global variables for use by mode()
//
byte gm_new_himem_higher
word gm_new_frame_start
#ifdef PLAS128
    word gm_new_ifp
#endif
word gm_copy_from
word gm_copy_size
byte gm_new_mode
//
// Standard Library exported functions.
//
byte syslibstr[]  = "CMDSYS"
byte machidstr[]  = "MACHID"
byte putcstr[]    = "PUTC"
byte putlnstr[]   = "PUTLN"
byte putsstr[]    = "PUTS"
byte getcstr[]    = "GETC"
byte getsstr[]    = "GETS"
byte callstr[]    = "CALL"
byte hpmarkstr[]  = "HEAPMARK"
byte hpalignstr[] = "HEAPALLOCALIGN"
byte hpallocstr[] = "HEAPALLOC"
byte hprelstr[]   = "HEAPRELEASE"
byte memsetstr[]  = "MEMSET"
byte memcpystr[]  = "MEMCPY"
byte uisgtstr[]   = "ISUGT"
byte uisgestr[]   = "ISUGE"
byte uisltstr[]   = "ISULT"
byte uislestr[]   = "ISULE"
byte loadstr[]    = "MODLOAD"
byte execstr[]    = "MODEXEC"
byte modadrstr[]  = "MODADDR"
byte argstr[]     = "ARGS"
byte setjmpstr[]  = "SETJMP"
byte longjmpstr[] = "LONGJMP"
byte prbytestr[]  = "PRBYTE"
byte oserrorstr[] = "OSERROR"
byte osfilestr[]  = "OSFILE"
byte osclistr[]   = "OSCLI"
byte stocrstr[]   = "STOCR"
byte modestr[]    = "MODE"
word exports[]	  = @callstr,   @call
word 		  = @putcstr,   @cout
word              = @putlnstr,  @crout
word		  = @putsstr,   @prstr
word		  = @getcstr,   @cin
word		  = @getsstr,   @rdstr
word		  = @hpmarkstr, @markheap
word		  = @hpallocstr,@allocheap
word		  = @hpalignstr,@allocalignheap
word		  = @hprelstr,  @releaseheap
word		  = @memsetstr, @memset
word		  = @memcpystr, @memcpy
word              = @uisgtstr,  @uword_isgt
word              = @uisgestr,  @uword_isge
word              = @uisltstr,  @uword_islt
word              = @uislestr,  @uword_isle
word              = @loadstr,   @loadmod
word              = @execstr,   @execmod
word              = @modadrstr, @lookupstrmod
word              = @machidstr, @machid
word              = @argstr,    @cmdptr
word		  = @setjmpstr, @setjmp
word		  = @longjmpstr,@longjmp
word		  = @prbytestr, @prbyte
word		  = @oserrorstr,@oserror
word		  = @osfilestr, @osfile
word              = @osclistr,  @oscli
word		  = @stocrstr,  @stocr
word		  = @modestr,   @mode
word              = 0
word syslibsym    = @exports     
//
// CALL 6502 ROUTINE
// CALL(AREG, XREG, YREG, STATUS, ADDR)
//
asm call
REGVALS	=	SRC
        PHP
        LDA     ESTKL,X
        STA     TMPL
        LDA     ESTKH,X
        STA     TMPH
        INX
        LDA     ESTKL,X
        PHA
        INX
        LDY     ESTKL,X
        INX
        LDA     ESTKL+1,X
        PHA
        LDA     ESTKL,X
        INX
        STX     ESP
        TAX
        PLA
        PLP
        JSR     JMPTMP
        PHP
        STA     REGVALS+0
        STX     REGVALS+1
        STY     REGVALS+2
        PLA
        STA     REGVALS+3
        LDX     ESP
        LDA     #<REGVALS
        LDY     #>REGVALS
        STA     ESTKL,X
        STY     ESTKH,X
        PLP
        RTS
JMPTMP	JMP	(TMP)
end
//
// QUIT TO PREVIOUS LANGUAGE
// TODO: Obviously not suitable if this gets turned into a language ROM itself...
//
asm quit
	LDA	#$FC
	LDX	#0
	LDY	#$FF
	JSR	$FFF4
	LDA	#$8E
	JSR	$FFF4
end
//
// SET MEMORY TO VALUE
// MEMSET(ADDR, VALUE, SIZE)
//   With optimizations from Peter Ferrie
//
asm memset
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	LDY     ESTKL,X
	BEQ     +
	INC     ESTKH,X
	LDY     #$00
+	LDA     ESTKH,X
	BEQ     SETMEX
SETMLPL	CLC
	LDA     ESTKL+1,X
SETMLPH	STA     (DST),Y
	DEC     ESTKL,X
	BEQ     ++
-	INY
	BEQ     +
--	BCS     SETMLPL
	SEC
	LDA     ESTKH+1,X
	BCS     SETMLPH
+	INC     DSTH
	BNE     --
++	DEC     ESTKH,X
	BNE     -
SETMEX	INX
	INX
	RTS
end
//
// COPY MEMORY
// MEMCPY(DSTADDR, SRCADDR, SIZE)
//
asm memcpy
	INX
	INX
MEMCPYINT
	LDA	ESTKL-2,X
	ORA	ESTKH-2,X
	BEQ	CPYMEX
	LDA	ESTKL-1,X
	CMP	ESTKL,X
	LDA	ESTKH-1,X
	SBC	ESTKH,X
 	BCC	REVCPY
;
; FORWARD COPY
;
	LDA	ESTKL,X
	STA 	DSTL
	LDA	ESTKH,X
	STA 	DSTH
	LDA	ESTKL-1,X
	STA 	SRCL
	LDA	ESTKH-1,X
	STA 	SRCH
	LDY	ESTKL-2,X
	BEQ	FORCPYLP
	INC 	ESTKH-2,X
	LDY	#$00
FORCPYLP LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL-2,X
	BNE	FORCPYLP
	DEC	ESTKH-2,X
	BNE	FORCPYLP
	RTS
;
; REVERSE COPY
;
REVCPY	;CLC
	LDA 	ESTKL-2,X
	ADC	ESTKL,X
	STA	DSTL
	LDA	ESTKH-2,X
	ADC	ESTKH,X
	STA	DSTH
	CLC
	LDA 	ESTKL-2,X
	ADC	ESTKL-1,X
	STA	SRCL
	LDA	ESTKH-2,X
	ADC	ESTKH-1,X
	STA	SRCH
	DEC	DSTH
	DEC	SRCH
	LDY	#$FF
	LDA 	ESTKL-2,X
	BEQ	REVCPYLP
	INC 	ESTKH-2,X
REVCPYLP LDA	(SRC),Y
	STA	(DST),Y
	DEY
	CPY	#$FF
	BNE	+
	DEC	DSTH
	DEC	SRCH
+	DEC 	ESTKL-2,X
	BNE	REVCPYLP
	DEC	ESTKH-2,X
	BNE	REVCPYLP
CPYMEX	RTS
end
//
// Unsigned word comparisons.
//
asm uword_isge
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
asm uword_isle
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
asm uword_isgt
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
asm uword_islt
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
//
// Addresses of internal routines.
//
asm interp
	DEX
	LDA	#<IINTERP
	STA	ESTKL,X
	LDA	#>IINTERP
	STA	ESTKH,X
	RTS
end
// 
// A DCI string is one that has the high bit set for every character except the last.
// More efficient than C or Pascal strings.
//
//def dcitos(dci, str)
//    byte len, c
//    len = 0
//    repeat
//        c = (dci).[len]
//        len = len + 1
//        (str).[len] = c & $7F
//    until !(c & $80)
//    ^str = len
//    return len
//end
asm dcitos
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(SRC),Y
	CMP	#$80
	AND	#$7F
	INY
	STA	(DST),Y
	BCS	-
	TYA
	LDY	#$00
	STA	(DST),Y
	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
//def stodci(str, dci)
//    byte len, c
//    len = ^str
//    if len == 0
//        return
//    fin
//    c = toupper((str).[len]) & $7F
//    len = len - 1
//    (dci).[len] = c
//    while len
//    	c = toupper((str).[len]) | $80
//    	len = len - 1
//    	(dci).[len] = c
//    loop
//    return ^str
//end
asm stodci
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	INX
	LDY	#$00
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
asm toupper
	LDA     ESTKL,X
TOUPR	AND     #$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SBC     #$1F
+	STA     ESTKL,X
	RTS
end
//
// Module symbols are entered into the symbol table
// pre-pended with a '#' to differentiate them
// from normal symbols.
//
//def modtosym(mod, dci)
//    byte len, c
//    (dci).0 = '#'|$80
//    len = 0
//    repeat
//        c = (mod).[len]
//        len = len + 1
//        (dci).[len] = c
//    until !(c & $80)
//    return dci
//end
asm modtosym
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDA	ESTKL,X
	STA	ESTKL+1,X
	STA	DSTL
	LDA	ESTKH,X
	STA	ESTKH+1,X
	STA	DSTH
	INX
	LDY	#$00
	LDA	#'#'+$80
-	STA	(DST),Y
	ASL
	LDA	(SRC),Y
	INY
	BCS	-
	RTS
end
//
// Lookup routines.
//
//def lookuptbl(dci, tbl)
//    word match
//    while ^tbl
//        match = dci
//        while ^tbl == ^match
//            if !(^tbl & $80)
//                return (tbl):1
//            fin
//            tbl   = tbl   + 1
//            match = match + 1
//        loop
//        while (^tbl & $80)
//            tbl = tbl + 1
//        loop
//        tbl = tbl + 3
//    loop
//    return 0
asm lookuptbl
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
-	LDA	(DST),Y
	BEQ	+
	CMP	(SRC),Y
	BNE	++
	INY
	ASL
	BCS	-
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
+	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
++	LDY	#$00
--	LDA	(DST),Y
	INC	DSTL
	BEQ	+
---	ASL
	BCS	--
	LDA	#$02
	ADC	DSTL
	STA	DSTL
	BCC	-
	INC	DSTH
	BCS	-
+	INC	DSTH
	BNE	---
end

//
// Acorn MOS API
// (only the bits needed by this file; the rest lives in acornos.pla and is
// included by programs which need it)
//
asm osfile
	STX	ESP
	LDA	ESTKL+1,X
	PHA
	LDY	ESTKH,X
	LDA	ESTKL,X
	TAX
	PLA
	JSR	$FFDD
	LDX 	ESP
	INX
	STA	ESTKL,X
	LDA	#0
	STA	ESTKH,X
	RTS
end

// oscli_cr(command_as_cr_string)
asm oscli_cr
	STX	ESP
	LDY	ESTKH,X
	LDA	ESTKL,X
	TAX
	JSR	$FFF7
	LDX	ESP
	RTS
end

asm oserror(n, msg)
	LDA	ESTKL+1,X
	STA	$101
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	TAY
	LDA	#0
	STA	$100 ; BRK opcode
	STA	$102,Y
-	LDA	(TMP),Y
	STA	$101,Y
	DEY
	BNE	-
	JMP	$100
end

//
// NONLOCAL GOTO
//

// TODO: export this?
asm jmpbufsz
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#5
	LDA	(TMP),Y
	EOR	#255
	CLC
	ADC	#9		;* actually 2 bytes smaller on PLAS32 but we just use this
	STA	ESTKL,X
	LDA	#0
	ADC	#0
	STA	ESTKH,X
	RTS
end

// setjmp(jmp_buf *b) -> 0 on save, longjmp val otherwise
asm setjmp
	STX	ESP

	LDY	#0
	LDA	ESTKL,X
	STA	TMPL
	STY	ESTKL,X
	LDA	ESTKH,X
	STA	TMPH
	STY	ESTKH,X

	TXA
	STA	(TMP),Y
	INY

	;* We store IFP and PP as a delta from HIMEM to avoid problems
	;* where we do setjmp(); mode(); longjmp(). TODONOW: Does this in fact help? OTOH it's not performance critical
+++	SEC
	LDA	#0
	SBC	IFPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	IFPH
	STA	(TMP),Y
	INY
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	PPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	PPH
	STA	(TMP),Y
	INY
#endif

	LDA	IPL
	STA	(TMP),Y
	INY
	LDA	IPH
	STA	(TMP),Y
	INY
#ifdef PLAS128
	LDA	$F4
	STA	(TMP),Y
	INY
#endif

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	+
	INC	TMPH
+	LDY	#0

	TSX
	TXA
	STA	(TMP),Y
--	INY
	INX
	BEQ	++
	LDA	$0100,X
	STA	(TMP),Y
	JMP	--

++	LDX	ESP
	RTS
end

// longjmp(jmp_buf *b, word val)
asm longjmp
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH
	LDA	ESTKL,X
	PHA
	LDA	ESTKH,X
	PHA

	LDY	#0
	LDA	(TMP),Y
	STA	ESP
	TAX
	INY

	PLA
	STA	ESTKH,X
	PLA
	STA	ESTKL,X
	;* if val is 0, force it to be 1
	ORA	ESTKH,X
	BNE	++++
	;* TODO: Can we just do INC ESTKL,X here?
	LDA	#1
	STA	ESTKL,X
++++

 	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	IFPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	IFPH
	INY
	;* TODONOW: This may not need to stack some things (e.g. IFP, $F4) for PLAS128
	;* because some state is pushed onto the stack by CALL and I think that is what
	;* really matters. Need to think about this with a clear head! (Don't forget
	;* that if this is the case, the various calculations of the jmp_buf size/worst
	;* case may need to return a smaller value.)
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	PPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	PPH
	INY
	;* TODONOW Test that the restore of PP is working
#endif

	LDA	(TMP),Y
	STA	IPL
	INY
	LDA	(TMP),Y
	STA	IPH
	INY
#ifdef PLAS128
	LDA	(TMP),Y
	STA	$F4
	STA	$FE30
	INY
#endif

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	++
	INC	TMPH
++	LDY	#0

	LDA	(TMP),Y
	TAX
	TXS
--	INY
	INX
	BEQ	+++
	LDA	(TMP),Y
	STA	$0100,X
	JMP	--

+++	LDX	ESP
	RTS
end

#ifdef PLAS128
//
// COPY FROM MAIN MEM TO AUX MEM.
//
// MEMXCPY(DST, SRC, SIZE)
//
// Assumes that DST to DST+SIZE-1 all lie in the same 16K bank; this will
// be true given how allocxheap() works.
asm memxcpy
	LDA	ESTKH,X
	ORA	ESTKL,X
	BEQ	MEMXCPYEX

	STY 	IPY

	;* TODO: this may want to share code with SETIPH; the two need to
	;* be consistent if they don't actually share code.
	LDA	ESTKH+2,X
	ASL
	ADC	#$00
	ASL
	ADC	#$00
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+2,X
	AND	#$BF
	ORA	#$80
	STA 	DSTH
	LDA	ESTKL+2,X
	STA	DSTL

	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	
	LDY	ESTKL,X
	BEQ	MEMXCPYLP
	INC 	ESTKH,X
	LDY	#$00
MEMXCPYLP 
	LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	MEMXCPYLP
	DEC	ESTKH,X
	BNE	MEMXCPYLP

	LDY	IPY
MEMXCPYEX
	INX
	INX
	RTS
end
#endif

//
// CONSOLE I/O
//
asm cout
	LDA	ESTKL,X
	JMP	$FFEE
end
asm cin
	DEX
	JSR	$FFE0
	STA	ESTKL,X
	LDA	#$00
	STA	ESTKH,X
	RTS
end
asm rdstr
	;* TODO: Can I avoid duplicating this definitions?
	inbuff = $700

	STX	ESP
	LDA	ESTKL,X
	JSR	$FFEE ;* TODO: Use constants for OS entry points everywhere
	LDA	#<inbuff
	STA	ESTKL,X
	LDA	#>inbuff
	STA	ESTKH,X

	SEC
	LDA	IFPL
	SBC	#5
	STA	TMPL
	LDA	IFPH
	SBC	#0
	STA	TMPH
	LDA	#<(inbuff+1)
	LDY	#0
	STA	(TMP),Y
	LDA	#>(inbuff+1)
	INY
	STA	(TMP),Y
	LDA	#254
	INY
	STA	(TMP),Y
	LDA	#0
	INY
	STA	(TMP),Y
	LDA	#255
	INY
	STA	(TMP),Y

	LDA	#0
	LDX	TMPL
	LDY	TMPH
	JSR	$FFF1
	BCC	not_escape
	LDA	#126
	JSR	$FFF4
	BRK
	!BYTE	17
	!TEXT	"Escape"
	BRK
not_escape
	STY	inbuff

	LDX	ESP
	RTS
end
asm cpu_stack_ptr
	DEX
	STX 	ESP
	TSX
	TXA
	; Don't include our stack frame in the value we return - CALL has pushed
	; six bytes, but we don't have an INTERP or ENTER as we're assembly
	; language.
	CLC
	ADC 	#6
	LDX	 ESP
	STA	 ESTKL,X
	LDA 	#0
	STA 	ESTKH,X
	RTS
end
asm get_call_jsr_return
	DEX
	LDA	#<(CALLADR+2)
	STA	ESTKL,X
	LDA	#>(CALLADR+2)
	STA	ESTKH,X
	RTS
end
asm get_ical_jsr_return
	DEX
	LDA	#<(ICALADR+2)
	STA	ESTKL,X
	LDA	#>(ICALADR+2)
	STA	ESTKH,X
	RTS
end
// def prstr(str)
asm prstr
	STX	ESP
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	BEQ	+
	TAX
-	INY
	LDA	(TMP),Y
	JSR	$FFE3
	DEX
	BNE	- 
+	LDX	ESP
	RTS
end
def crout
    cout($0A)
    return cout($0D)
end
def prbyte(v)
    cout(hexchar[(v >> 4) & $0F])
    return cout(hexchar[v & $0F])
end
def prword(v)
    prbyte(v >> 8)
    return prbyte(v)
end

// Change the screen mode
//
// Care must be taken when calling mode(). The parameter stack starts at the
// bottom of screen memory (HIMEM) and grows downwards. If a mode change
// alters HIMEM, the parameter stack needs to be relocated in memory. mode()
// takes care of this, but any code which has taken the address of local
// variables on the parameter stack (or, on PLAS128, constant strings, which
// also live on the parameter stack) will have an invalid address after
// the relocation. (This isn't an issue if changing between modes which doesn't
// alter HIMEM.)
//
// TL;DR: Call mode() as early as possible and with as few nested function
// calls in effect as possible and you'll probably be safe.
//
// Returns TRUE if the mode change was successful and FALSE if not (typically
// caused by insufficient memory).
def mode(n)
    word new_himemh, himem, new_himem
    byte s, frame_size
    word call_jsr_return, ical_jsr_return, possible_jsr_return
    word working_ifp, working_pp

    // If the mode change doesn't alter HIMEM, it's trivial. We need to check
    // specifically for the second processor case here; see the code just
    // above INITFP.
    new_himemh = call($85, n, 0, 0, $FFF4).2
    if new_himemh == ^himemh or ^himemh > $80
	cout(22)
	cout(n)
	return TRUE
    fin

    himem = ^himemh << 8
    new_himem = new_himemh << 8
#ifdef PLAS128
    gm_new_frame_start = *pp + (new_himem - himem)
    // Because we use gm_new_frame_start below, it's important that PP doesn't
    // move between now and then - which means none of the following code can
    // use constant strings. (We could redo this calculation at that point, but
    // it's nicer not to have to.)
#else
    gm_new_frame_start = *ifp + (new_himem - himem)
#endif
    // Insist on 512 bytes free afterwards, so that an application has a
    // chance to not crash after a mode change when memory is tight.
    if uword_islt(gm_new_frame_start - 512, heap)
	return FALSE
    fin

    ^himemh = new_himemh

    // We're now going to copy the parameter frame stack and adjust IFP (and
    // PP for PLAS128) accordingly. We need a temporary parameter frame
    // stack so we can call memcpy(); once we've switched to that we can't
    // access any local variables, so we copy everything into globals first.
    gm_new_himem_higher = uword_isge(new_himem, himem)
#ifdef PLAS128
    gm_new_ifp = *ifp + (new_himem - himem)
    gm_copy_from = *pp
#else
    gm_copy_from = *ifp
#endif
    gm_copy_size = himem - gm_copy_from
    gm_new_mode = n
    *ifp = heap + 256 // we know there's at least 512 bytes available

    if gm_new_himem_higher
	cout(22)
	cout(gm_new_mode)
    fin
    memcpy(gm_new_frame_start, gm_copy_from, gm_copy_size)
    if not gm_new_himem_higher
	cout(22)
	cout(gm_new_mode)
    fin
#ifdef PLAS128
    *pp = gm_new_frame_start
    *ifp = gm_new_ifp
#else
    *ifp = gm_new_frame_start
#endif
// TODO TEMP!
    if call($84, 0, 0, 0, $FFF4).2 <> ^himemh
    	prstr("foo")
    	oserror(255,"foo")
    fin	
    return TRUE
end

// Convert a DCI string to an Acorn OS-style string terminated by CR
// TODO: This should probably be coded in assembly
def dcitocr(dci, cr)
    byte len, c
    len = 0
    repeat
        c = (dci).[len]
	(cr).[len] = c & $7F
	len = len + 1
    until !(c & $80)
    (cr).[len] = $D
    return len
end

//
// CFFA1 routines
// FILE I/O
//
//def opendir
//    perr = syscall($10)
//    return perr
//end
//def readdir
//    perr = syscall($12)
//    return *CFFAEntryPtr
//end
def readfile(filename, buffer)
    byte block[18]
    block:0 = filename
    block:2 = buffer
    block:4 = 0
    block:6 = 0
    perr = (osfile($FF, @block) == 0)
    return perr
end
//
// Heap routines.
//
def availheap
    byte fp
    return @fp - heap
end
// TODO: We should maybe have an xallocheap() which generates an OS-style
// error if the allocation fails, and use that everywhere - we don't
// normally check the return code so this would be better than nothing.
def allocheap(size)
    word addr
    addr = heap
    heap = heap + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def allocalignheap(size, pow2, freeaddr)
    word align, addr
    if freeaddr
        *freeaddr = heap
    fin
    align = (1 << pow2) - 1
    addr = (heap | align) + 1
    heap = addr + size
    if uword_isge(heap, @addr)
        return 0
    fin
    return addr
end
def markheap
    return heap
end
def releaseheap(newheap)
    heap = newheap
    return @newheap - heap
end
#ifdef PLAS128
def allocxheap(size)
    word xaddr, start_bank, end_bank
    if uword_isgt(size, 16*1024-xheap_bank_start)
	return 0
    fin
    repeat
	xaddr = xheap
	xheap = xheap + size
	start_bank = xaddr & $C000
	end_bank = (xheap - 1) & $C000
	if start_bank <> end_bank
	    xheap = (xheap & $C000) | xheap_bank_start
	    if uword_islt(xheap, xaddr) // if xheap has wrapped around
		xheap = $FFFF
		return 0
	    fin
	fin
    until start_bank == end_bank
    if ^rambankcount < 4 and uword_isge(xheap, xheapsize)
	return 0
    fin
    cout('X')
    prword(xaddr)
    cout(' ')
    prword(size)
    cout(13)
    cout(10)
    return xaddr
end
#endif

//
// Acorn MOS API
//

// TODO: This should probably be coded in assembly
def stocr(str, cr)
    byte len, c
    len = ^str
    (cr).[len] = 13
    while len
	c = (str).[len]
	len = len - 1
	(cr).[len] = c
    loop
end

// oscli(str)
// TODO: Does 'export' work in this file? Probably not...
export def oscli(str)
    // TODO: This will go wrong if the command is too long
    byte cr[253]
    stocr(str, @cr)
    oscli_cr(@cr)
end

//
// Symbol table routines.
//
def lookupsym(sym)
    return lookuptbl(sym, symtbl)
end
def addsym(sym, addr)
    while ^sym & $80
        ^lastsym = ^sym
        lastsym  = lastsym + 1
        sym      = sym     + 1
    loop
    lastsym->0 = ^sym
    lastsym=>1 = addr
    lastsym    = lastsym + 3
    ^lastsym   = 0
end
//
// Module routines.
//
def lookupmod(mod)
    byte dci[17]
    return lookuptbl(modtosym(mod, @dci), symtbl)
end
def lookupstrmod(str)
    byte mod[17]
    stodci(str, @mod)
    return lookupmod(@mod)
end
def addmod(mod, addr)
    byte dci[17]
    return addsym(modtosym(mod, @dci), addr)
end
def lookupextern(esd, index)
    word sym, addr
    byte str[16]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if esd->0 & $10 and esd->1 == index
            addr = lookupsym(sym)
	    if !addr
                perr = $81
	        cout('?')
		prstr(@str)
		crout
	    fin
            return addr
        fin
        esd = esd + 3
    loop
    return 0
end
def adddef(addr, deflast)
    word defentry
    defentry = *deflast
    *deflast = defentry + 5
    defentry->0 = $20
    defentry=>1 = interp
    defentry=>3 = addr
    defentry->5 = 0 // null out next entry
    return defentry
end
def lookupdef(addr, deftbl)
    while deftbl->0 == $20
        if deftbl=>3 == addr
            return deftbl
        fin
        deftbl = deftbl + 5
    loop
    return 0
end
def loadmod(mod)
    word rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr
#ifdef PLAS128
    word defaddr
#endif
    word modaddr, modfix, modend
    word deftbl, deflast
    word moddep, rld, esd, sym
    byte str[17], filename[17]
    byte header[128]
    //
    // Read the RELocatable module header (first 128 bytes)
    //
    dcitocr(mod, @filename)
    header.0 = @filename
    header.1 = (@filename) >> 8
    perr = (osfile(5, @header) <> 1)
    rdlen = header.10 + (header.11 << 8)
    crout()
    if perr
        return -perr
    fin
    if rdlen > 0
    	// TODO: Note that we re-read the file below, so this is potentially a waste - we should
	// probably just read the first 128 bytes here, as the Apple II code does.
        readfile(@filename, heap)
	memcpy(@header, heap, 128)
	modsize = header:0
	moddep  = @header.1
	defofst = modsize
        init    = 0
        if rdlen > 4 and heap=>2 == $DA7E // DAVE = magic number :-)
            //
            // This is an EXTended RELocatable (data+bytecode) module.
            //
            defofst  = header:6
            defcnt   = header:8
            init     = header:10
            moddep   = @header.12
	    //
	    // Load module dependencies.
	    //
            while ^moddep
                if !lookupmod(moddep)
                    if loadmod(moddep) < 0
	      	        return -perr
		    fin
                fin
                moddep = moddep + dcitos(moddep, @str)
            loop
	    //
	    // Init def table.
	    //
	    deftbl   = allocheap(defcnt * 5 + 1)
	    deflast  = deftbl
	    ^deflast = 0
	    //
	    // Re-read file
	    //
	    readfile(@filename, heap)
        fin
	//
	// Alloc heap space for relocated module (data + bytecode).
	//
	moddep  = moddep  + 1 - @header + heap
	modfix  = moddep  - (heap + 2) // Adjust to skip header
	modsize = modsize - modfix
	rdlen   = rdlen   - modfix - 2
	modaddr = allocheap(modsize)
	memcpy(modaddr, moddep, rdlen)
	//
	// Add module to symbol table.
	//
	addmod(mod, modaddr)
	//
	// Apply all fixups and symbol import/export.
	//
        modfix   = modaddr - modfix
        bytecode = defofst + modfix - MODADDR
        modend   = modaddr + modsize
        rld      = modend  // Re-Locatable Directory
        esd      = rld     // Extern+Entry Symbol Directory
        while ^esd         // Scan to end of ESD
            esd = esd + 4
	loop
        esd = esd + 1
#ifdef PLAS128
	//
	// Locate bytecode defs in appropriate bank.
	//
	// TODO: We should fail gracefully if allocxheap() returns 0
	defaddr = allocxheap(rld - bytecode)
	modend  = bytecode
#endif
        //
        // Run through the Re-Location Dictionary.
        //
        while ^rld
            if ^rld == $02
	        //
		// This is a bytcode def entry - add it to the def directory.
		//
#ifdef PLAS128
                adddef(rld=>1 - defofst + defaddr, @deflast)
#else
		adddef(rld=>1 - defofst + bytecode, @deflast)
#endif
            else
                addr = rld=>1 + modfix
                if uword_isge(addr, modaddr) // Skip fixups to header
                    if ^rld & $80 // WORD sized fixup.
                        fixup = *addr
                    else	  // BYTE sized fixup.
                        fixup = ^addr
                    fin
                    if ^rld & $10 // EXTERN reference.
                        fixup = fixup + lookupextern(esd, rld->3)
                    else	  // INTERN fixup.
                        fixup = fixup + modfix - MODADDR
                        if uword_isge(fixup, bytecode)
                            //
                            // Bytecode address - replace with call def directory.
                            //
#ifdef PLAS128
                            fixup = lookupdef(fixup - bytecode + defaddr, deftbl)
#else
                            fixup = lookupdef(fixup - bytecode + bytecode, deftbl)
#endif
                        fin
                    fin
                    if ^rld & $80 // WORD sized fixup.
                        *addr = fixup
                    else	  // BYTE sized fixup.
                        ^addr = fixup
                    fin
                fin
            fin
            rld = rld + 4
        loop
	//
        // Run through the External/Entry Symbol Directory.
	//
        while ^esd
            sym = esd
            esd = esd + dcitos(esd, @str)
            if ^esd & $08
		//
                // EXPORT symbol - add it to the global symbol table.
		//
                addr = esd=>1 + modfix - MODADDR
                if uword_isge(addr, bytecode)
		    //
		    // Use the def directory address for bytecode.
		    //
#ifdef PLAS128
                    addr = lookupdef(addr - bytecode + defaddr, deftbl)
#else
                    addr = lookupdef(addr - bytecode + bytecode, deftbl)
#endif
                fin
                addsym(sym, addr)
            fin
            esd = esd + 3
        loop
#ifdef PLAS128
	//
	// Move bytecode to AUX bank.
	//
	memxcpy(defaddr, bytecode, modsize - (bytecode - modaddr))
#endif
    fin
    if perr
        return -perr
    fin
    //
    // Call init routine if it exists.
    //
    fixup = 0
    if init
#ifdef PLAS128
	fixup = adddef(init - defofst + defaddr, @deflast)()
#else
	fixup = adddef(init - defofst + bytecode, @deflast)()
#endif
    if fixup < 0
        perr = -fixup
    fin
    // TODO: modinitkeep stuff is a bit different compared to Apple II; switch to II-style?
	if !(systemflags & modinitkeep)
#ifdef PLAS128
            xheap = init - defofst + defaddr
	    cout('Q')
	    prword(xheap)
	    cout(13)
	    cout(10)
#else
            modend = init - defofst + bytecode
#endif
	fin
    fin
    //
    // Free up the end-of-module in main memory.
    //
    releaseheap(modend)
    return fixup | (systemflags & modkeep)
end
//
// Command mode
//
def stripchars(strptr)
    while ^strptr and ^(strptr + 1) <> ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
    return ^strptr
end
def stripspaces(strptr)
    while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)
    byte i

    for i = 1 to ^strptr
        if (strptr)[i] == ' '
	    ^strptr = i - 1
	    return
	fin
    next
end
def parsecmd(strptr)
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
// User code could choose to install an alternate error handler, but
// it's probably not a good idea; most of the time user code should
// restrict itself to manipulating *errjb.
def error_handler
  // The error number is available to the target at ^errnum but since
  // longjmp() naturally passes along a value we pass the error number.
  longjmp(*errjb, ^errnum)
end
def execmod(modfile)
    byte moddci[17]
    word saveheap
#ifdef PLAS128
    word savexheap
#endif
    word savesym, saveflags, error, action, olderrjb
    // We know that we have a fairly shallow CPU stack here so we can
    // get away with this small jmp_buf on the stack; this saves us
    // having to allocate a fixed block of memory for it. (We can't
    // allocate on the heap temporarily here, as the space would get
    // 'trapped' below the loaded module if it's to remain resident.)
    byte jb[100]

    perr = 1
    if stodci(modfile, @moddci)
        saveheap  = heap
#ifdef PLAS128
	savexheap = xheap
#endif
	savesym   = lastsym
	saveflags = systemflags
        olderrjb = *errjb
	error = setjmp(@jb)
	if error == 0
	    *errjb = @jb
	    action = loadmod(@moddci)
	fin
	*errjb = olderrjb
	if error <> 0 or action < modkeep
	    lastsym = savesym
#ifdef PLAS128
	    xheap   = savexheap
#endif
	    heap    = saveheap
	fin
	^lastsym    = 0
	systemflags = saveflags
	if error <> 0
	    error_handler()
	fin
    fin
    return -perr
end
//
// Get heap start.
//
heap = *freemem
#ifdef PLAS128
    xheapsize = ^rambankcount * 16 * 1024
#endif
//
// Init symbol table.
//
symtbl   = allocheap($200)
lastsym  = symtbl
^lastsym = 0
stodci(@syslibstr, heap)
addmod(heap, @version)
while *syslibsym
    stodci(syslibsym=>0, heap)
    addsym(heap, syslibsym=>2)
    syslibsym = syslibsym + 4
loop
//
// Set up error handler
//
*errjb = markheap()
if setjmp(*errjb) == 0
  allocheap(jmpbufsz(*errjb))
  *errfp = @error_handler
else
  crout
  prstr(@errorstr)
  prbyte(^errnum)
  prstr(@colonstr)
  prstr(errstr)
  crout
fin
//
// Try to load autorun.
// TODO: This is disabled; it's awkward as it can cause an OS error, and
// it's not all that useful as a !BOOT file can do the same job.
//
cmdptr = heap
memset(cmdptr, 0, 128)
//readfile(@autorun, cmdptr + 1)
while ^(cmdptr + ^cmdptr + 1) >= ' '
    ^cmdptr = ^cmdptr + 1
loop
perr = 0
// TODO: Might be best to base this on cmd.pla's version not the Apple I code
//
// Print some startup info.
//
if not ^cmdptr
    prstr(@verstr)
    prbyte(version.1)
    cout('.')
    prbyte(version.0)
    crout
    // TODO: Temporarily moved this to prompt instead of only displaying it
    // on startup; this makes it more obvious if heap gets leaked.
    //prstr(@freestr)
    //prword(availheap)
#ifdef PLAS128
    //prstr(@xfreestr)
    //prword(xheapsize - 1 - xheap) // a bit approximate
#endif
    //crout
fin
//
// Handle commands.
//
while 1
    if ^cmdptr
        when toupper(parsecmd(cmdptr))
            is 'Q'
	        quit
//	    is 'M'
//	        syscall($02)
//		break
	    is '+'
	        execmod(cmdptr)
		break
	    is '*'
	    	oscli(cmdptr)
		break
	    otherwise
	        prstr(@huhstr)
        wend
        if perr
            prstr(@errorstr)
	    prbyte(perr)
	    perr = 0
        else
            prstr(@okstr)
        fin
	crout()
    fin
    prstr(@freestr)
    prword(availheap)
#ifdef PLAS128
    prstr(@xfreestr)
    prword(xheapsize - 1 - xheap) // a bit approximate
#endif
    crout
    prstr(@prompt)
    cmdptr = rdstr(':')
loop
done
