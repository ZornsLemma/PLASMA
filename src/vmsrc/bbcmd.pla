// OK, this is a bit ugly... We (mis)use the C preprocessor to allow
// this file to be conditionally compiled to build PLASMA ("PLAS32") and
// PLAS128, based on whether PLAS128 is defined or not. plvmbb.s also
// uses an ACME constant called PLAS128 to provide conditional assembly there.
// Because this file contains inline ACME assembler which wants to be able to
// say things like '!IFDEF PLAS128', it's important that PLAS128 is defined to
// be 'PLAS128', so that the C preprocessor effectively leaves those !IFDEF
// lines alone. We could simply make sure we define it to the appropriate value
// in the makefile, but it seems safest and slightly cleaner (since it gives us
// a place to write this comment) to enforce this here.
#ifdef PLAS128
    #undef PLAS128
    #define PLAS128 PLAS128
#endif

include "inc/acornc.plh"

// TODO: Weird - *SPOOL Z then *PLAS128 *immediately* closes the *SPOOL file.
// *PLASMA doesn't exhibit this. Note that there's no need to load a module,
// the startup banner and prompt don't make it into the spool file. Oh no,
// this is a consequence of the current futzing around to try to make it
// run on I/O processor when 2P is active. If that works out in the end,
// this is probably acceptable. (However, possibly not. Does this cause
// problems if a *EXEC-able !BOOT file wants to do something like:
// *PLAS128
// +MYPROG
// If it does this might be unacceptable. Possibly it would be nice to allow
// a command to be executed to be given as an argument to PLAS128 - then you
// could do '*PLAS128 +MYPROG' - but even then losing the flexibility of the
// *EXEC !BOOT option isn't ideal. I haven't tested to see if this does break
// that case yet.) OK, I have now tested - yes, on a second processor such a
// !BOOT does stop without "typing" in the +MYPROG. It *does* work fine if you
// don't have a second processor turned on, so arguably this is not too big a
// deal - the alternatives are "if there is a second processor, do we refuse to
// run PLAS128 or run it but refuse to accept any commands via *EXEC"

const MODADDR      = $1000

// The following constants must be kept in sync with vmsrc/plvmzp.inc and
// vmsrc/acornc.inc.

// Note that we cannot rely on initialisation of non-constant globals; on
// PLAS32 running on a second processor, the VM is re-entered on BREAK and
// any globals will have their post-modification values, not the original
// values.

const inbuff       = $0700
const errnum       = $0700
const errstr	   = $0701
const freemem      = $0006 	// 'SRC' zp, used to indicate heap start
const ifp          = $0071
#ifdef PLAS128
    const pp           = $0073
#endif
const himemh       = $0078
const scratch	   = $0079
#ifdef PLAS128
    const rambankcount = $0404
#endif
const errfp	   = $0405	// 2 bytes
const errjb	   = $0407	// 2 bytes

#ifndef STANDALONE
// TODO: I am currently very wasteful of memory in $400-$800; for
// now we just allot this little part of it for the initial symbol
// table, but this can probably be expanded later as the memory use
// is tided up
const lowsymtblchunk = $0409
const lowsymtblchunksz = $50 // $150 // TODO $02f7

const maxnamelen = 16
const maxsymlen = maxnamelen + 1 // 1 for '#' prefix for module name
const maxpathlen = 256
#endif
const false = 0
const true = not false
// TODO: allocheap_fail_threshold should probably be a non-constant
// and be modifiable under program control (if so, modexec() should
// probably reset it to a default on successful or unsuccessful
// execution). While we're developing, we just stick with this.
const allocheap_fail_threshold = $FFFF
//
// Module don't free memory
//
const modkeep     = $2000
const modinitkeep = $4000
//
// Predefined functions.
//
// TODO: It would be nice if these could be omitted and we could 'include
// "inc/cmdsys.plh"' instead, but this doesn't seem to work. Perhaps try this
// kind of thing with upstream compiler and ask Dave.
predef syscall(cmd,params)#1, call(addr,areg,xreg,yreg,status)#1
predef putln()#0, putc(c)#0, puts(s)#0, getc()#1, gets(p)#1
predef heapmark()#1, heapalloc(size)#1, xheapalloc(size)#1, heapallocalign(size, pow2, freeaddr), heaprelease(newheap)#1, heapavail()#1
predef memset(addr,value,size)#0, memcpy(dst,src,size)#0
predef isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
predef modload(mod)#1, modexec(modfile)#1, modaddr(str)#1
predef setjmp(b)#1, longjmp(b, val)#0
predef prbyte(v)#0
predef oserror(n, msg)#0
predef call_oscli(str)#0
predef stocr(str, cr)#0
predef mode(n)#1
predef callalloca
//
// System variables.
//
word version     = $0099 // 00.99
// word systemflags = 0 TODO: delete this? commented out for now
const heapptr = $0089
#ifdef PLAS128
    word xheapsize
    // We leave $8000-$8008 inclusive free in each 16K sideways RAM bank
    // to avoid the risk of the data accidentally looking like a valid
    // sideways ROM header.
    const xheap_bank_start = $09
    const xheap_bank_size = 16 * 1024
    word xheap = xheap_bank_start
#endif
#ifndef STANDALONE
word symtblchunk
word lastsym
byte perr
//
// String pool.
// We don't strictly speaking need this, now that the CS opcode uses string
// pooling in PLAS128 in a way which works even if there's a mode change
// between two executions of the same CS opcode. However, not using this
// manual string pool only saves 12 bytes in PLAS32 and it costs 5 bytes in
// PLAS128, because we need a copy of the string in the binary and on the
// parameter stack (the binary is in main RAM here, not in sideways
// RAM), so we stick with it. TODO: We could in principle conditionally
// compile this, but it's awfully fiddly.
//
byte verstr[]     = "PLASMA "
byte freestr[]    = "MEM FREE:$"
#ifdef PLAS128
    byte xfreestr[]	  = ", AUX FREE:$"
#endif
byte errorstr[]   = "ERR:$"
byte prompt[]     = "PLASMA"
byte okstr[]      = "OK"
byte huhstr[]     = "?\n"
byte colonstr[]   = ": "
#endif
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
//
// Exported Machine ID. We somewhat arbitrarily assign the apparently free code
// $C8 for all Acorn machines; once you know you're on an Acorn machine you can
// use something like OSBYTE 0 to determine the exact model.
//
export byte machid       = $C8
#ifndef STANDALONE
//
// Command line pointer
//
word cmdptr
//
// File handle used by modload (so we can close it if an error occurs)
//
byte modload_handle
//
// Pointer to function used to transform a module name into a filename; used to
// allow a user to load a resident module to override the default
// small-but-simplistic implementation.
//
word modname
#endif
//
// Global variables for use by mode()
//
word gm_himem_delta
word gm_new_frame_start
#ifdef PLAS128
    word gm_new_ifp
#endif
word gm_copy_from
word gm_copy_size
byte gm_new_mode
#ifndef STANDALONE
//
// Standard Library exported functions.
//
include "vmsrc/symtab.pla"
#endif
//
// CALL 6502 ROUTINE
// CALL(ADDR, AREG, XREG, YREG, STATUS)
//
export asm call(addr,areg,xreg,yreg,sstatus)#1
REGVALS =   SRC
        PHP
        LDA     ESTKL+4,X
        STA     TMPL
        LDA     ESTKH+4,X
        STA     TMPH
        LDA     ESTKL,X
        PHA
        LDA     ESTKL+1,X
        TAY
        LDA     ESTKL+3,X
        PHA
        LDA     ESTKL+2,X
        INX
        INX
        INX
        INX
        STX     ESP
        TAX
        PLA
        PLP
        JSR     JMPTMP
        PHP
        STA     REGVALS+0
        STX     REGVALS+1
        STY     REGVALS+2
        PLA
        STA     REGVALS+3
        LDX     ESP
        LDA     #<REGVALS
        LDY     #>REGVALS
        STA     ESTKL,X
        STY     ESTKH,X
        PLP
        RTS
end
//
// SET MEMORY TO VALUE
// MEMSET(ADDR, VALUE, SIZE)
//   With optimizations from Peter Ferrie
//
export asm memset(addr,value,size)#0
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	LDY     ESTKL,X
	BEQ     +
	INC     ESTKH,X
	LDY     #$00
+	LDA     ESTKH,X
	BEQ     SETMEX
SETMLPL	CLC
	LDA     ESTKL+1,X
SETMLPH	STA     (DST),Y
	DEC     ESTKL,X
	BEQ     ++
-	INY
	BEQ     +
--	BCS     SETMLPL
	SEC
	LDA     ESTKH+1,X
	BCS     SETMLPH
+	INC     DSTH
	BNE     --
++	DEC     ESTKH,X
	BNE     -
SETMEX	INX
	INX
	INX
	RTS
end
//
// COPY MEMORY
// MEMCPY(DSTADDR, SRCADDR, SIZE)
//
export asm memcpy(dst,src,size)#0
	INX
	INX
	INX
	LDA	ESTKL-3,X
	ORA	ESTKH-3,X
	BEQ	CPYMEX
	LDA	ESTKL-2,X
	CMP	ESTKL-1,X
	LDA	ESTKH-2,X
	SBC	ESTKH-1,X
 	BCC	REVCPY
;
; FORWARD COPY
;
	LDA	ESTKL-1,X
	STA 	DSTL
	LDA	ESTKH-1,X
	STA 	DSTH
	LDA	ESTKL-2,X
	STA 	SRCL
	LDA	ESTKH-2,X
	STA 	SRCH
	LDY	ESTKL-3,X
	BEQ	FORCPYLP
	INC 	ESTKH-3,X
	LDY	#$00
FORCPYLP LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL-3,X
	BNE	FORCPYLP
	DEC	ESTKH-3,X
	BNE	FORCPYLP
	RTS
;
; REVERSE COPY
;
REVCPY	;CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-1,X
	STA	DSTL
	LDA	ESTKH-3,X
	ADC	ESTKH-1,X
	STA	DSTH
	CLC
	LDA 	ESTKL-3,X
	ADC	ESTKL-2,X
	STA	SRCL
	LDA	ESTKH-3,X
	ADC	ESTKH-2,X
	STA	SRCH
	DEC	DSTH
	DEC	SRCH
	LDY	#$FF
	LDA 	ESTKL-3,X
	BEQ	REVCPYLP
	INC 	ESTKH-3,X
REVCPYLP LDA	(SRC),Y
	STA	(DST),Y
	DEY
	CPY	#$FF
	BNE	+
	DEC	DSTH
	DEC	SRCH
+	DEC 	ESTKL-3,X
	BNE	REVCPYLP
	DEC	ESTKH-3,X
	BNE	REVCPYLP
CPYMEX	RTS
end
//
// Unsigned word comparisons.
//
export asm isuge(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isule(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
	EOR	#$FF
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isugt(a,b)#1
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
export asm isult(a,b)#1
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
	LDA	#$FF
	ADC	#$00
 	STA	ESTKL+1,X
	STA	ESTKH+1,X
	INX
	RTS
end
#ifndef STANDALONE
//
// Addresses of internal routines.
//
asm interp()#1
	DEX
	LDA	#<IINTERP
	STA	ESTKL,X
	LDA	#>IINTERP
	STA	ESTKH,X
	RTS
end
// 
// A DCI string is one that has the high bit set for every character except the last.
// More efficient than C or Pascal strings.
//
//def dcitos(dci, str)
//    byte len, c
//    len = 0
//    repeat
//        c = (dci).[len]
//        len = len + 1
//        (str).[len] = c & $7F
//    until !(c & $80)
//    ^str = len
//    return len
//end
asm dcitos(dci, str)#1
	JSR	INITDSTSRCY
-	LDA	(SRC),Y
	CMP	#$80
	AND	#$7F
	INY
	STA	(DST),Y
	BCS	-
	TYA
	LDY	#$00
	STA	(DST),Y
        INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
INITDSTSRCY
	LDA	ESTKL,X
	STA	DSTL
	LDA	ESTKH,X
	STA	DSTH
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDY	#$00
        RTS
end
//def stodci(str, dci)
//    byte len, c
//    len = ^str
//    if len == 0
//        return 0
//    fin
//    c = toupper((str).[len]) & $7F
//    len = len - 1
//    (dci).[len] = c
//    while len
//    	c = toupper((str).[len]) | $80
//    	len = len - 1
//    	(dci).[len] = c
//    loop
//    return ^str
//end
asm stodci(str,dci)#1
	JSR	INITDSTSRCY
        INX
	LDA	(SRC),Y
	BEQ	++
	TAY
	LDA	(SRC),Y
	JSR	TOUPR
	BNE	+
-	LDA	(SRC),Y
	JSR	TOUPR
	ORA	#$80
+	DEY
	STA	(DST),Y
	BNE	-
	LDA	(SRC),Y
++	STA	ESTKL,X
	STY	ESTKH,X
	RTS
end
asm toupper(c)#1
	LDA     ESTKL,X
TOUPR	AND     #$7F
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SBC     #$1F
+	STA     ESTKL,X
	RTS
end
// Convert a DCI string to an Acorn OS-style string terminated by CR
// int dcitocr(dci, cr) - returns length (of DCI string/excluding CR)
asm dcitocr(dci, cr)#1
	JSR	INITDSTSRCY
	INX
	STY	ESTKH,X
-	LDA	(SRC),Y
	CMP	#$80		; set C iff >= $80
	AND	#$7F
	STA	(DST),Y
	INY
	BCS	-
	LDA	#$0D
	STA	(DST),Y
	STY	ESTKL,X
	RTS
end
#endif
// Converts a PLASMA string to an Acorn OS-style string terminated by CR
// void stocr(str, cr)
export asm stocr(str, cr)#0
	JSR	INITDSTSRCY
        INX
	INX
	STX	ESP
	LDA	(SRC),Y
	BEQ	+
	TAX
-	INY
	LDA	(SRC),Y
	DEY
	STA	(DST),Y
	INY
	DEX
	BNE	-
+	LDA	#$0D
	STA	(DST),Y
	LDX	ESP
	RTS
end

#ifndef STANDALONE
//
// Module symbols are entered into the symbol table
// pre-pended with a '#' to differentiate them
// from normal symbols.
//
//def modtosym(mod, dci)
//    byte len, c
//    (dci).0 = '#'|$80
//    len = 0
//    repeat
//        c = (mod).[len]
//        len = len + 1
//        (dci).[len] = c
//    until !(c & $80)
//    return dci
//end
asm modtosym(mod,dci)#1
	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	LDA	ESTKL,X
	STA	ESTKL+1,X
	STA	DSTL
	LDA	ESTKH,X
	STA	ESTKH+1,X
	STA	DSTH
	INX
	LDY	#$00
	LDA	#'#'+$80
-	STA	(DST),Y
	ASL
	LDA	(SRC),Y
	INY
	BCS	-
	RTS
end
//
// Lookup routines.
//
asm lookuptbl(dci, tbl)#1
	JSR	INITDSTSRCY
.NEXT	LDY	#$00
.NEXTY	LDA	(DST),Y
	BEQ	.TABLEEND
        CMP	#$01
        BEQ	.CHUNKEND
	CMP	(SRC),Y
	BNE	.NOTMATCH
	INY
	ASL
	BCS	.NEXTY
	LDA	(DST),Y
	PHA
	INY
	LDA	(DST),Y
	TAY
	PLA
.EXIT	INX
	STA	ESTKL,X
	STY	ESTKH,X
	RTS
.TABLEEND
        TAY
        BEQ	.EXIT
.NOTMATCH
	LDY	#$00
.SKIP	LDA	(DST),Y
	INC	DSTL
	BEQ	.DSTCARRY
.DSTCARRYDONE
	ASL
	BCS	.SKIP
	LDA	#$02
	ADC	DSTL
	STA	DSTL
	BCC	.NEXTY
	INC	DSTH
	BCS	.NEXTY
.DSTCARRY
	INC	DSTH
	BNE	.DSTCARRYDONE
.CHUNKEND 
	LDY	#$02
	LDA	(DST),Y
	PHA
	DEY
	LDA	(DST),Y
	STA	DSTL
	PLA
	STA	DSTH
	BNE	.NEXT
end
#endif

//
// Large frame allocation API
// 
// This is effectively a varargs function; given a function foo:
// 	def foo(a, b, c)
// if you execute:
//	x = callalloca(5, 25, @foo, 512)
// it behaves 'as if' you wrote:
//	byte tmp[512]
//	x = foo(5, 25, @tmp)
// and then 'tmp' is immediately freed on exit from foo().
// This is useful because normal local variables are restricted to a total
// of 256 bytes per function.
//
// Note that if the function being called has a #n on its definition with n!=1,
// the same #n must be appended to the call to callalloca(), otherwise things
// will go wrong - callalloca() actually leaves the expression stack alone after
// calling the specified function.
export asm callalloca
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH

	SEC
!IFNDEF PLAS128 {
	LDA	IFPL
	PHA
	SBC	ESTKL,X
	STA	IFPL
	STA	ESTKL+1,X
	LDA	IFPH
	PHA
	SBC	ESTKH,X
	STA	IFPH
	STA	ESTKH+1,X
	+CHECKVSHEAP IFP
} ELSE {
	LDA	PPL
	PHA
	SBC	ESTKL,X
	STA	PPL
	STA	ESTKL+1,X
	LDA	PPH
	PHA
	SBC	ESTKH,X
	STA	PPH
	STA	ESTKH+1,X
	+CHECKVSHEAP PP
	; We don't need to update IFP; if the called function uses the frame
	; stack, ENTER will set IFP=PP-frame_size.
}
	INX

	JSR	JMPTMP

!IFNDEF PLAS128 {
	PLA
	STA	IFPH
	PLA
	STA	IFPL
} ELSE {
	PLA
	STA	PPH
	PLA
	STA	PPL
}

	RTS
end

//
// ACORN OS ERROR GENERATION
//
export asm oserror(n, msg)#0
	LDA	ESTKL+1,X
	STA	$101
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	TAY
	LDA	#0
	STA	$100 ; BRK opcode
	STA	$102,Y
-	LDA	(TMP),Y
	STA	$101,Y
	DEY
	BNE	-
	JMP	$100
end

//
// NONLOCAL GOTO
//

// setjmp(jmp_buf *b) -> 0 on save, longjmp val otherwise
export asm setjmp(b)#1
	STX	ESP

	LDY	#0
	LDA	ESTKL,X
	STA	TMPL
	STY	ESTKL,X
	LDA	ESTKH,X
	STA	TMPH
	STY	ESTKH,X

	TXA
	STA	(TMP),Y
	INY

	; Note that we know there's at least one element on ESTK as
	; we received our 'b' argument on it. We could avoid saving
	; that but it seems simplest just to include it.
----	LDA	ESTKL,X
	STA	(TMP),Y
	INY
	LDA	ESTKH,X
	STA	(TMP),Y
	INY
	INX
    	CPX	#ESTKSZ/2
	BNE	----

	;* We store IFP and PP as a delta from HIMEM to avoid problems
	;* where we do setjmp(); mode(); longjmp().
+++	SEC
	LDA	#0
	SBC	IFPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	IFPH
	STA	(TMP),Y
	INY
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	PPL
	STA	(TMP),Y
	INY
	LDA	HIMEMH
	SBC	PPH
	STA	(TMP),Y
	INY
#endif

	;* We don't need to save IP, IPY or (for PLAS128) the current bank at 
	;* $F4; CALL/ICAL save and restore these themselves. (Remember that
	;* when longjmp() reaches its RTS, control returns to just after the
	;* JSR inside the CALL/ICAL which called setjmp.)

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	+
	INC	TMPH
+	LDY	#0

	TSX
	TXA
	STA	(TMP),Y
        ; Y=0 at this point; we assume the CPU stack is not completely full
        ; (X=$FF) at this point (if it is, we're in trouble, because an
        ; interrupt could occur and push more onto the stack) and therefore we
        ; know that Y can't wrap round during the following loop.
--	INX
	BEQ	++
	LDA	$0100,X
	INY
	STA	(TMP),Y
        BNE     --              ; always branches

++	LDX	ESP
	RTS
end

// longjmp(jmp_buf *b, word val)
// Control never returns to caller; we declare this to return no values so the
// caller doesn't waste space on a redundant DROP opcode after the CALL.
export asm longjmp(b, val)#0
	LDA	ESTKL+1,X
	STA	TMPL
	LDA	ESTKH+1,X
	STA	TMPH
	LDA	ESTKL,X
	PHA
	LDA	ESTKH,X
	PHA

	LDY	#0
	LDA	(TMP),Y
	STA	ESP
	TAX
	INY
-	LDA	(TMP),Y
	STA	ESTKL,X
	INY
	LDA	(TMP),Y
	STA	ESTKH,X
	INY
	INX
	CPX 	#ESTKSZ/2
	BNE	-
        LDX	ESP

	PLA
	STA	ESTKH,X
	PLA
	STA	ESTKL,X
	;* if val is 0, force it to be 1
	ORA	ESTKH,X
	BNE	++++
	INC	ESTKL,X
++++

 	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	IFPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	IFPH
	INY
#ifdef PLAS128
	SEC
	LDA	#0
	SBC	(TMP),Y
	STA	PPL
	INY
	LDA	HIMEMH
	SBC	(TMP),Y
	STA	PPH
	INY
#endif

	TYA
	CLC
	ADC	TMPL
	STA	TMPL
	BCC	++
	INC	TMPH
++	LDY	#0

	LDA	(TMP),Y
	TAX
	TXS

        ;* As in setjmp(), we can assume X is not $FF and so we know Y can't
        ;* wrap round during this loop.
--	INX
	BEQ	+++
        INY
	LDA	(TMP),Y
	STA	$0100,X
        JMP	--

+++	

	;* PLAS128: CS may have allocated some constant strings after setjmp()
	;* was called, but when we restore the value of PP saved by setjmp()
	;* we effectively just reset the pool back to the state at the setjmp()
	;* point.

	LDX	ESP
	RTS
end

#ifdef PLAS128
//
// COPY FROM MAIN MEM TO AUX MEM.
//
// MEMXCPY(DST, SRC, SIZE)
//
// Assumes that DST to DST+SIZE-1 all lie in the same 16K bank; this will
// be true given how allocxheap() works.
asm memxcpy(dst,src,size)#0
	LDA	ESTKH,X
	ORA	ESTKL,X
	BEQ	MEMXCPYEX

	STY 	IPY

	;* This code must be kept consistent with IINTERP
	LDA	ESTKH+2,X
        ROL
        ROL
        ROL
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+2,X
	AND	#$BF
	ORA	#$80
	STA 	DSTH
	LDA	ESTKL+2,X
	STA	DSTL

	LDA	ESTKL+1,X
	STA	SRCL
	LDA	ESTKH+1,X
	STA	SRCH
	
	LDY	ESTKL,X
	BEQ	MEMXCPYLP
	INC 	ESTKH,X
	LDY	#$00
MEMXCPYLP 
	LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	MEMXCPYLP
	DEC	ESTKH,X
	BNE	MEMXCPYLP

	LDY	IPY
MEMXCPYEX
	INX
	INX
	INX
	RTS
end
#endif

//
// CONSOLE I/O
//
export asm putln()#0
        ; Since this is so simple, it's highly tempting to try to do away with
        ; it and have code call OSNEWL directly. This is possible for loaded
        ; modules - we can simply arrange for the "putln" entry in the symbol
        ; table to point to OSNEWL. However, it's trickier to make it work here
        ; in the core VM. We can omit this definition and do 'const putln =
        ; osnewl' but calling through a function pointer (as this effectively
        ; is) requires the call site to specify '#0' (we can't attach that type
        ; information to the function pointer itself) - I haven't actually tried
        ; that but it would probably work, but it would be a bit intrusive.
        ; Since this JMP OSNEWL therefore "has" to exist, I haven't bothered
        ; making the symbol table just refer directly to OSNEWL lest it cause
        ; confusion - the performance overhead is negligible.
	JMP	OSNEWL
end
export asm putc(c)#0
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
// Just a helper function for mode(); smaller than writing it in PLASMA.
asm putc22(n)#0
	LDA	#22
	JSR	OSWRCH
	LDA	ESTKL,X
	INX
	JMP	OSWRCH
end
export asm getc()#1
	DEX
	JSR	OSRDCH
        BCS	ESCAPE
	STA	ESTKL,X
	LDA	#$00
	STA	ESTKH,X
	RTS
end
export asm gets(p)#1
	STX	ESP
	LDA	ESTKL,X
	JSR	OSWRCH
	LDA	#<INBUFF
	STA	ESTKL,X
	LDA	#>INBUFF
	STA	ESTKH,X
        LDA	#0
        LDX	#<OSWORD0BLK
        LDY	#>OSWORD0BLK
	JSR	OSWORD
	BCS	ESCAPE
	STY	INBUFF
	LDX	ESP
	RTS
ESCAPE
	LDA	#osbyte_acknowledge_escape
	JSR	OSBYTE
	BRK
	!BYTE	17
	!TEXT	"Escape"
	BRK
OSWORD0BLK
	!WORD	INBUFF+1
        !BYTE	INBUFFSZ-1
        !BYTE	32
        !BYTE	255
end
// def puts(str)
export asm puts(s)#0
	STX	ESP
	LDA	ESTKL,X
	STA	TMPL
	LDA	ESTKH,X
	STA	TMPH
	LDY	#0
	LDA	(TMP),Y
	BEQ	+
	TAX
-	INY
	LDA	(TMP),Y
	JSR	OSASCI
	DEX
	BNE	- 
+	LDX	ESP
	INX
	RTS
end
export def prbyte(v)#0
    putc(hexchar[(v >> 4) & $0F])
    putc(hexchar[v & $0F])
end
#ifndef STANDALONE
def prword(v)#0
    prbyte(v >> 8)
    prbyte(v)
end
#endif

// TODO: export this?
// TODO: as well/instead, could I provide a setjmp() wrapper which returns a
// pair of values - the regular setjmp return code and the address of a
// dynamically allocated jmp_buf automatically sized appropriately? I could
// potentially use that function instead of setjmp() in the core VM code.
// Perhaps even just call it 'setjmp2' - short name is valuable given it takes
// space in symbol table, and it would help convey the '2 return value' nature.
// dword jmpbufsz(const jmp_buf *jb) - returns actual size of *jb
def jmpbufsz(jb)#1
	const esp_size = 1
	const esp_offset = 0
#ifdef PLAS128
	const pp_size = 2
#else
	const pp_size = 0
#endif
	const ifp_size = 2
	const stack_ptr_size = 1
	const estksz = 32
	const estksz_elems = estksz / 2
	word size
	word stack_ptr
	size = esp_size + 2 * (estksz_elems - jb->esp_offset) + ifp_size + pp_size
	stack_ptr = ^(jb + size)
	size = size + stack_ptr_size + (255 - stack_ptr)
	return size
end

// Change the screen mode
//
// Care must be taken when calling mode(). The parameter stack starts at the
// bottom of screen memory (HIMEM) and grows downwards. If a mode change
// alters HIMEM, the parameter stack needs to be relocated in memory. mode()
// takes care of this, but any code which has taken the address of local
// variables on the parameter stack (or, on PLAS128, constant strings, which
// also live on the parameter stack) will have an invalid address after
// the relocation. (This isn't an issue if changing between modes which doesn't
// alter HIMEM.)
//
// TL;DR: Call mode() as early as possible and with as few nested function
// calls in effect as possible and you'll probably be safe.
//
// Returns true if the mode change was successful and false if not (typically
// caused by insufficient memory).
export def mode(n)#1
    word new_himemh, himem, new_himem

    // If the mode change doesn't alter HIMEM, it's trivial. We need to check
    // specifically for the second processor case here; see the code just
    // above INITFP.
    new_himemh = call(osbyte, osbyte_read_himem_for_mode, n, 0, 0).2
    if new_himemh == ^himemh or ^himemh > $80
        putc22(n)
	return true
    fin

    himem = ^himemh << 8
    new_himem = new_himemh << 8
    gm_himem_delta = new_himem - himem
#ifdef PLAS128
    gm_new_frame_start = *pp + gm_himem_delta
    // Because we use gm_new_frame_start below, it's important that PP doesn't
    // move between now and then - which means none of the following code can
    // use constant strings. (We could redo this calculation at that point, but
    // it's nicer not to have to.)
#else
    gm_new_frame_start = *ifp + gm_himem_delta
#endif
    // Insist on 512 bytes free afterwards, so that an application has a
    // chance to not crash after a mode change when memory is tight.
    if isult(gm_new_frame_start - 512, *heapptr)
	return false
    fin

    ^himemh = new_himemh

    // We're now going to copy the parameter frame stack and adjust IFP (and
    // PP for PLAS128) accordingly. We need a temporary parameter frame
    // stack so we can call memcpy(); once we've switched to that we can't
    // access any local variables, so we copy everything into globals first.
#ifdef PLAS128
    gm_new_ifp = *ifp + gm_himem_delta
    gm_copy_from = *pp
#else
    gm_copy_from = *ifp
#endif
    gm_copy_size = himem - gm_copy_from
    gm_new_mode = n
    *ifp = *heapptr + 256 // we know there's at least 512 bytes available

    if gm_himem_delta >= 0
	putc22(gm_new_mode)
    fin
    memcpy(gm_new_frame_start, gm_copy_from, gm_copy_size)
    if gm_himem_delta < 0
	putc22(gm_new_mode)
    fin
#ifdef PLAS128
    *pp = gm_new_frame_start
    *ifp = gm_new_ifp
#else
    *ifp = gm_new_frame_start
#endif
// TODO TEMP!
    if call(osbyte, osbyte_read_himem, 0, 0, 0).2 <> ^himemh
    	puts("foo")
    	oserror(255,"foo")
    fin	
    return true
end

//
// FILE I/O
//
#ifndef STANDALONE
def high_order_address()#1
    return call(osbyte, osbyte_read_high_order_address, 0, 0, 0):1
end
def oserror_not_found()#0
    oserror(214, "Not found")
end
#endif
//
// Heap routines.
//
export def heapavail()#1
    byte fp
    return @fp - *heapptr
end
def heapfull()#0
    puts("heapalloc failed\n") // TODO TEMP
    oserror(0, "Heap full") // TODO: Non-0 error code? (In the language range..)
end
// heapalloc() generates an OS error if the allocation fails and is
// no larger than allocheap_fail_threshold; failures otherwise return
// 0. The idea here is that as well as allowing "always" and "never"
// generating an OS error, a program may take more care to check big
// allocations (e.g. loading a file containing user data) than it will
// do with small allocations (where it might not be able to do much
// except die even if it checks and notices that they failed).
export def heapalloc(size)#1
    word addr
    if isugt(size, heapavail())
	if isule(size, allocheap_fail_threshold)
	    heapfull()
	fin
	return 0
    fin
    addr = *heapptr
    *heapptr = *heapptr + size
    return addr
end
// Like heapalloc(), but *always* generates an error if the allocation
// fails, regardless of the size requested and the fail threshold.
export def xheapalloc(size)#1
    word addr
    addr = heapalloc(size)
    if addr == 0
	heapfull()
    fin
    return addr
end
export def heapallocalign(size, pow2, freeaddr) // TODO: ADD#? ALSO IN .plh
    word align, addr
    if freeaddr
        *freeaddr = *heapptr
    fin
    align = (1 << pow2) - 1
    addr = *heapptr
    if addr & align
        addr = (addr | align) + 1
    fin
    if !heapalloc(size + (addr - *heapptr))
        return 0
    fin
    return addr
end
export def heapmark()#1
    return *heapptr
end
export def heaprelease(newheap)#1
    *heapptr = newheap
    return @newheap - *heapptr
end
#ifdef PLAS128
// TODO: I've rewritten this - review it when fresh and test the various corner
// cases (I've only run a few sample programs under it so far)
def allocxheap(size)#1
    word xheapcopy, adjust, bankend, bankfree

    if isugt(size, xheap_bank_size - xheap_bank_start)
	return 0
    fin

    xheapcopy = xheap
    adjust = (4 - ^rambankcount) * xheap_bank_size
    repeat
        bankend = (xheapcopy & $C000) + xheap_bank_size
        bankfree = bankend - xheapcopy
        if size <= bankfree
            if size == bankfree
                size = size + xheap_bank_start
            fin
            xheap = xheapcopy + size
            return xheapcopy
        fin
        xheapcopy = bankend | xheap_bank_start
    until bankend + adjust == 0
    return 0
end
#endif

//
// Acorn MOS API
//

def call_oscli_internal(str, str_cr)#0
    stocr(str, str_cr)
    call(oscli, 0, str_cr, str_cr >> 8, 0)
end

// call_oscli(str)
export def call_oscli(str)#0
    callalloca(str, @call_oscli_internal, ^str + 1)#0
end

#ifndef STANDALONE
//
// Symbol table routines.
//
// The symbol table is a "chunked array"; the first chunk is at symtbl and
// each chunk consists of a number of entries, each of which consists of:
// - symbol name (as DCI string)
// - symbol address (2 bytes)
//
// If the symbol name's first byte is 0, that marks the end of the symbol
// table.
//
// If the symbol name's first byte is 1, that marks the end of the current
// chunk but not the symbol table; it is followed by two bytes which are
// the address of the next chunk.
//
// The first chunk is a different size than later chunks but this is only
// relevant to addsym(); it makes no difference to lookuptbl().
//
// TODO: lookupsym has only one caller, inline it??
def lookupsym(sym)#1
    return lookuptbl(sym, @symtbl)
end
def addsym(sym, addr)#0
    byte str[maxsymlen]
    word entrysz
    word SFTODO // TODO: DELETE
    const addrsz = 2
    const nextchunkptrsz = 3 // end of chunk marker followed by two byte pointer
    
    // We must always have room for the symbol name, two bytes for the
    // address associated with that name and another three bytes for the
    // 'next chunk' pointer. (Initially we only need one byte for the 'end
    // of table' marker, but sooner or later another chunk will be added
    // so we need to allocate three bytes. Those extra two bytes are not
    // *touched* yet, which is important for the assumptions we make about
    // symbol table growth in modload().)
    entrysz = addrsz + nextchunkptrsz + dcitos(sym, @str)
    if 0 // TODO: DELETE
	    prword(addr); putc(' ')
	    SFTODO = sym
	    while ^SFTODO & $80
		putc(^SFTODO & $7f)
		SFTODO++
	    loop
	    putc(^SFTODO)
	    putln()
    fin
    //puts("SFTODOX0 "); prword(lastsym); putc(' '); prword(symtblchunk); putc(' '); prword(symtbl_chunk_size); putln()
    if (symtblchunk <> lowsymtblchunk) or (lastsym - lowsymtblchunk + entrysz > lowsymtblchunksz)
    	symtblchunk = xheapalloc(entrysz)
        //puts("SFTODOX1 "); prword(newsymtblchunk); putln()
	if lastsym + nextchunkptrsz == symtblchunk
            //puts("SFTODOX2\n")
	    // This allocation is contiguous with the previous chunk; we
            // therefore don't need a chunk end marker and a symbol table
            // pointer. This is important when we're called in modload(), as
	    // otherwise the assumption about the growth of the symbol table
	    // per addsym() call wouldn't be true. Because this is the common
	    // case, we can get away with allocating only the exact number of
	    // bytes required every time without this wasting space by causing
            // us to have one symbol table chunk per symbol.
	    symtblchunk = lastsym
            heaprelease(symtblchunk + entrysz)
	else
            //puts("SFTODOX3\n")
            lastsym->0 = 1 // end of chunk but not end of table
	    lastsym=>1 = symtblchunk // next chunk
	    lastsym = symtblchunk
	fin
    fin
    // We don't have a 'copy DCI string' function, but since we copied the DCI
    // string into str[] above using dcitos(), we can get the same effect by
    // copying that using stodci() here.
    lastsym = lastsym + stodci(@str, lastsym)
    lastsym=>0 = addr
    lastsym    = lastsym + 2
    ^lastsym   = 0 // end of table
end
//
// Module routines.
//
def lookupmod(mod)#1
    byte dci[maxsymlen]
    return lookuptbl(modtosym(mod, @dci), @symtbl)
end
export def modaddr(str)#1
    byte mod[maxsymlen]
    stodci(str, @mod)
    return lookupmod(@mod)
end
#endif
#ifndef STANDALONE
// TODO: If this has only one caller we might be as well to inline it - but
// maybe that's over-optimisation.
def addmod(mod, addr)#0
    byte dci[maxsymlen]
    addsym(modtosym(mod, @dci), addr)
end
def lookupextern(esd, index)#1
    word sym, addr
    byte str[maxnamelen]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if esd->0 & $10 and esd->1 == index
            addr = lookupsym(sym)
	    if !addr
                perr = $81
	        putc('?')
		puts(@str)
		putln
	    fin
            return addr
        fin
        esd = esd + 3
    loop
    return 0
end
def adddef(addr, deflast)#1
    word defentry
    defentry = *deflast
    *deflast = defentry + 5
    defentry->0 = $20
    defentry=>1 = interp
    defentry=>3 = addr
    defentry->5 = 0 // null out next entry
    return defentry
end
def lookupdef(addr, deftbl)#1
    while deftbl->0 == $20
        if deftbl=>3 == addr
            return deftbl
        fin
        deftbl = deftbl + 5
    loop
    return 0
end
def modname_default(modcr)#0
    // Default implementation does nothing
end
// Load the module whose name is 'moddci' (a DCI string) from the file 'modcr'
// (a CR-terminated string); modcr points to at least maxpathlen bytes of space to
// allow modname() to generate a long filename in place if it wants to.
def modloadcr_internal(moddci, modcr)#1
    word rdlen, modsize, bytecode, defofst, defcnt, init, fixup
    word addr
#ifdef PLAS128
    word defaddr
#endif
    word modaddr, modfix, modend
    word deftbl, deflast
    word moddep, rld, esd, sym
    byte str[maxsymlen]
    const header_size = 128
    byte header[header_size]
    byte handle
    byte block[osfile_block_size] // osgbpb_block_size is smaller
    byte file_length[4]

    perr = 0

    // We use OSGBPB to read the first header_size bytes of the module, but we
    // use OSFILE to load the entire module later; tests on Acorn DFS 2.24 on
    // BeebEm suggest OSFILE can load 6.25K in 1.74s compared with 4.47s for
    // OSGBPB. So it's well worth the "waste" of reading the header twice.

    //
    // Perform any transformations on the filename we are going to load from.
    //
    modname(modcr)#0

    //
    // Read the RELocatable module header (first header_size bytes); we also
    // get the file length while we have the file open.
    //
    handle = call(osfind, osfind_input, modcr, modcr >> 8, 0).0
    if handle == 0
        oserror_not_found()
    fin
    modload_handle = handle
    block.0 = handle
    block:1 = @header
    block:3 = high_order_address()
    block:5 = header_size
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    rdlen = header_size - block:5
    call(osargs, osargs_read_ext, scratch, handle, 0)
    file_length:0 = scratch:0; file_length:2 = scratch:2
    modload_handle = 0; call(osfind, osfind_close, 0, handle, 0)

    // TODO: Once finished reworking this, should test with a file which doesn't
    // have $DA7F special stuff, if I can find or create one. (Just hack the
    // $DA7F in a hex editor to change it to $0000 or something.)
    if rdlen <= 16 or header:2 <> $DA7F // DAVE+1 = magic number :-)
        perr = 69
        return -perr
    fin

    modsize = header:0
    moddep  = @header.1
    defofst = modsize
    init    = 0
    //
    // This is an EXTended RELocatable (data+bytecode) module.
    //
    // systemflags = header:4 | systemflags
    defofst  = header:6
    defcnt   = header:8
    init     = header:10
    moddep   = @header.12
    //
    // Load module dependencies.
    //
    while ^moddep
        if !lookupmod(moddep)
            if modload(moddep) < 0
                return -perr
            fin
        fin
        moddep = moddep + dcitos(moddep, @str)
        // Just to be paranoid, let's check for the case where a module has
        // loads of dependencies and they overflow the header. This won't
        // catch everything, as it doesn't check the call to dcitocr()
        // inside the above modload() hasn't overflowed, but it should be
        // fairly reliable in practice.
        if (moddep - @header) >= rdlen
            oserror(0, "Header too long") // TODO: shorter error? very rare... "Bad header"? "Bad module"? Perhaps just return 69 as above? Non-0 error number??
        fin
    loop
    //
    // Init def table.
    //
    deftbl   = xheapalloc(defcnt * 5 + 1)
    deflast  = deftbl
    ^deflast = 0
    //
    // Add module to symbol table. This may grow the symbol table, so we
    // do it before we allocate space on the heap for the module. The
    // address of the module is not used (although it's important it's
    // not zero, otherwise lookupmod() will indicate the module isn't
    // loaded when it is) and due to the symbol table changes we don't
    // have modaddr available here (unlike the Apple code), so we just
    // use a non-zero constant.
    //
    addmod(moddci, $0001)
    //
    // Check there's room for the entire file onto the heap now any
    // dependencies have been loaded.
    //
    addr = 0
    if file_length:2 <> 0 // if file is >=64K
        heapfull()
    fin
    rdlen = file_length:0
    addr = xheapalloc(rdlen)
    //
    // Load the file
    //
    block:0 = modcr
    block:2 = addr
    block:4 = high_order_address()
    block:6 = 0 // ignore file's load address, use our own
    // We check specifically for file found; a directory is no good to us. In
    // reality we don't expect any problems as we already opened the file using
    // OSFILE to read the header.
    if call(osfile, osfile_load_file, @block, @block >> 8, 0).0 <> osfile_file_found
        oserror_not_found()
    fin
    //
    // Release the claim we just made; we really did it only to see if it
    // would fail. The code immediately following will shift the loaded
    // module down to avoid wasting space on the header and claim the
    // required amount of space for the module's data and code.
    //
    heaprelease(addr)
    //
    // Alloc heap space for relocated module (data + bytecode).
    //
    moddep  = moddep  + 1 - @header + *heapptr
    modfix  = moddep  - (*heapptr + 2) // Adjust to skip header
    modsize = modsize - modfix
    rdlen   = rdlen   - modfix - 2
    modaddr = xheapalloc(modsize) // can't fail anyway
    memcpy(modaddr, moddep, rdlen)
    //
    // Apply all fixups and symbol import/export.
    //
    modfix   = modaddr - modfix
    bytecode = defofst + modfix - MODADDR
    modend   = modaddr + modsize
    rld      = modend  // Re-Locatable Directory
    esd      = rld     // Extern+Entry Symbol Directory
    while ^esd         // Scan to start of ESD
        esd = esd + 4
    loop
    esd = esd + 1
#ifdef PLAS128
    //
    // Locate bytecode defs in appropriate bank.
    //
    defaddr = allocxheap(rld - bytecode)
    // TODO: If there's only one caller of allocxheap(), might as well fold
    // the following test into allocxheap() itself.
    if defaddr == 0
        heapfull()
    fin
    modend  = bytecode
#endif
    //
    // Free up the end-of-module in main memory. This is premature
    // as we are going to access that data, but we may allocate from the
    // heap to expand the symbol table, so we must do this first. This is
    // "risky", because any more heap allocations could allocate memory
    // we will try to read. We get away with it because only addsym() is
    // going to touch heap-allocated memory. Any one addsym() call can only touch
    // len(symbol_name) + 2 (symbol address) + 1 (end-of-table marker) new bytes, and each ESD entry
    // is len(symbol_name) + 3 bytes, so we're always OK even if there
    // are no RLD entries. TODO: Double check this reasoning!
    //
    heaprelease(modend)    
    //puts("SFTODOHR "); prword(modend); putln();
    //
    // Run through the Re-Location Dictionary.
    //
    while ^rld
        if ^rld == $02
            //
            // This is a bytcode def entry - add it to the def directory.
            //
#ifdef PLAS128
            adddef(rld=>1 - defofst + defaddr, @deflast)
#else
            adddef(rld=>1 - defofst + bytecode, @deflast)
#endif
        else
            addr = rld=>1 + modfix
            if isuge(addr, modaddr) // Skip fixups to header
                if ^rld & $80 // WORD sized fixup.
                    fixup = *addr
                else	  // BYTE sized fixup.
                    fixup = ^addr
                fin
                if ^rld & $10 // EXTERN reference.
                    fixup = fixup + lookupextern(esd, rld->3)
                else	  // INTERN fixup.
                    fixup = fixup + modfix - MODADDR
                    if isuge(fixup, bytecode)
                        //
                        // Bytecode address - replace with call def directory.
                        //
#ifdef PLAS128
                        fixup = lookupdef(fixup - bytecode + defaddr, deftbl)
#else
                        fixup = lookupdef(fixup - bytecode + bytecode, deftbl)
#endif
                    fin
                fin
                if ^rld & $80 // WORD sized fixup.
                    *addr = fixup
                else	  // BYTE sized fixup.
                    ^addr = fixup
                fin
            fin
        fin
        rld = rld + 4
    loop
#ifdef PLAS128
    //
    // Move bytecode to AUX bank.
    //
    memxcpy(defaddr, bytecode, modsize - (bytecode - modaddr))
#endif
    //
    // Run through the External/Entry Symbol Directory.
    //
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if ^esd & $08
            //
            // EXPORT symbol - add it to the global symbol table.
            //
            addr = esd=>1 + modfix - MODADDR
            if isuge(addr, bytecode)
                //
                // Use the def directory address for bytecode.
                //
#ifdef PLAS128
                addr = lookupdef(addr - bytecode + defaddr, deftbl)
#else
                addr = lookupdef(addr - bytecode + bytecode, deftbl)
#endif
            fin
            //puts("SFTODO1 "); prword(lastsym); putc(' '); prword(esd); putln()
            addsym(sym, addr)
            //puts("SFTODO2 "); prword(lastsym); putc(' '); prword(esd); putln()
            // TODO: The following test could be removed eventually.
            // Assert that the last byte written in the symbol table
            // (lastsym) hasn't trampled over the next ESD entry
            // (at esd + 3).
            if isuge(lastsym, esd + 3)
                oserror(0, "Symbol table clash") // TODO: non-0 error number if (probably won't) lives
            fin
        fin
        esd = esd + 3
    loop
    if perr
        return -perr
    fin
    //
    // Call init routine if it exists.
    //
    fixup = 0
    if init
#ifdef PLAS128
	fixup = adddef(init - defofst + defaddr, @deflast)()
#else
	fixup = adddef(init - defofst + bytecode, @deflast)()
#endif
	if fixup < modinitkeep
	    //
	    // Free init routine unless initkeep. Because we grow our symbol
	    // table dynamically, we aren't as flexible as the Apple code here.
	    // On PLAS128 we're fine, because the symbol table lives in
	    // main RAM and the bytecode lives in the 'AUX' RAM. On PLAS32
	    // we may have allocated space for a symbol table chunk on top
	    // of the module's RLD/ESD, and that comes *after* the module's
	    // init. However, even on PLAS32 we can free the init code if we
	    // haven't yet exhausted the low symbol table chunk (and therefore
	    // haven't dynamically allocated a new symbol table chunk).
	    //
#ifdef PLAS128
            xheap = init - defofst + defaddr
#else
            modend = init - defofst + bytecode
            if symtblchunk == lowsymtblchunk
                heaprelease(modend)
            fin
#endif
	    if fixup < 0
		perr = -fixup
	    fin
	else
	    fixup = fixup & ~modinitkeep
	fin
    fin
#if 0 // TODO: Temporary code for forcing multiple 16K banks to be used for PLAS128 testing
    #ifdef PLAS128
        prword(allocxheap(7000)); putln()
    #endif
#endif
    return fixup
end
def modloadpstr_internal(modpstr, modcr)#1
    byte moddci[maxnamelen]
    if ^modpstr == 0 or ^modpstr > maxnamelen
        // TODO: Non-0 error number
        oserror(0, "Bad name") // TODO: Share a common error with some other case?
    fin
    stodci(modpstr, @moddci)
    stocr(modpstr, modcr)
    return modloadcr_internal(@moddci, modcr)
end
// Load the module named by the PLASMA string modpstr; this is taken from a
// command line and may be overlong or invalid in some other way.
// For the moment at least, I am going to work on the model that what you type
// after the + sign at the prompt is a module name - never a path of any
// description. modname() allows custom "module name to filename" conversion
// (including potentially locating the module in a directory other than the
// current one and therefore returning a filename with path components), but the
// user input is just a module name. We can therefore validate modpstr and
// convert it to a DCI module name quite naively.
def modloadpstr(modpstr)#1
    return callalloca(modpstr, @modloadpstr_internal, maxpathlen)#1
end
def modload_internal(moddci, modcr)#1
    dcitocr(moddci, modcr)
    return modloadcr_internal(moddci, modcr)
end
// Load the module named by the DCI string moddci; this is taken from a module
// reference in another module and therefore should be valid (e.g. not
// arbitrarily long).
export def modload(moddci)#1
    return callalloca(moddci, @modload_internal, maxpathlen)#1
end
#endif
#ifndef STANDALONE
//
// Command mode
//
def stripspaces(strptr)#0
    while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)#1
    byte i

    for i = 1 to ^strptr
        if ^(strptr + i) <= ' '
	    ^strptr = i - 1
	    return strptr
	fin
    next
    return strptr
end
def parsecmd(strptr)#1
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
#endif
// User code could choose to install an alternate error handler, but
// it's probably not a good idea; most of the time user code should
// restrict itself to manipulating *errjb.
def error_handler()#0
  // The error number is available to the target at ^errnum; longjmp() naturally
  // passes along a value so it's tempting to pass the error number using it,
  // but it can't send a value of 0 (which is a valid error number) so we don't
  // do that as it just adds to the temptation to write not-quite-correct client
  // code. (Passing 0 saves a few bytes in the VM; this will be turned into 1
  // by longjmp() internally, not that anything is likely to examine the value.)
  longjmp(*errjb, 0)
end
#ifndef STANDALONE
def modexec(modfile)#1
    word saveheap
#ifdef PLAS128
    word savexheap
#endif
    word savesym, savesymtblchunk
    // word saveflags
    word error, action, olderrjb, jb

    saveheap  = *heapptr
#ifdef PLAS128
    savexheap = xheap
#endif
    savesym   = lastsym
    savesymtblchunk = symtblchunk
    // saveflags = systemflags
    modload_handle = 0
    olderrjb = *errjb
    // We allocate a jmp_buf on the heap; it will get trapped and
    // leaked if the module being executed remains resident, but
    // that can't really be helped (and it will be fairly small).
    // We can't allocate a local jmp_buf because the address of
    // it would change if the executed module changes mode and
    // thereby alters HIMEM; mode() will relocate the frame
    // stack but it won't patch up the address at *errjb.
    jb = saveheap
    error = setjmp(jb)
    if error == 0
        xheapalloc(jmpbufsz(jb))
        *errjb = jb
        action = modloadpstr(modfile)
    fin
    *errjb = olderrjb
    if error <> 0 or action < modkeep
        if modload_handle <> 0
            call(osfind, osfind_close, 0, modload_handle, 0)
        fin

        lastsym     = savesym
        symtblchunk = savesymtblchunk
        ^lastsym    = 0
        lastsym=>1  = 0
#ifdef PLAS128
        xheap       = savexheap
#endif
        *heapptr    = saveheap
    fin
    // systemflags = saveflags
    if error <> 0
        error_handler()
    fin
    return -perr
end
#endif
#ifndef STANDALONE
// The parsing in here is deliberately naive to avoid bloating the virtual
// machine too much. It also works in our favour because parsecmd() only pays
// attention to the first character, so this means that "M7" and "MODE 7" both
// work (as, in fact, will things like " M O D E    1 3  5").
def modechange(cmdptr)#0
    word n, i
    byte c
    n = 0
    i = 1
    while i <= ^cmdptr
	c = ^(cmdptr + i)
	if c >= '0' and c <= '9'
	    n = (n * 10) + (c - '0')
	fin
	i++
    loop
    if not mode(n)
        // It doesn't really matter (the error is only shown to the user at the
        // prompt, not seen by any code which might check it) but we use the
        // same error number as BASIC here. (Code changes mode using mode()
        // which returns a boolean success/failure indicator instead of raising
        // an error.)
	oserror(25, "Bad mode")
    fin
end
#endif
//
// Get heap start.
//
*heapptr = *freemem
#ifdef PLAS128
    xheapsize = ^rambankcount * xheap_bank_size
#endif
#ifndef STANDALONE
//
// Init globals; see note at top about why we have to do this.
//
symtblchunk = lowsymtblchunk
lastsym = lowsymtblchunk
modname = @modname_default
//
// Init symbol table.
//
^lastsym = 0 // end of symbol table
#endif
//
// Set up error handler
//
*errjb = heapmark()
if setjmp(*errjb) == 0
  xheapalloc(jmpbufsz(*errjb))
  *errfp = @error_handler
else
#ifndef STANDALONE
  putln
  puts(@errorstr)
  prbyte(^errnum)
  puts(@colonstr)
  puts(errstr)
  putln
#endif
fin
#ifndef STANDALONE
//
// Initialise cmdptr
//
cmdptr = *heapptr
^cmdptr = 0
perr = 0
//
// Print some startup info.
//
if not ^cmdptr
    puts(@verstr)
    prbyte(version.1)
    putc('.')
    prbyte(version.0)
    putln
    // TODO: Temporarily moved this to prompt instead of only displaying it
    // on startup; this makes it more obvious if heap gets leaked.
    //puts(@freestr)
    //prword(heapavail)
#ifdef PLAS128
    //puts(@xfreestr)
    //prword(xheapsize - 1 - xheap) // a bit approximate
#endif
    //putln
fin
//
// Handle commands.
//
while 1
    if ^cmdptr
        when toupper(parsecmd(cmdptr))
	    is 'M'
		modechange(cmdptr)
		break
	    is '+'
	        modexec(striptrail(cmdptr))
		break
	    is '*'
	    	call_oscli(cmdptr)
		break
	    otherwise
	        puts(@huhstr)
        wend
        if perr
            puts(@errorstr)
	    prbyte(perr)
	    perr = 0
        else
            puts(@okstr)
        fin
	putln()
    fin
    puts(@freestr)
    prword(heapavail)
#ifdef PLAS128
    puts(@xfreestr)
    prword(xheapsize - 1 - xheap) // a bit approximate
#endif
    putln
    puts(@prompt)
    cmdptr = gets(':')
loop
#endif
done
