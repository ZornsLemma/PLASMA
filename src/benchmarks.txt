		Master	  Master    BBC B     Master	    PCW BBC B   PCW Master   Master   Master
		BASIC 4	  BASIC 4   BASIC 2   BAS128 1.10   BASIC 2	BASIC 4      PLASMA   PLAS128
			  (shadow)
intmath16									      0.97     0.99
intmath32	 3.12	   3.32	     4.32      5.48	     2.6	 2.5          4.73     4.81
textscrn	21.59	  22.93	    23.15     23.52	    13.7	14.2         16.12    16.42
grafscrn	21.02	  22.90	    22.09     30.08	    21.5	22.0	     17.15    17.75

Timings are "best of many runs" using BeebEm and b-em. For some reason my numbers for BBC BASIC are significantly slower than those reported by PCW themselves, even though I've been fairly generous in my coding of the benchmarks (using resident integer variables in particular). I did the Master BASIC 4+shadow run (i.e. *SHADOW before running the benchmark) in order to have a fairer comparison with BAS128 (which uses shadow mode).


Temporary timings with experimental out-of-memory detection on PLAS128:
intmath16	 0.97
intmath32	 4.77
textscrn	17.31
grafscrn	19.00
(So far this is based on one run in b-em only; I honestly wouldn't expect to see any significant difference here, given none of these make significant use of either CS opcode or function calls - well, intmath32 makes a lot of function calls, but they're all assembly so don't touch parameter stack)



Times for executing "+PLASM", i.e. loading the self-hosted compiler, printing help message and exiting. BeebEm 4.14 for Windows under Wine in Master 128 mode with a (3MHz) second processor. Best of three runs, times reported by bbcmd.pla's TIME code.

Baseline:
283e6529a7f374bb9d7b006ffed1ebda3d94f8a1 1320cs (no drive noises)/1492cs (drive noises)
PLASM is 92% of the file size of files loaded, and as a point of comparison "*LOAD PLASM 1000" takes 418cs (no drive noises)/541cs (drive noises) - given the VM "has" to read the first 128 bytes via OSGBPB and it is loading extra files, that suggests a rough best possible time for this test of around 5 seconds, even if the code to handle loading a module was infinitely fast.

Ported Apple II relocation improvements:
bff360f76d82069c62ae7d4dbc604e5e50015806 702cs (no drive noises)/866cs (drive noises)
Impressive!

Temporarily added a 'return 0' just after the call to OSFILE to load the module - so recursive module loading occurs but no symbol fix up or code execution occurs. "+PLASM" takes 481cs (no drive noises)/647cs (drive noises, but this is a bit variable). So the rest of the load process and running the bit of code to produce the help message takes 220cs and my estimate of 5s for file I/O (no drive noises) is not far off. Anyway, we can roughly infer that it's mostly the symbol fix up stuff that takes the 220cs

"+PLASM HELLO.PLA"
bff360f76d82069c62ae7d4dbc604e5e50015806 1505cs (no drive noises)/1883cs (drive noises)

"+PLASM TEST.PLA"
bff360f76d82069c62ae7d4dbc604e5e50015806 7169s (no drive noises)/7750cs (drive noises)



Using different emulator, PLASMA 2.0 etc so not comparable.
+PLASM TEST.PLA takes 40 seconds (timed with *TIME) with my new read() code
With old OSBGET naive read() code, takes 41 seconds
turning drive noises on, naive takes 49 seconds/50 seconds/51 seconds
new read() code takes 47/50/50 seconds
- this is disappointing
- in some sense it's logical, as the test is just not reading that much (7001 bytes across 3 files)
- I guess a lot of the slowness was perhaps other things which Dave has now optimised
drive noises off
now with new write() code takes 41 seconds/40 seconds/40 seconds



2020/07/13:
b-em, Master 128 OS 3.20, bench2, *DELETE B.PCW to free up catalogue space
Before hacking in "dummy" except() call:
drive noises on - storefileio 23.37s, loadfileio 16.87s (two runs, identical results)
drive noises off - storefileio 20.01s, loadfileio 16.36s (two runs, identical results)
With hacked in "dummy" except() call in fillbuf() only:
drive noises on - storefileio 23.37s, loadfileio 17.13s (two runs, loadfileio 17.12s on second run)
drive noises off - storefileio 20.01s, loadfileio 16.61s (two runs, identical results)
That's actually quite encouraging - a 1.5% slowdown isn't great but it isn't terrible. I think a real implementation would bloat the code a little more but wouldn't have much of a difference on the speed.
