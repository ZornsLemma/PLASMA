//
// PLASMA UNDERSTANDS TWO TYPES OF DATA:
// BYTES (UNSIGNED 8 BIT VALUES), AND
// WORDS (SIGNED 16 BIT VALUES). FROM
// THESE TWO TYPES, EVERYTHING MUST BE
// BUILT. BUT, PLASMA HELPS OUT WITH
// DEFINING DATA, INCLUDING ARRAYS,
// STRUCTURES, STRINGS, AND POINTERS.
// YOU'VE ALREADY SEEN A STRING IN THE
// FIRST EXAMPLE. HERE ARE SOME MORE...
//

BYTE[16] FILENAME // RESERVES 16 BYTES

//
// THE FOLLOWING RESERVES A MINUMUM
// AMOUNT OF SPACE FOR A STRING, PLUS
// IT INITIALIZES IT WITH A VALUE.
//

BYTE[32] PREFIX = "/EXAMPLES"

//
// ARRAY DEFINITIONS WITH NO SIZE DON'T
// RESERVE ANY SPACE, BUT ARE USEFUL FOR
// LABELS. ARRAY DEFINITIONS WITHOUT A
// NAMED VARIABLE JUST INITIALIZE THE
// MEMORY WITH VALUES.
//

BYTE[] ALIAS          // ALIAS HAS SAME
WORD   MYVAR = 1      // ADDRESS AS MYVAR
WORD         = 2, 3, 4// BUT DIFFERENT TYPE

//
// PLASMA ALLOWS FLEXIBLE ARRAY SYNTAX,
// MORE TRADITIONAL ARRAYS LOOK LIKE:
//

WORD MYARRAY[2] // PICK ONE STYLE AND
                // STICK WITH IT

//
// PLASMA ALSO HELPS OUT WITH CONSTANTS
// THAT CAN BE GIVEN A NAME TO MAKE THE
// CODE MORE READABLE.
//

CONST SPEAKER = $C030 // HEX VALUES START WITH '$'

//
// OF COURSE PLASMA HAS LOOPING
// CONSTRUCTS INCLUDING FOR/NEXT,
// REPEAT/UNTIL, WHILE/LOOP.
//
// THE FOR/NEXT IS THE MOST FLEXIBLE,
// TAKING THE EXPANDED FORM OF:
//
// FOR VAR = LO TO HI STEP INC
//
// FOR VAR = HI DOWNTO LO STEP DEC
//

FOR MYVAR = 0 TO 1000
  ^SPEAKER // ACCESS SPEAKER TO MAKE NOISE
NEXT

//
// HERE IS THE SAME THING USING A WHILE
// LOOP AND THE INCREMENT STATEMENT. THE
// TONE IS SLIGHTLY LOWER THAN ABOVE DUE
// TO THE 'WHILE' EXECUTING SLIGHTLY
// SLOWER THAN THE 'FOR' LOOP.
//

MYVAR = 0
WHILE MYVAR <= 1000
  ^SPEAKER
  MYVAR++  // INCREMENT VARIABLE
LOOP

//
// AND TO BE THOROUGH, PLASMA PROGRAMS
// SHOULD END WITH A "DONE" SO THE
// COMPILER KNOWS WHEN TO STOP. ANYTHING
// FOLLOWING "DONE" IS IGNORED.
//

DONE

THIS CAN BE HANDY TO HAVE ARBITRARY TEXT
FOLLOWING THE PROGRAM CODE.
