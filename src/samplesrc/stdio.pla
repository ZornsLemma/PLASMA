// Experimental C-style stdio and test/demonstration code
// TODO: If this works, the stdio functionality should be moved into
// a separate module.

// TODO: ungetc()

// TODO: ftell()/ftell32()

// TODO: rewind()?

// TODO: feof()

// TODO: ferror()?

// TODO: could produce an alternate stdio implementation which is a thin
// wrapper around the OS calls. If do that, compare performance with this
// one and if this is slower then either ditch it or fix the problem!

// TODO: fread()/fwrite() - these should be able to do fast memcpy
// into/out of the buffer where possible

include "inc/acornos.plh"
include "inc/cmdsys.plh"
include "inc/dword.plh"
include "inc/testlib.plh"

const TRUE = -1
const FALSE = 0

const EOF = -1
const SEEK_SET = 0

// This should normally be $0000, but it's handy for testing to be able
// to alter it.
const empty_fill = $2B2B

const scratch = $79

// Note that the buffer size is a word; this means that an application can
// choose to allocate virtually the entire heap as a buffer for a single file
// if it wishes.
struc t_FILE
    byte r_handle
    byte r_eof // TODO: possibly 'flags' not just 'eof'? note that currently this means EOF *for OSGBPB* but not that we've returned all bytes via fgetc()
    byte r_dirty // TODO: possibly 'flags' byte?
    byte r_append // TODO: move into flags byte?
    word r_buffer_used
    word r_buffer_size
    byte r_buffer_file_ptr[4]
    byte r_file_ptr[4]
    byte r_buffer // buffer_size bytes
end

byte stdout_handle = 0 // TODO private
word stdout = @stdout_handle // TODO export this

// TODO TEMP
byte random_state[4]
byte random_multiplier[4]
byte random_increment[4]


// TODO: Move this global into the DWORD module? Note it is initialised below
// TODO: Alternatively, perhaps just provide a dword_inc() and dword_dec()?
byte dword_zero[4]
byte dword_one[4]

// TODO TEMP
def prword(w)
    prbyte(w >> 8)
    prbyte(w)
end

// TODO: COMMENT OUT IN FINAL VSN
def debug_dump_file(prefix, file)
    puts(prefix)
    puts(": "); prbyte(file->r_handle)
    putc('/'); prword(file + r_buffer)
    puts(", f/bptr "); prword(file=>r_file_ptr:2); prword(file=>r_file_ptr:0)
    putc('/'); prword(file=>r_buffer_file_ptr:2); prword(file=>r_buffer_file_ptr:0)
    puts(", bs/u "); prword(file=>r_buffer_size)
    putc('/'); prword(file=>r_buffer_used)
    puts(", f: ")
    if file->r_eof
	puts("EOF ")
    fin
    if file->r_dirty
	puts("dirty ")
    fin
    putln()
end

// TODO: COMMENT OUT IN FINAL VSN
def debug_dump_osgbpb(a, block)
    puts("OSGBPB "); prbyte(a)
    puts(": "); prbyte(block->0)
    puts(", addr "); prword(block=>3); prword(block=>1)
    puts(", size "); prword(block=>7); prword(block=>5)
    puts(", fptr "); prword(block=>11); prword(block=>9)
    putln()
end

// TODO: PUT THIS IN DWORD LIBRARY?
// void dword_adduword(dword *result, const dword *lhs, word rhs)
def dword_adduword(result, lhs, rhs)
    byte rhs_dword[4]
    dword_fromuword(@rhs_dword, rhs)
    return dword_add(result, lhs, @rhs_dword)
end

// TODO: MAKE THIS A STD LIBRARY FUNCTION? IF DO SO THINK ABOUT THE NAME, SHOULD IT BE UMIN??
def minu(lhs, rhs)
    if isult(lhs, rhs)
	return lhs
    else
	return rhs
    fin
end

// TODO: INTERNAL, DON'T EXPORT
// void get_length(dword *length, int handle)
def get_length(length, handle)
    // TODO: AUG says OSARGS control block is always in I/O processor memory!?
    call(2, scratch, handle, 0, $FFDA)
    memcpy(length, scratch, 4)
end

// TODO BENCHMARK IT, BUT MAY WANT TO WRITE THE 'IN MEMORY' BRANCH OF FGETC AND
// FPUTC IN ASSEMBLER - BUT DON'T GO NUTS, BECAUSE ASSEMBLER ALWAYS BURNS
// MAIN RAM, WHEREAS BYTECODE CAN BE IN SWR ON PLAS128

// TODO: RETURN TYPE IS POSSIBLY NOT BOOL, IT'S POSSIBLY 'file or 0'
// void fopen_prealloc(FILE *file, const char *filename, const char *mode)
// Expectes 'file' to point to a large enough block of memory with the
// r_buffer_size element filled in (to represent the size of the buffer,
// not the size of the whole memory block)
def fopen_prealloc(file, filename, mode)
    byte base_mode, update, i, c, osfind_mode, handle
    // TODO: error handling
    base_mode = 'r'
    update = FALSE
    for i = 1 to ^mode
	c = (mode).[i]
	if c == 'r' or c == 'w' or c == 'a'
	    base_mode = c
	elsif c == '+'
	    update = TRUE
	fin
	// We ignore anything else, including 'b' - PLASMA's '\n' is
	// ASCII CR (13) which is exactly what we want so text and
	// binary modes are equivalent.
    next
    file->r_append = (base_mode == 'a')
    when base_mode
	is 'r'
	    if update
		osfind_mode = osfind_update
	    else
		osfind_mode = osfind_input
	    fin
	    break
	is 'w'
	    osfind_mode = osfind_output
	    break
	is 'a'
	    osfind_mode = osfind_update
	    break
    wend
    handle = osfind_open(osfind_mode, filename)
    if base_mode == 'w' and update and handle <> 0
	// "w+" must truncate the file if it exists; we opened it in write
	// mode to get this behaviour, we now need to re-open it in update
	// mode.
	osfind_close(handle)
	handle = osfind_open(osfind_update, filename)
    elsif file->r_append and handle == 0
	// "a" must create the file if it doesn't exist but OSFIND's update
	// mode doesn't ever create the file, so we do it explicitly if the
	// open failed.
	handle = osfind_open(osfind_output, filename)
	if handle == 0
	    return 0
	fin
	osfind_close(handle)
	handle = osfind_open(osfind_update, filename)
    fin
    if handle == 0
	return 0
    fin

    file->r_handle = handle
    file->r_eof = FALSE
    file->r_dirty = FALSE
    file=>r_buffer_used = 0
    dword_fromuword(file + r_file_ptr, 0)
    dword_fromuword(file + r_buffer_file_ptr, 0)
    debug_dump_file("fopen->", file)
    return file
end

// TODO: PROTOTYPE
def fopen_heap(buffer_size, filename, mode)
    word file
    file = heapalloc(t_FILE - 1 + buffer_size)
    file=>r_buffer_size = buffer_size
    return fopen_prealloc(file, filename, mode)
end

// word fflush(FILE *file) - returns 0 on success, EOF on error
// TODO: CURRENTLY THIS NEVER RETURNS EOF
def fflush(file)
    byte block[13], length[4], size_delta[4]
    const zero_size = 128
    byte zero[zero_size]
    //debug_dump_file("fflush-<", file)
    if file->r_dirty
	// If the first byte in the buffer comes after the current end of the file,
	// specifying the appropriate file pointer in the OSGBPB 1 call would cause
	// the filing system to extend the file with undefined contents. So we have
	// to emit zeros to grow the file to the appropriate length first.
	get_length(@length, file->r_handle)
	if dword_isugt(file + r_buffer_file_ptr, @length)
	    memset(@zero, empty_fill, zero_size)
	    while dword_isugt(file + r_buffer_file_ptr, @length)
		dword_sub(@size_delta, file + r_buffer_file_ptr, @length)
		puts("length "); prword(length:2); prword(length:0)
		putln()
		block.0 = file->r_handle
		block:1 = @zero
		block:3 = 0 // TODO
		if not dword_isuword(@size_delta)
		    block:5 = zero_size
		else
		    block:5 = minu(zero_size, dword_touword(@size_delta))
		fin
		block:7 = 0
		block:9 = length:0
		block:11 = length:2
		dword_adduword(@length, @length, block:5)
		debug_dump_osgbpb(1, @block)
		call(1, @block, @block >> 8, 0, $FFD1) // TODO: BRK on error or can it return something?
	    loop
	fin

	// Now we can actually write the buffer out
	block.0 = file->r_handle
	block:1 = file + r_buffer
	block:3 = 0 // TODO
	block:5 = file=>r_buffer_used
	block:7 = 0
	block:9 = file=>r_buffer_file_ptr:0
	block:11 = file=>r_buffer_file_ptr:2
	debug_dump_osgbpb(1, @block)
	call(1, @block, @block >> 8, 0, $FFD1) // TODO: BRK on error or can it return something?

	file->r_dirty = FALSE
	debug_dump_file("fflush->", file)
    fin
    return 0
end

// word fgetc(FILE *file)
// TODO ERROR HANDLING (NOT JUST EOF)
// TODO: magic constants everywhere
def fgetc(file)
    byte c
    byte block[13]
    byte buffer_used_ptr[4]
    byte length[4]
    //debug_dump_file("fgetc-<", file)
    dword_adduword(@buffer_used_ptr, file + r_buffer_file_ptr, file=>r_buffer_used)
    if dword_isuge(file + r_file_ptr, file + r_buffer_file_ptr) and dword_isult(file + r_file_ptr, @buffer_used_ptr))
	c = ^(file + r_buffer + file=>r_file_ptr:0 - file=>r_buffer_file_ptr:0)
	dword_add(file + r_file_ptr, file + r_file_ptr, @dword_one)
	debug_dump_file("fgetc->", file)
	return c
    else
	if file->r_eof
	    return EOF
	fin

	// The relevant byte isn't in the buffer, so either:
	// - r_file_ptr is past EOF, in which case we enter EOF state, or
	// - we flush the current buffer contents and read a buffer full of
	//   data starting at r_file_ptr

	// TODO: create a dword_assign rather than using these :0 and :2 pairs in various places?
	// TODONOW: THIS *READ* WILL STILL GROW THE FILE IF THE FILE POINTER IS
	// PAST THE END - AND WE AREN'T EXPECTING THAT (NOR, I THINK, DO WE WANT IT
	// TO HAPPEN AT ALL). FOR NOW LET'S USE THIS HACK, WE MAYBE WANT/NEED TO TRACK
	// THE LENGTH OF THE FILE AS A MEMBER OF THE FILE OBJECT
	block:5 = file=>r_buffer_size
	get_length(@length, file->r_handle)
	if not dword_isuge(file + r_file_ptr, @length)
	    if fflush(file) == EOF
		return EOF
	    fin

	    block.0 = file->r_handle
	    block:1 = file + r_buffer
	    block:3 = 0 // TODO: what to do with high order to get correct behaviour in all cases?
	    block:7 = 0
	    block:9 = file=>r_file_ptr:0
	    block:11 = file=>r_file_ptr:2
	    // We ignore the carry returned by OSGBPB; BeebWiki says it's not
	    // returned consistently, so we just use the updated number of bytes.
	    debug_dump_osgbpb(3, @block)
	    call(3, @block, @block >> 8, 0, $FFD1)

	    file=>r_buffer_file_ptr:0 = file=>r_file_ptr:0
	    file=>r_buffer_file_ptr:2 = file=>r_file_ptr:2
	    file=>r_buffer_used = file=>r_buffer_size - block:5
	fin
	if block:5 <> 0
	    file->r_eof = TRUE
	fin
	debug_dump_file("fgetc-!", file)
	return fgetc(file)
    fin
end

// word fputc(char c, FILE *file) - returns c on success, EOF on error
def fputc(c, file)
    byte buffer_end_ptr[4]
    word index
    // TODO: Perhaps just use 'file == 0' as the stdout indicator? Would save
    // a bit of setup, and the reality is the current approach is still likely
    // to fail if someone incorrectly passes stdout to another function as
    // stdout is not a full FILE structure with all the fields
    if file->r_handle == 0
	putc(c)
	if c == '\n' // TODO: use OSASCI, ideally via assembly
	    putc('\r')
	fin
	return c
    fin
    //debug_dump_file("fputc-<", file)
    if file->r_append
	get_length(file + r_file_ptr, file->r_handle)
	// TODO: THIS IS SEEK-LIKE, FACTOR OUT COMMON CODE?
	// TODO: DOES THIS NEED TO DO ANYTHING WITH EOF FLAG? - I THINK IT CAN LEAVE IT ALONE, WHICH IS NOT SEEK LIKE, SO BE CAREFUL IF FACTORING OUT
    fin
    dword_adduword(@buffer_end_ptr, file + r_buffer_file_ptr, file=>r_buffer_size)
    if dword_isuge(file + r_file_ptr, file + r_buffer_file_ptr) and dword_isult(file + r_file_ptr, @buffer_end_ptr)
	index = file=>r_file_ptr:0 - file=>r_buffer_file_ptr:0
	^(file + r_buffer + index) = c
	dword_add(file + r_file_ptr, file + r_file_ptr, @dword_one)
	index++
	file->r_dirty = TRUE

	// If a seek means we've grown the buffer (and the file), we need to
	// clear the gap created.
	if isugt(index, file=>r_buffer_used)
	    memset(file + r_buffer + file=>r_buffer_used, empty_fill, index - file=>r_buffer_used - 1)
	    file=>r_buffer_used = index
	fin

	debug_dump_file("fputc->", file)
	return c
    else
	if fflush(file) == EOF
	    return EOF
	fin
	file=>r_buffer_file_ptr:0 = file=>r_file_ptr:0
	file=>r_buffer_file_ptr:2 = file=>r_file_ptr:2
	file=>r_buffer_used = 0 // TODONOW: THIS IS WRONG, NOW THE BUFFER SHOULD ALWAYS BE FILLED EXCEPT AT EOF
	debug_dump_file("fputc-!", file)
	return fputc(c, file)
    fin
end

// word fseek32(FILE *file, const dword *offset, word origin) - returns 0 on success, non-0 on error
def fseek32(file, offset, origin)
    *(file + r_file_ptr) = *offset
    *(file + r_file_ptr + 2) = *(offset + 2)
    file->r_eof = FALSE
    debug_dump_file("fseek->", file)
    return 0 // TODO: CURRENTLY CAN'T RETURN ANYTHING ELSE
end

// word fseek(FILE *file, word offset, word origin) - returns 0 on success, non-0 on error
// TODO: CURRENTLY NO SUPPORT FOR origin - ASSUMED TO BE SEEK_SET - REMEMBER THAT WITH SEEK_CUR AND SEEK_END THE OFFSET CAN BE NEGATIVE, SO WE NEED TO TREAT IT AS SIGNED IN BOTH 16 AND 32 BIT VERSIONS
def fseek(file, offset, origin)
    byte offset32[4]
    // TODO: This should be a no-op if file opened as "a" (but not "a+")
    dword_fromuword(@offset32, offset)
    return fseek32(file, @offset32, origin)
end

// word fclose(FILE *file) - returns 0 on success, EOF on error
// TODO: can this return errors or will we always get an OS error?
def fclose(file)
    word result
    debug_dump_file("fclose-<", file)
    if fflush(file) == EOF
	return EOF
    fin
    osfind_close(file->r_handle)
    return 0
end

def main()
    word file
    word i
    word count
    puts("foo\nbar\nbaz\n")
    fputc('x', stdout)
    fputc('y', stdout)
    fputc('\n', stdout)
    file = fopen_heap(256, "TEST", "w+b")
    if file == 0
	puts("open failed")
	return
    fin
    puts("DOINGX\n")
    i = fputc('X', file)
    puts("DONEX\n")
    i = fputc('Y', file)
    puts("DOINGZ\n")
    i = fputc('Z', file)
    puts("DONEZ\n")
    i = fseek(file, 2, SEEK_SET)
    if i <> 0
	puts("fseek failed")
	return
    fin
    puts("about to fget Z\n")
    i = fgetc(file)
    if i <> 'Z'
	puts("fgetc failed")
	return
    fin
    puts("fgot Z\n")
    i = fseek(file, 0, SEEK_SET)
    if i <> 0
	puts("fseek failed")
	return
    fin
    i = fgetc(file)
    if i <> 'X'
	puts("fgetc2 failed")
	return
    fin
    i = fseek(file, $82, SEEK_SET)
    if i <> 0
	puts("fseek2 failed")
	return
    fin
    puts("about to write Q\n")
    i = fputc('Q', file)
    i = fclose(file)
    if i == EOF
	puts("close failed")
	return
    fin
    return



    file = fopen_heap(2, "HELLO", "rb")
    if file == 0
	puts("open failed")
	return
    fin
    count = 0
    repeat
	if count % 8 == 0
	    putln()
	    prword(count)
	    putc(' ')
	fin
	i = fgetc(file)
	if i <> EOF
	    prbyte(i)
	    putc(' ')
	fin
	count++
    until i == EOF
    i = fclose(file)
    if i == EOF
	puts("close failed")
	return
    fin
end

def assert(b, message)
    if not b
	oserror(42, message)
    fin
end

def seedrand(seed)
    dword_fromuword(@random_state, seed)
end

def rand(n)
    byte r[4], SFTODO[100]
    dword_mul(@random_state, @random_state, @random_multiplier)
    dword_add(@random_state, @random_state, @random_increment)
    dword_fromuword(@r, n)
    dword_div(0, @r, @random_state, @r)
    return dword_touword(@r)
end

def random_test(seed)
    const memory_size = 8192
    const buffer_size = 4096
    word saved_heap
    word file
    word i, j
    word memory
    word ptr, max_ptr
    word op
    word c, d
    word subseed
    prword(@random_state)
    puts("SFTODO1\n")
    max_ptr = 0
    puts("SFTODO2\n")
    puts("SFTODO3\n")
    seedrand(seed)
    memory = heapalloc(memory_size)
    memset(memory, empty_fill, memory_size)
    saved_heap = heapmark()
    for i = 1 to 5
	subseed = rand($FFFF)
	seedrand(subseed)
	puts("j "); puti(i); putln()
	if i == 1
	    file = fopen_heap(buffer_size, "T.DATA", "w+b")
	else
	    file = fopen_heap(buffer_size, "T.DATA", "r+b")
	fin
	puts("SFTODO4\n")
	assert(file, "open")
	ptr = 0
	for j = 1 to 1024 // TODO: SHOULD BE RANDOM OR LARGE-ISH FIXED
	    op = rand(10)
	    puts("SFTODO5\n")
	    putc('Q'); prword(i); putc(' '); prbyte(op); putln()
	    puts("XXX"); prbyte(^(memory+$0EB0)); putln()
	    if op == 0
		ptr = rand(memory_size)
		assert(fseek(file, ptr, SEEK_SET) == 0, "seek")
	    elsif op <= 5
		c = rand(256)
		^(memory + ptr) = c
		ptr++
		assert(fputc(c, file) <> EOF, "fputc")

		// Merely seeking to a point doesn't grow the file; only if we
		// try to write at that point does it grow.
		if ptr > max_ptr
		    max_ptr = ptr
		fin
	    else
		putc('x'); prword(ptr);
		if ptr >= max_ptr
		    c = EOF
		else
		    c = ^(memory + ptr)
		    ptr++
		fin
		putc(' '); prword(c)
		d = fgetc(file)
		if c <> d
		    putc(' '); prbyte(c); putc(' '); prbyte(d)
		    putln()
		    assert(FALSE, "fgetc")
		fin
	    fin
	    if ptr >= memory_size
		ptr = 0
		assert(fseek(file, 0, SEEK_SET) == 0, "seek2")
	    fin
	next
	assert(fclose(file) == 0, "close")
	
	seedrand(subseed)
	file = fopen_heap(256, "T.DATA", "rb")
	assert(file, "open verify")
	ptr = 0
	while ptr < max_ptr
	    c = fgetc(file)
	    d = ^(memory + ptr)
	    if c <> d
		putc('V'); prword(ptr); 
		putc(' '); prbyte(c); putc(' '); prbyte(d)
		putln()
		assert(FALSE, "fgetc verify")
	    fin
	    ptr++
	loop
	assert(fgetc(file) == EOF, "fgetc EOF verify")
	assert(fclose(file) == 0, "close verify")

	heaprelease(saved_heap)
    next
end

// TODONOW: EXAMINE OUTPUT OF TEST WITH 8192 SIZE BUFFER AND SEE IF ALL THE OSGBPB CALLS ARE
// "REASONABLE" - PROBABLY ARE, BUT GOOD TO CHECK IN THIS EXTREME CASE WHERE
// BUFFER IS VERY LARGE

puts("SFTODOX1\n")
dword_fromuword(@dword_zero, 0)
dword_fromuword(@dword_one, 1)
puts("SFTODOX2\n")
random_multiplier[0] = $0D; random_multiplier[1] = $66; random_multiplier[2] = $19; random_multiplier[3] = $00
puts("SFTODOX3\n")
random_increment[0] = $5F; random_increment[1] = $F3; random_increment[2] = $6E; random_increment[3] = $3C
puts("SFTODOX4\n")

//main()
random_test(42)
done

// TODO: temp-ish notes 
//
// the full buffer_size bytes don't need to be present in the buffer, but the
// only partially filled state supported if that the buffer contains
// buffer_used bytes of data which are the file contents starting from
// buffer_file_ptr
//
// this means that if you seek forward but still within the area covered by
// [buffer_file_ptr, buffer_ptr_ptr + buffer_size), the read will have to read
// all the intervening data into the buffer as well

// vi: sts=4 sw=4
