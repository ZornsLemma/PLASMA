// Experimental C-style stdio and test/demonstration code
// TODO: If this works, the stdio functionality should be moved into
// a separate module.

// TODO: Support for a "stdout" stream?

// TODO: ungetc()

// TODO: ftell()/ftell32()

// TODO: rewind()?

// TODO: feof()

// TODO: ferror()?

// TODO: fread()/fwrite() - these should be able to do fast memcpy
// into/out of the buffer where possible

include "inc/acornos.plh"
include "inc/cmdsys.plh"
include "inc/testlib.plh"

const TRUE = -1
const FALSE = 0

const EOF = -1
const SEEK_SET = 0

// Note that the buffer size is a word; this means that an application can
// choose to allocate virtually the entire heap as a buffer for a single file
// if it wishes.
struc t_FILE
    byte r_handle
    byte r_eof // TODO: possibly 'flags' not just 'eof'? note that currently this means EOF *for OSGBPB* but not that we've returned all bytes via fgetc()
    word r_buffer_used
    word r_buffer_size
    word r_buffer_dirty_low
    word r_buffer_dirty_high
    word r_buffer_file_ptr // TODO: dword?
    word r_file_ptr // TODO: dword? rename?
    byte r_buffer // buffer_size bytes
end

// TODO TEMP
def prword(w)
    prbyte(w >> 8)
    prbyte(w)
end

// TODO BENCHMARK IT, BUT MAY WANT TO WRITE THE 'IN MEMORY' BRANCH OF FGETC AND
// FPUTC IN ASSEMBLER - BUT DON'T GO NUTS, BECAUSE ASSEMBLER ALWAYS BURNS
// MAIN RAM, WHEREAS BYTECODE CAN BE IN SWR ON PLAS128

// TODO: RETURN TYPE IS POSSIBLY NOT BOOL, IT'S POSSIBLY 'file or 0'
// void fopen(FILE *file, const char *filename, const char *mode)
def fopen(file, filename, mode)
    byte osfind_mode
    // TODO: text mode - I guess this is actually quite easy, because we just need to translate '\n' into '\r' on write and opposite on read - we are not having to change one byte to two or vice versa
    // TODO: Can I continue to support fseek()/ftell() in text mode?
    // TODO: error handling
    // TODO: very poor parsing of mode
    // TODO: this ignores the subtleties of w+ vs r+ vs a+
    if ^mode == 2 and ^(mode + 2) == '+'
	osfind_mode = osfind_update
    elsif ^(mode + 1) == 'r'
	osfind_mode = osfind_input
    elsif ^(mode + 1) == 'w'
	osfind_mode = osfind_output
    fin
    file->r_handle = osfind_open(osfind_mode, filename)
    if file->r_handle == 0
	return 0
    fin
    file->r_eof = FALSE
    file=>r_buffer_dirty_low = $FFFF
    file=>r_buffer_dirty_high = $0000
    file=>r_buffer_used = 0
    file=>r_file_ptr = 0
    file=>r_buffer_file_ptr = 0
    return file
end

// word fflush(FILE *file) - returns 0 on success, EOF on error
// TODO: CURRENTLY THIS NEVER RETURNS EOF
def fflush(file)
    byte block[13]
    puts("fflush ")
    if isult(file=>r_buffer_dirty_low, file=>r_buffer_dirty_high)
	puts("dirty")
	block.0 = file->r_handle
	block:1 = file + r_buffer
	block:3 = 0 // TODO
	block:5 = file=>r_buffer_dirty_high - file=>r_buffer_dirty_low
	block:7 = 0
	block:9 = file=>r_buffer_file_ptr + file=>r_buffer_dirty_low
	block:11 = 0 // TODO
	puti(file=>r_buffer_file_ptr)
	puts("writing dirty, low ")
	prword(file=>r_buffer_dirty_low)
	puts(", size ")
	prword(block:5)
	putln()
	call(1, @block, @block >> 8, 0, $FFD1) // TODO: BRK on error or can it return something?
	file=>r_buffer_dirty_low = $FFFF
	file=>r_buffer_dirty_high = $0000
	// TODO: What if anything should this do with r_eof?
    fin
    return 0
end

// word fgetc(FILE *file)
// TODO ERROR HANDLING (NOT JUST EOF)
def fgetc(file)
    word c, osgbpb_flags
    byte block[13]
    // TODO: SHOULD BE USE UNSIGNED COMPARISONS HERE
    if file=>r_file_ptr >= file=>r_buffer_file_ptr and file=>r_file_ptr < (file=>r_buffer_file_ptr + file=>r_buffer_used)
	c = ^(file + r_buffer + file=>r_file_ptr - file=>r_buffer_file_ptr)
	file=>r_file_ptr++
	return c
    else
	if file->r_eof
	    return EOF
	fin
	if fflush(file) == EOF
	    return EOF
	fin
	// TODO: careful if this handles EOF occurring at this point
	// TODO: magic constants!
	block.0 = file->r_handle
	block:1 = file + r_buffer
	block:3 = 0 // TODO: what to do with high order to get correct behaviour in all cases?
	// TODO: We should possibly have a "block read" size which can be smaller than the
	// buffer size - that way if an app has (say) a 20K buffer, it will be able to cache
	// 20K for random access, but it won't be forced to wait while all 20K gets read in
	// order to access a single byte.
	block:5 = file=>r_buffer_size
	block:7 = 0
	block:9 = file=>r_file_ptr
	block:11 = 0 // TODO
	puts("reading from file ptr ")
	prword(file=>r_file_ptr)
	puts(", bytes ")
	prword(block:5)
	// TODO puts("CALLING OSGBPB\n")
	// We ignore the carry returned by OSGBPB; BeebWiki says it's not
	// returned consistently, so we just use the updated number of bytes.
	call(3, @block, @block >> 8, 0, $FFD1)
	file=>r_buffer_file_ptr = file=>r_file_ptr
	file=>r_buffer_used = file=>r_buffer_size - block:5
	if block:5 > 0
	    file->r_eof = TRUE
	fin
	return fgetc(file)
    fin
end

// word fputc(char c, FILE *file) - returns c on success, EOF on error
def fputc(c, file)
    word index
    // TODO: SHOULD BE USE UNSIGNED COMPARISONS HERE
    if file=>r_file_ptr >= file=>r_buffer_file_ptr and file=>r_file_ptr < (file=>r_buffer_file_ptr + file=>r_buffer_size)
	index = file=>r_file_ptr - file=>r_buffer_file_ptr
	^(file + r_buffer + index) = c
	file=>r_file_ptr++
	// TODO: In order to minimise problems if an app has (say) a 20K buffer
	// and modifies the first and last byte, we should probably have a
	// threshold and if writing this one byte would increase the dirty range
	// by more than the threshold, we should flush first.
	if isult(index, file=>r_buffer_dirty_low)
	    file=>r_buffer_dirty_low = index
	fin
	index++ // high watermark is exclusive
	if isugt(index, file=>r_buffer_dirty_high)
	    file=>r_buffer_dirty_high = index
	fin
	if file=>r_file_ptr - file=>r_buffer_file_ptr > file=>r_buffer_used
	    file=>r_buffer_used = file=>r_file_ptr - file=>r_buffer_file_ptr
	    puts("XXX"); puti(file=>r_buffer_used)
	fin
	return c
    else
	if fflush(file) == EOF
	    return EOF
	fin
	file=>r_buffer_file_ptr = file=>r_file_ptr
	file=>r_buffer_used = 0
	return fputc(c, file)
    fin
end

// word fseek(FILE *file, word offset, word origin) - returns 0 on success, non-0 on error
// TODO: CURRENTLY NO SUPPORT FOR origin - ASSUMED TO BE SEEK_SET
// TODO: IDEALLY WE SHOULD HAVE A DWORD VERSION (fseek32) FOR FILES >64K OR SOME MEANS TO SUPPORT THIS ANYWAY
def fseek(file, offset, origin)
    file=>r_file_ptr = offset
    file->r_eof = FALSE
end

// word fclose(FILE *file) - returns 0 on success, EOF on error
// TODO: can this return errors or will we always get an OS error?
def fclose(file)
    word result
    puts("fclose ")
    if fflush(file) == EOF
	return EOF
    fin
    osfind_close(file->r_handle)
    return 0
end

def main()
    byte file[20]
    word i
    word count
    file:r_buffer_size = 2 
    i = fopen(@file, "TEST", "w+b")
    if i == 0
	puts("open failed")
	return
    fin
    i = fputc('X', @file)
    i = fputc('Y', @file)
    puts("\nDOINGZ")
    i = fputc('Z', @file)
    puts("DONEZ\n")
    i = fseek(@file, 2, SEEK_SET)
    if i <> 0
	puts("fseek failed")
	return
    fin
    puts("\nabout to fget Z\n")
    i = fgetc(@file)
    if i <> 'Z'
	puts("fgetc failed")
	return
    fin
    puts("\nfgot Z\n")
    i = fseek(@file, 2, SEEK_SET)
    if i <> 0
	puts("fseek failed")
	return
    fin
    puts("\nabout to write Q\n")
    i = fputc('Q', @file)
    i = fclose(@file)
    if i == EOF
	puts("close failed")
	return
    fin
    return



    i = fopen(@file, "HELLO", "rb")
    if i == 0
	puts("open failed")
	return
    fin
    count = 0
    repeat
	if count % 8 == 0
	    putln()
	    prword(count)
	    putc(' ')
	fin
	i = fgetc(@file)
	if i <> EOF
	    prbyte(i)
	    putc(' ')
	fin
	count++
    until i == EOF
    i = fclose(@file)
    if i == EOF
	puts("close failed")
	return
    fin
end

main()
done

// vi: sts=4 sw=4
