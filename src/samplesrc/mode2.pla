// Demonstration of mode changes - this doesn't show good practice as it
// changes mode with a lot of state on the parameter stack, but it's a
// good test.

include "inc/cmdsys.plh"
include "inc/testlib.plh"
include "inc/acornos.plh"

byte do_mode_change
byte jb[jbsz]

def bar(i)
    word j, k
    k = 0
    j = setjmp(@jb)
    if j <> 0; osrdch(); fin
    puts("setjmp k ")
    if j <> 0; osrdch(); fin
    puti(k)
    puts(" j ")
    if j <> 0; osrdch(); fin
    puti(j)
    if j <> 0; osrdch(); fin
    puts("\n")
    if j <> 0
	if j <> 0; osrdch(); fin
	oscli("save z 100 200")
	return k + j
    fin
    // TODONOW: OK, this isn't working on PLAS128 and I now see why -
    // setjmp saves the CPU stack, mode() rewrites the actual CPU
    // stack and longjmp() restores the CPU stack pre-rewriting.
    // This may frankly argue for the "relative stack" change, given
    // the cost of the extra work on enter/exit is actually negligible.
    // An alternative would be to store HIMEMH in the jmp_buf and
    // use the delta between it and current HIMEMH to perform rewriting
    // of the CPU stack inside longjmp. We could probably use PLASM
    // code not asm and allow reuse of the rewrite logic. However, this
    // is starting to feel brittle, given how practically cheap the
    // relative stack is.
    for j = 99 to 100 // TODO TEMP SHOULD BE FROM 1 TO 100
	k = k + i
	if do_mode_change
	    puts("baz"); osrdch()
	    mode(j)
	fin
	if j == 99
	    puts("k ")
	    puti(k)
	    puts(" about to longjmp\n")
	    osrdch()
	    longjmp(@jb, 42)
	fin
    next
    oserror(0, "Didn't longjmp!")
end

def foo
    word i, j, k
    i = 10
    j = -3
    for k = 1 to 100
	i = i - 199
	if do_mode_change
	    puts("foo"); osrdch()
	    mode(j)
	fin
	j = j * 2
	j = j + bar(i)
    next
    return j
end

def main
    word result1, result2

    mode(7)
    puts("This program changes modes rapidly and\nrepeatedly. This may damage your monitorif run on real hardware.\n\nPress SPACE to start...")
    call(21, 0, 0, 0, $FFF4) // TODO: nicer wrapper, at least named constant?
    repeat until osrdch() == ' '

    mode(7)
    do_mode_change = 0
    // TODO TEMP COMMENTED OUT result1 = foo()
    do_mode_change = 1
    result2 = foo()
    mode(7)
    puts("Final result is ")
    puti(result2)
    puts(", should be ")
    puti(result1) //-23146 TODO
    puts(".\n")
end

main()
done

// vi: sw=4 sts=4
