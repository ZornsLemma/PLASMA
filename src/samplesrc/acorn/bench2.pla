// Benchmarks, including some based on the Personal Computer World
// benchmarks (from December 1986 issue). These are split from bench1.pla as
// those need to be small enough to allow mode 3 for textscrn even on a
// machine with 32K RAM with no sideways or shadow RAM.

// TODO: this uses puti() for output but that treats its argument as
// signed, which isn't strictly correct and gives invalid results if
// the times are very high.

// TODO: Factor out common code from bench1.pla and bench2.pla

include "inc/acornos.plh"
include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/int32.plh"
include "inc/fileio.plh"
include "inc/acornc.plh"

byte intmath16str[] = "intmath16"
byte intmath32str[] = "intmath32"
byte storefileiostr[] = "storefileio"
byte storebputstr[] = "storebput"
byte storegbpbstr[] = "storegbpb"
byte fncallstr[] = "fncall"

// Benchmark start/finish times
byte start[5]
byte finish[5]

struc t_result
    word r_next
    word r_name
    word r_time
end

word results_head = 0
word results_tail_ptr = @results_head

def time_delta(start, finish)#1
    // We can get away with ignoring the fifth byte; the result will be
    // correct unless there's a difference of more than one in the fifth
    // byte, and that's just not going to happen.
    byte delta_i32[t_i32]
    load32(finish)
    sub32(start)
    store32(@delta_i32)
    if delta_i32:2 == 0
        return delta_i32:0
    fin
    return 0
end

def log_time(name)#0
    word result

    result = heapalloc(t_result)
    result=>r_next = 0
    result=>r_name = name
    result=>r_time = time_delta(@start, @finish)
    *results_tail_ptr = result
    results_tail_ptr = result+r_next
end

def puti_pad_space(i)#0
    if i < 100
        putc(' ')
    fin
    if i < 10
        putc(' ')
    fin
    puti(i)
end

def puti_pad_0(i)#0
    if i < 10
        putc('0')
    fin
    puti(i)
end

def show_times()#0
    word p, i
    p = results_head
    while p <> 0
	puts(p=>r_name)
	for i = 1 to 12 - ^(p=>r_name)
	    putc(' ')
	next
	puti_pad_space(p=>r_time / 100)
	putc('.')
	puti_pad_0(p=>r_time % 100)
	putc('s')
	putln()
	p = p=>r_next
    loop
end

def time(t)#0
    call(osword, osword_read_time, t, t >> 8, 0)
end

def high_order_address()#1
    return call(osbyte, osbyte_read_high_order_address, 0, 0, 0):1
end

// Actual benchmarks

def intmath16()#0
    word x, y, i
    time(@start)
    x = 0
    y = 9
    puts("Start\n")
    for i = 1 to 1000
	x = x + (y * y - y) / y
    next
    puts("Finish ")
    puti(x) // should be 8000
    putln()
    time(@finish)
    log_time(@intmath16str)
    if x <> 8000
	oserror(0, "intmath16 failed")
    fin
end

def intmath32()#0
    byte x[4], y[4], a[4]
    word i
    time(@start)
    zero32(); store32(@x)
    loadi16(9); store32(@y)
    puts("Start\n")
    for i = 1 to 1000
	// x = x + (y * y - y) / y
        load32(@y)
        mul32(@y)
        sub32(@y)
        div32(@y)
        add32(@x)
        store32(@x)
    next
    puts("Finish ")
    puti32(@x) // should be 8000
    putln()
    time(@finish)
    log_time(@intmath32str)
    load32(@x)
    if not iseqi16(8000)
	oserror(0, "intmath32 failed")
    fin
end

// All the store*() benchmarks write the string as raw text whereas the
// specification says to use "record handling". I think I'd write the benchmark
// in this way in C on any platform, but what we're doing here is not a fair
// comparison with the BASIC version of the benchmark in pcw.bas.
//
// They should also delete the file after creating it, but that's inconvenient
// for verifying the file was written correctly and for using the file with load
// benchmarks, so we don't do that, and we do a delete before starting each
// store benchmark instead.

def storefileio()#0
    word i, file, str
    if fileio:destroy("X.TEST") <> 0
        oserror(0, "Can't delete test file")
    fin
    time(@start)
    puts("Start\n")
    // Using 'str' like this isn't quite the same as the other versions of this
    // benchmark, but since we need to know the string length in order to test
    // the return value of fileio::write(), this seems the most natural way to
    // write it.
    str = "1234567890qwertyuiop\n"
    fileio:create("X.TEST", $FE, $1000) // $FE and $1000 may be "wrong" but irrelevant on Acorn
    file = fileio:open("X.TEST")
    if file == 0
	oserror(0, "Can't open test file")
    fin
    for i = 1 to 1000
	if fileio:write(file, str + 1, ^str) <> ^str
	    fileio:close(file)
	    oserror(0, "Error writing test file")
	fin
    next
    if fileio:close(file) <> 0
	oserror(0, "Can't close test file")
    fin
    //if fileio:destroy("X.TEST") <> 0
    //    oserror(0, "Can't delete test file")
    //fin
    puts("Finish\n")
    time(@finish)
    log_time(@storefileiostr)
end

def storebput()#0
    // TODO: we could install an error handler at errjb here to close the
    // file before passing the error on
    word file, i, j, p
    if fileio:destroy("X.TEST") <> 0
        oserror(0, "Can't delete test file")
    fin
    time(@start)
    puts("Start\n")
    file = call_osfind_open(osfind_output, "X.TEST")
    if file == 0
	oserror(0, "Can't open test file")
    fin
    for i = 1 to 1000
	p = "1234567890qwertyuiop\n"
	j = ^p
	while j > 0
	    p++
	    call_osbput(^p, file)
	    j--
	loop
    next
    call(osfind, osfind_close, 0, file, 0)
    //call_oscli("DELETE X.TEST")
    puts("Finish\n")
    time(@finish)
    log_time(@storebputstr)
end

def storegbpb()#0
    // TODO: we could install an error handler at errjb here to close the
    // file before passing the error on
    word file, i, j, p
    byte block[32]
    if fileio:destroy("X.TEST") <> 0
        oserror(0, "Can't delete test file")
    fin
    time(@start)
    puts("Start\n")
    file = call_osfind_open(osfind_output, "X.TEST")
    if file == 0
	oserror(0, "Can't open test file")
    fin
    block.0 = file
    for i = 1 to 1000
        p = "1234567890qwertyuiop\n"
	block:1 = p + 1; block:3 = high_order_address()
	block:5 = ^p; block:7 = 0
	call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    next
    call(osfind, osfind_close, 0, file, 0)
    //call_oscli("DELETE X.TEST")
    puts("Finish\n")
    time(@finish)
    log_time(@storegbpbstr)
end

def sum(n)#1
    if n == 0
	return 0
    fin
    return n + sum(n - 1)
end

def fncall()#0
    // Test of function call performance
    const n = 1000
    word i, j
    time(@start)
    puts("Start\n")
    j = 0
    for i = 1 to n
	// We mustn't use a large argument to sum() as otherwise the recursion
	// overruns the 16 element stack.
	j = j + sum(10)
    next
    puts("Finish\n")
    time(@finish)
    log_time(@fncallstr)
    if j <> n*10*11/2
	oserror(0, "fncall failed")
    fin
end

mode(7)
intmath16()
intmath32()
fncall()
storefileio()
storebput()
storegbpb()
show_times()
done

// vi: sts=4 sw=4
