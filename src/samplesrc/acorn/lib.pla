// Simple (and rather pointless) example of how to implement a custom modname()
// function; a more sophisticated version of this might allow things like
// searching for modules in a library directory.
// SFTODO: It might be worth writing a proper utility which uses this feature
// to add a single "library directory" (a string prefix, which might be used
// on ADFS to access a different directory or on DFS/ADFS to access files on
// another drive) - we would ideally be able to re-execute that utility
// without leaking more memory each time. If we have that, maybe we don't need
// MODNAME as a sample any more, especially now we show the name of the module
// we couldn't find in the core VM and don't need MODNAME as a hack to make the
// name visible. We'd probably call this utility +LIB by analogy with *LIB.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/args.plh"
include "inc/acornc.plh"

const max_lib_path_len = 16 // this can be changed to suit
const max_module_name_len = 16 // this is a "fact" about PLASMA modules
struc t_data
    word base_data_ptr
    byte lib_path[max_lib_path_len+1]
    word parent_modname
end
byte our_data[t_data] = 0, 0, 0

word data_ptr
word arg

byte lib_dci = $cc, $c9, $42

def putcr(cr)#0
    word i
    i = cr
    while ^i <> 13
        putc(^i)
        i++
    loop
end

def lib_modname(modcr)#1
    byte filenamecr[max_lib_path_len + max_module_name_len + 1]
    word ptr
    byte lib_path_len, c, i, handle

    handle = data_ptr=>parent_modname(modcr)#1
    if handle <> 0
        return handle
    fin

    lib_path_len = ^(data_ptr + lib_path)
    memcpy(@filenamecr, data_ptr + lib_path + 1, lib_path_len)
    ptr = @filenamecr + lib_path_len
    i = 0
    repeat
        c = ^(modcr + i)
        ^ptr = c
        i++
        ptr++
    until c == '\n'
    puts("XXX"); putcr(@filenamecr); puts("XXX")
    handle = call(osfind, osfind_input, @filenamecr, @filenamecr >> 8, 0).0
    if handle <> 0
        memcpy(modcr, @filenamecr, ptr - @filenamecr)
    fin
    return handle
end

// The INIT code below is discarded after the module has been loaded, so we don't need
// to worry about how verbose it is to save memory.

// SFTODO TEMP EXPERIMENTAL
our_data:base_data_ptr = lookupsym(@lib_dci)
data_ptr = our_data:base_data_ptr
puts("SFTODOX"); puth(data_ptr); putln()

arg = argNext(argFirst()) // argFirst is the module name
if ^arg <> 0
    if ^arg > max_lib_path_len
        oserror(32, "Library path too long")
    fin
    if ^arg == 1 and ^(arg + 1) == '-'
        ^arg = 0
    fin
    strcpy(data_ptr + lib_path, arg)
else
    puts("Usage: LIB [PATH]\nUse a path of \"-\" to set an empty path.\n")
    puts("Library path: ");
    if ^(data_ptr + lib_path) > 0
        puts(data_ptr + lib_path)
    else
        putc('-')
    fin
    putln()
    return 0
fin

if data_ptr=>base_data_ptr == @our_data
    data_ptr=>parent_modname = modname
    modname = @lib_modname
    puts("Installed lib_modname()\n") // SFTODO TEMP
    return modkeep
fin

done
