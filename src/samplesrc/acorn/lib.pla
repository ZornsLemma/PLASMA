// Simple (and rather pointless) example of how to implement a custom modname()
// function; a more sophisticated version of this might allow things like
// searching for modules in a library directory.
// SFTODO: It might be worth writing a proper utility which uses this feature
// to add a single "library directory" (a string prefix, which might be used
// on ADFS to access a different directory or on DFS/ADFS to access files on
// another drive) - we would ideally be able to re-execute that utility
// without leaking more memory each time. If we have that, maybe we don't need
// MODNAME as a sample any more, especially now we show the name of the module
// we couldn't find in the core VM and don't need MODNAME as a hack to make the
// name visible. We'd probably call this utility +LIB by analogy with *LIB.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/args.plh"
include "inc/acornc.plh"

const max_lib_path_len = 16 // this can be changed to suit
const max_module_name_len = 16 // this is a "fact" about PLASMA modules
struc t_data
    word base_data_ptr
    byte lib_path[max_lib_path_len+1]
end
byte our_data[t_data] = 0, 0, 0

word data_ptr
word arg

// There's no requirement to chain modname() functions, but let's demonstrate
// that it's possible if desired.
word parent_modname

word lookup_modname // SFTODO TEMP EXPERIMENTAL
byte lib_dci = $cc, $c9, $42

def putcr(cr)#0
    word i
    i = cr
    while ^i <> 13
        putc(^i)
        i++
    loop
end

def lib_modname(modcr)#0
    byte filenamecr[max_lib_path_len + max_module_name_len + 1]
    word data_ptr, ptr
    byte lib_path_len, c, i, handle
    data_ptr = our_data:base_data_ptr
    lib_path_len = ^(data_ptr + lib_path)
    memcpy(@filenamecr, data_ptr + lib_path + 1, lib_path_len)
    ptr = @filenamecr + lib_path_len
    i = 0
    repeat
        c = ^(modcr + i)
        ^ptr = c
        i++
        ptr++
    until c == '\n'
    puts("XXX"); putcr(@filenamecr); puts("XXX")
    // SFTODO: Note this *prefers* to locate things in the library; I really want to prefer
    // current directory and only then fall back to lib.
    handle = call(osfind, osfind_input, @filenamecr, @filenamecr >> 8, 0).0
    if handle <> 0
        call(osfind, osfind_close, 0, handle, 0)
        memcpy(modcr, @filenamecr, ptr - @filenamecr)
    fin
end

// SFTODO TEMP EXPERIMENTAL
// SFTODO: NOTE WE REUSE VARIABLES A BIT TO REDUCE SIZE TAKEN ON HEAP BY RESIDENT DATA
our_data:base_data_ptr = lookupsym(@lib_dci)
data_ptr = our_data:base_data_ptr
puts("SFTODOX"); puth(data_ptr); putln()

arg = argNext(argFirst()) // argFirst is the module name
if ^arg <> 0
    if ^arg > max_lib_path_len
        oserror(32, "Library path too long")
    fin
    strcpy(data_ptr + lib_path, arg) // SFTODO: CHECK FOR OVERFLOW!
else
    // SFTODO: THIS MEANS THERE'S NO WAY TO SET THE LIBRARY PATH BACK TO AN EMPTY STRING
    puts("Library path is: ")
    puts(data_ptr + lib_path)
    putln()
    return 0
fin

if data_ptr=>base_data_ptr == @our_data
    parent_modname = modname // SFTODO NOT RIGHT, ASSUMING IT LIVES ANYWAY
    modname = @lib_modname
    puts("Installed lib_modname()\n") // SFTODO TEMP
    return modkeep
fin

done


// TODO: Some means of preventing this being installed over and over again
// (burning memory each time) might be nice, but as far as I can see upstream
// PLASMA doesn't support this and I am not sure it's a good idea to make
// Acorn-specific changes here. Now that modules have their address in the
// symbol table, can we use that to help?
//parent_modname = modname
//modname = @lib_modname
//puts("Installed lib_modname()\n")
//return modkeep // SFTODO BE MORE SELECTIVE
//done
