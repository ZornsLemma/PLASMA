//
// Map module
//
include "inc/acornc.plh"
include "inc/cmdsys.plh"
include "inc/conio.plh"
include "inc/fileio.plh"

//
// Title page
//

byte[] initstr
byte = " (        )\n"
byte = " )\\ )  ( /(  (\n"
byte = "(()/(  )\\()) )\\ )       (   (\n"
byte = " /(_))((_)\\ (()/(       )\\  )\\\n"
byte = "(_))    ((_) /(_))_  _ ((_)((_)\n"
byte = "| _ \\  / _ \\(_)) __|| | | || __|\n"
byte = "|   / | (_) | | (_ || |_| || _|\n"
byte = "|_|_\\  \\___/   \\___| \\___/ |___|\n"
byte = "\n"
byte = "       By Resman\n"
byte = "       Artwork by Seth Sternberger\n"
byte = ""
word titlestr = @initstr

//
// Octant beam parameters
//

const beamdepth = 23

byte dbeam = 0,2,4,8,12,17,22,28,37,44,53,63,72,83,96,109,123,137,151,166,183,202,220,239
const beampts = 240

byte[] xbeam
byte = 0
byte = 1,0
byte = 1,0
byte = 2,2,1,0
byte = 3,2,1,0
byte = 4,3,2,1,0
byte = 4,3,2,1,0
byte = 5,4,3,2,1,0
byte = 6,5,5,4,3,3,2,1,0
byte = 6,5,4,3,2,1,0
byte = 7,7,6,5,4,3,2,1,0
byte = 8,7,6,6,5,4,3,2,1,0
byte = 8,7,6,5,4,3,2,1,0
byte = 9,9,8,7,6,5,4,3,2,1,0
byte = 10,9,8,8,7,6,5,4,4,3,2,1,0
byte = 11,10,10,9,8,7,6,5,4,3,2,1,0
byte = 11,10,9,9,8,7,7,6,5,4,3,2,1,0
byte = 12,12,11,10,9,8,7,6,5,4,3,2,1,0
byte = 13,12,11,10,9,8,7,6,5,4,3,2,1,0
byte = 13,12,11,11,10,9,8,7,6,5,4,3,2,1,0
byte = 14,14,13,12,11,10,10,9,8,7,6,5,4,3,2,1,0
byte = 15,14,13,13,12,12,11,10,9,8,8,7,6,5,4,3,2,1,0
byte = 16,15,14,13,12,11,10,9,8,7,6,5,5,4,3,2,1,0
byte = 16,15,15,14,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0

byte[] ybeam
byte = 0
byte = 1,1
byte = 2,2
byte = 2,3,3,3
byte = 3,4,4,4
byte = 4,4,5,5,5
byte = 5,5,6,6,6
byte = 5,6,6,7,7,7
byte = 6,6,7,7,7,8,8,8,8
byte = 7,8,8,9,9,9,9
byte = 7,8,8,9,9,10,10,10,10
byte = 8,9,9,10,10,10,11,11,11,11
byte = 9,10,11,11,11,12,12,12,12
byte = 9,10,10,11,12,12,12,13,13,13,13
byte = 10,11,11,12,12,13,13,13,14,14,14,14,14
byte = 11,11,12,12,13,13,14,14,15,15,15,15,15
byte = 12,13,13,14,14,14,15,15,15,16,16,16,16,16
byte = 12,13,13,14,15,15,16,16,16,17,17,17,17,17
byte = 13,14,14,15,16,16,17,17,17,18,18,18,18,18
byte = 14,15,15,16,16,17,17,18,18,18,19,19,19,19,19
byte = 14,15,15,16,17,17,18,18,18,19,19,19,20,20,20,20,20
byte = 15,16,16,17,17,18,18,19,19,19,20,20,20,20,21,21,21,21,21
byte = 16,16,17,18,19,19,20,20,21,21,21,21,22,22,22,22,22,22
byte = 17,17,18,18,19,19,20,20,21,21,22,22,22,23,23,23,23,23,23

byte[] vbeam
byte = 0
byte = 0,0
byte = 2,2
byte = 1,3,4,4
byte = 5,7,7,8
byte = 9,6,11,11,12
byte = 14,10,16,16,17
byte = 13,19,15,21,21,22
byte = 23,18,24,25,20,26,26,27,28
byte = 30,32,33,35,35,36,37
byte = 29,38,31,40,34,42,42,43,44
byte = 45,47,39,48,49,41,51,51,52,53
byte = 46,56,58,59,50,60,61,62,63
byte = 54,64,55,57,67,68,60,69,70,71,72
byte = 73,75,65,76,66,78,79,69,80,80,81,82,83
byte = 84,74,85,86,88,77,90,91,93,93,94,95,96
byte = 98,100,87,101,102,89,103,104,92,105,106,107,108,109
byte = 97,110,99,112,114,115,117,118,105,119,120,121,122,123
byte = 124,126,111,113,129,116,131,132,119,133,134,135,136,137
byte = 125,140,127,141,128,143,130,145,146,133,147,148,149,150,151
byte = 138,152,139,154,156,142,157,158,144,160,161,147,162,163,164,165,166
byte = 167,169,153,170,155,171,172,174,175,159,176,177,178,178,179,180,181,182,183
byte = 184,168,186,188,190,173,192,193,195,196,197,197,214,198,199,200,201,202
byte = 204,185,205,187,206,189,208,191,210,194,212,213,214,215,216,217,218,219,220

byte[beampts] vispix = 1

const rowshift = 6
const maprows  = 64
const mapcols  = 64
const mapsize  = maprows*mapcols

const WALL_TILE   = '#'
const FLOOR_TILE  = '.'
const TORCH_TILE  = '*'
const PIT_TILE    = ' '
const DOOR_TILE   = '+'
const LOCKED_TILE = '%'
const WATER1_TILE = '>'
const WATER2_TILE = '<'
const KEY_TILE    = ','
const RAFT_TILE   = '@'
const GOLD_TILE   = '$'
const FOOD_TILE   = '&'
const ENTER_TILE  = '-'
const EXIT_TILE   = '='
const OPAQUE_TILE = $01
const VIEWED_TILE = $80
const LIT_TILE    = $80
// SFTODO: Really need to respect INV_TILE when updating screen for Acorn port
const INV_TILE    = $3F
const MAP_TILE    = $7F

byte catacomb = "LEVEL0"
word map, viewmap

const xcentr     = 20
const ycentr     = 12
const scrnwidth  = 40
const scrnheight = 22

//
// Buffer to void checks in octant caster
//

byte[scrnwidth*(scrnheight+1)] emscreen
byte[scrnwidth*(scrnheight+1)] emscreen2
byte[scrnwidth] linebuffer

// I think these @linebuffer elements before and after the 'real' lines
// in screen are to allow writes "off screen" without it actually corrupting
// any significant memory.

word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer

// Apple code for reference:
// word[] screen
// word = $400, $480, $500, $580, $600, $680, $700, $780
// word = $428, $4A8, $528, $5A8, $628, $6A8, $728, $7A8
// word = $450, $4D0, $550, $5D0, $650, $6D0, $750, @linebuffer // $7D0
// Acorn code:
word[2*8+7] screen // initialised in INIT below
word = @linebuffer

word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer

// SFTODO: This doesn't emit newline at end of 40 chars, so (it's a good idea
// anyway) we should have some code on startup to make sure we are in a 40
// char mode. (It can kill things via oserror() if we're not.)
// SFTODO: We should probably turn the cursor off during this
// SFTODO: WITH THIS EXPERIMENTAL DOUBLE-BUFFERING, WE PROBABLY NEED TO GO AND
// BLANK OUT THE STATUS LINE BEFORE REDRAWING IT, TO AVOID PROBLEMS WHEN
// NUMBERS GET SMALLER AND HAVE FEWER DIGITS - WE USED TO DO A CLS IN HERE
// WHICH SIDESTEPPED THIS
// SFTODO: WE NEED TO REFUSE TO RUN IF WE'RE NOT IN A 40 COLUMN MODE, SINCE
// THIS CODE ASSUMES LINE WRAPPING AT 40 CHARS (AS DID THE NON-DOUBLE-BUFFERED VERSION)

//
// Update the display using OS calls so it looks like 'scrn', taking advantage
// of the fact it previously looked like 'scrn2' to avoid unnecessary updates.
// (On the very first call, scrn2 will have been automatically zero initialised
// and the display will be blank; this is a bit hacky, because a zero byte is
// an inverted A, but in practice we get away with this because the map won't
// contain any such characters. invalidatemap() forces scrn2 to all-$FF so we'll
// redraw everything; we will never actually have an $FF byte in scrn so this is
// fine.)
//

asm drawscreen(scrn, scrn2)#0
	!SOURCE "vmsrc/plvmzp.inc"
        !SOURCE "vmsrc/acorn/acornc.inc"
        ; CURSOR[XY] track where the OS text cursor is; we use this to decide
        ; the most efficient way to position it where we want. We could query
        ; this from the OS but we're trying to avoid unnecessary delays.
        CURSORX = TMP
        CURSORY = TMP+1
        FGCOLOUR = SCRATCH

	STX ESP

        ; SRC is scrn, DST is scrn2
	LDA ESTKL+1,X
	STA SRCL
	LDA ESTKH+1,X
	STA SRCH
        LDA ESTKL,X
        STA DSTL
        LDA ESTKH,X
        STA DSTH

        ; Start off with the cursor at the top left.
        LDA #vdu_home
        JSR OSWRCH
        ; As we go round LINELOOP, the X register holds the Y screen index
        ; and the Y register holds the X screen index.
	LDX #0
        STX CURSORX
        STX CURSORY

        ; We always start off in normal (non-inverse) video; we restore this
        ; before returning to our caller.
        LDA #1
        STA FGCOLOUR
        BNE LINELOOP

        ; VIDEOCHANGE is a pseudo-subroutine to avoid branch distance limits;
        ; remember we can't use JSR within our code as it won't be relocated.
VIDEOCHANGE
        STA FGCOLOUR
        ; Set the foreground and background colours so the foreground colour is
        ; FGCOLOUR and the background is opposite.
        LDA #vdu_tcol
        JSR OSWRCH
        LDA FGCOLOUR
        JSR OSWRCH
        LDA #vdu_tcol
        JSR OSWRCH
        LDA FGCOLOUR
        EOR #129
        JSR OSWRCH
        LDA #1
        BNE NOVIDEOCHANGE

LINELOOP
	LDY #0
CHARLOOP
        ; Do we need to do anything?
	LDA (SRC),Y
        CMP (DST),Y
        BEQ NOCHANGE

        ; Yes we do. Update scrn2 so we remember we've done this.
        STA (DST),Y

        ; Set the foreground and background colour correctly for this character.
        CMP #$40        ; clear C iff we want inverse video
        LDA #0
        ROL
        CMP FGCOLOUR
        BNE VIDEOCHANGE
NOVIDEOCHANGE

        ; If the cursor isn't on the right line, we'll just move it to the
        ; desired position directly. Similarly if we're more than one X position
        ; away. If it's already in the right place we obviously don't need to
        ; do anything, and if it's just one position too far left we will use
        ; VDU 9 to bump it over. (I did a crude timing test from BASIC and I
        ; think VDU 9 is faster than VDU 31,X,Y but not that much faster, so
        ; we only use it for a single character move.)
        CPX CURSORY
        BNE MOVEXY
        TYA
        SEC
        SBC CURSORX
        BEQ NOMOVENEEDED
        CMP #1
        BNE MOVEXY
        LDA #9 ; SFTODO MAGIC CONSTANT
        JSR OSWRCH
        INC CURSORX
        BNE NOMOVENEEDED
MOVEXY
        LDA #vdu_goto_xy
        JSR OSWRCH
        TYA
        STA CURSORX
        JSR OSWRCH
        TXA
        STA CURSORY
        JSR OSWRCH
NOMOVENEEDED

        ; Output the character. The Apple II character set has printable
        ; characters where ASCII has control characters.
        LDA (SRC),Y
        AND #$7F
        CMP #$20
        BCS NOTLOWCHAR
        ADC #$40
NOTLOWCHAR
        JSR OSWRCH
        INC CURSORX
        LDA CURSORX
        CMP #40
        BNE NOLINEWRAP
        INC CURSORY
        LDA #0
        STA CURSORX
NOLINEWRAP

NOCHANGE
        ; Advance to the next character in the emulated screen and loop back
        ; round as appropriate.
	INY
	CPY #40
	BNE CHARLOOP
	CLC
	LDA SRCL
	ADC #40
	STA SRCL
	BCC +
	INC SRCH
+	CLC
        LDA DSTL
        ADC #40
        STA DSTL
        BCC +
        INC DSTH
+       INX
        CPX #23
	BCC LINELOOP

        ; We're done. Restore normal video and set X appropriately before
        ; returning to our caller.
        LDA #vdu_tcol
        JSR OSWRCH
        LDA #1
        JSR OSWRCH
        LDA #vdu_tcol
        JSR OSWRCH
        LDA #128
        JSR OSWRCH
	LDX ESP
        INX
        INX
	RTS
end

//
// Load map - levels 0 to 9
//

export def loadmap(level)
  byte mapref, row, l

  //
  // Init the view map
  //
  // SFTODO: I *think* it would be possible to replace viewmap by a packed
  // array of bits to indicate whether a tile in 'map' has been seen or not.
  // That would save 3.5K, less the extra code needed to handle the packed
  // array - maybe 3K saving overall? I suspect the performance impact would
  // be acceptable, maybe not even noticeable. However, this would be a
  // potential source of bugs and it's not clear to me it's worth it - it might
  // allow the game to run on a BBC B with PAGE=&1900 and no sideways or
  // shadow RAM, but only in mode 7, which isn't ideal anyway. This would also
  // mean a B+ 64K or B with shadow RAM and PAGE=&1900 could run the game in
  // shadow mode 4. BITD this might have been worth it, but nowadays I think
  // anyone running this is likely to have at least one sideways RAM bank which
  // (either via a PAGE=&E00 filing system or use of PLAS128) would allow them
  // to run the game anyway without this change.
  //
  if not viewmap
    viewmap = heapalloc(mapsize)
  fin
  memset(viewmap, $A0A0, mapsize)
  //
  // Load catacomb map from file
  //
  if not map
    map = heapalloc(mapsize)
  fin
  memset(map, $2323, mapsize) // Solid walls
  //
  // Set level map and read it
  //
  catacomb[catacomb] = '0' + level
  mapref = fileio:open(@catacomb)
  if mapref
    fileio:newline(mapref, $7F, $0D)
    for row = 1 to maprows - 2
      l = fileio:read(mapref, map + (row << 6) + 1, mapcols)
      ^(map + (row << 6) + l) = WALL_TILE
    next
    fileio:close(mapref)
    return TRUE
  fin
  return FALSE
end

//
// Tile access to map
//

export def getmaptile(xmap, ymap)
  return ^(map + (ymap << rowshift) + xmap)
end

export def setmaptile(xmap, ymap, tile)#0
  word imap

  imap = (ymap << rowshift) + xmap
  ^(map + imap) = tile
  if ^(viewmap + imap) <> $A0
    ^(viewmap + imap) = tile | VIEWED_TILE
  fin
end

export def updtmaptile(xmap, ymap, tile)#0
  word imap

  imap = (ymap << rowshift) + xmap
  ^(map + imap) = (^(map + imap) & LIT_TILE) | tile
  if ^(viewmap + imap) <> $A0
    ^(viewmap + imap) = tile | VIEWED_TILE
  fin
end

//
// Light torches in map
//

export def lighttorches#0
  word imap, tmap
  byte xmap, ymap, xt, yt

  for ymap = 1 to maprows - 2
    for xmap = 1 to mapcols - 2
      imap = (ymap << rowshift) + xmap
      if ^(map + imap) & MAP_TILE == TORCH_TILE
        for yt = ymap - 1 to ymap + 1
          for xt = xmap - 1 to xmap + 1
            tmap = (yt << rowshift) + xt
            ^(map + tmap) = ^(map + tmap) | LIT_TILE
          next
        next
      fin
    next
    if not (ymap & 7)
      putc('.')
    fin
  next
end

//
// Force a full redraw of the map on the next call to updatemap(). This is
// useful if the screen has been updated (e.g. via putc()) without going via
// drawscreen().
//

export def invalidatemap()#0
  byte yscr
  for yscr = 0 to scrnheight
    memset(@emscreen2 + yscr * scrnwidth, $FFFF, scrnwidth)
  next
end

//
// Draw the map. Return 0 if any light visible, 1 if in complete darkness
//

export def drawmap(xorg, yorg, viewfield, viewdir, lightdist, viewdist)
  byte l, dist, tile, adjtile, occluded, darkness
  word ymap, xmap, imap, o
  byte yscr, xscr

  if viewdist > beamdepth
    viewdist = beamdepth
  fin
  if lightdist > viewdist
    lightdist = viewdist
  fin
  //
  // Clear screen
  //
  // SFTODO PROB DON'T WANT THIS BUT LET'S KEEP IT HERE COMMENTED OUT FOR MOMENT conio:home()
  for yscr = 0 to scrnheight
    memset(screen[yscr], $A0A0, scrnwidth)
  next
  //
  // Draw background map if in light
  //
  darkness = 1
  imap     = (yorg << rowshift) + xorg
  if lightdist or ^(map + imap) & LIT_TILE
    //
    // Update current spot in viewmap
    //
    ^(viewmap + imap) = ^(map + imap) | VIEWED_TILE
    //
    // Draw the viewmap
    //
    xmap = xorg - xcentr
    if xmap < 0
      l    = mapcols
      xscr = -xmap
      xmap = 0
    else
      l    = mapcols - xmap
      xscr = 0
    fin
    if xscr + l > scrnwidth
      l = scrnwidth - xscr
    fin
    for yscr = 0 to scrnheight
      ymap = yscr - ycentr + yorg
      if ymap >= 0 and ymap < maprows
        memcpy(screen[yscr] + xscr, viewmap + (ymap << rowshift) + xmap, l)
      fin
    next
    darkness = 0
  fin
  //
  // Draw visible octants
  //
  for o = viewdir - viewfield - 1 to viewdir + viewfield
    dist     = lightdist + 1
    occluded = 1
    when o & 7
      is 0
        //
        // Run through lit octant beam points
        //
        for l = 1 to dbeam[lightdist]
          //
          // Check parent visiblity
          //
          if vispix[vbeam[l]]
            imap = ((yorg - ybeam[l]) << rowshift) + xorg + xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              //
              // The view stops here
              //
              vispix[l] = 0
            else
              //
              // This tile is transparent
              //
              vispix[l] = 1
              //
              // Check adjacent tile for opaqueness - improves wall display
              //
              adjtile = ^(map + imap + 1) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap + 1) = adjtile | VIEWED_TILE
                screen.[ycentr-ybeam[l], xcentr+xbeam[l]+1] = adjtile
              fin
            fin
            //
            // Update view
            //
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr-ybeam[l], xcentr+xbeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        //
        // Run through visible octant beam points
        //
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          //
          // Check parent visiblity
          //
          if vispix[vbeam[l]]
            imap = ((yorg - ybeam[l]) << rowshift) + xorg + xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              //
              // The view stops here
              //
              vispix[l] = 0
            else
              //
              // This tile is transparent
              //
              vispix[l] = 1
              occluded  = 0
            fin
            //
            // If the tile is in light, update view
            //
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr-ybeam[l], xcentr+xbeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          //
          // Advance beam distance
          //
          if l == dbeam[dist]
            if occluded
              //
              // Beam fully occluded
              //
              break
            fin
            //
            // Update distance
            //
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 1
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << rowshift) + xorg + ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap - mapcols) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap - mapcols) = adjtile | VIEWED_TILE
                screen.[ycentr-xbeam[l]-1, xcentr+ybeam[l]] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr-xbeam[l], xcentr+ybeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << rowshift) + xorg + ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr-xbeam[l], xcentr+ybeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 2
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << rowshift) + xorg + ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap + mapcols) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap + mapcols) = adjtile | VIEWED_TILE
                screen.[ycentr+xbeam[l]+1, xcentr+ybeam[l]] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr+xbeam[l], xcentr+ybeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << rowshift) + xorg + ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr+xbeam[l], xcentr+ybeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 3
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << rowshift) + xorg + xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap + 1) & INV_TILE
              if  adjtile & OPAQUE_TILE
                ^(viewmap + imap + 1) = adjtile | VIEWED_TILE
                screen.[ycentr+ybeam[l], xcentr+xbeam[l]+1] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr+ybeam[l], xcentr+xbeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << rowshift) + xorg + xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr+ybeam[l], xcentr+xbeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 4
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << rowshift) + xorg - xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap - 1) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap - 1) = adjtile | VIEWED_TILE
                screen.[ycentr+ybeam[l], xcentr-xbeam[l]-1] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr+ybeam[l], xcentr-xbeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg + ybeam[l]) << rowshift) + xorg - xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr+ybeam[l], xcentr-xbeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 5
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << rowshift) + xorg - ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap + mapcols) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap + mapcols) = adjtile | VIEWED_TILE
                screen.[ycentr+xbeam[l]+1, xcentr-ybeam[l]] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr+xbeam[l], xcentr-ybeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg + xbeam[l]) << rowshift) + xorg - ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr+xbeam[l], xcentr-ybeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 6
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << rowshift) + xorg - ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap - mapcols) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap - mapcols) = adjtile | VIEWED_TILE
                screen.[ycentr-xbeam[l]-1, xcentr-ybeam[l]] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr-xbeam[l], xcentr-ybeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          if vispix[vbeam[l]]
            imap = ((yorg - xbeam[l]) << rowshift) + xorg - ybeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr-xbeam[l], xcentr-ybeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
      is 7
        for l = 1 to dbeam[lightdist]
          if vispix[vbeam[l]]
            imap = ((yorg - ybeam[l]) << rowshift) + xorg - xbeam[l]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              adjtile = ^(map + imap - 1) & INV_TILE
              if adjtile & OPAQUE_TILE
                ^(viewmap + imap - 1) = adjtile | VIEWED_TILE
                screen.[ycentr-ybeam[l], xcentr-xbeam[l]-1] = adjtile
              fin
            fin
            ^(viewmap + imap) =  tile | VIEWED_TILE
            if tile <> PIT_TILE
              screen.[ycentr-ybeam[l], xcentr-xbeam[l]] = tile & INV_TILE
            fin
          else
            vispix[l] = 0
          fin
        next
        for l = dbeam[lightdist]+1 to dbeam[viewdist]
          imap = ((yorg - ybeam[l]) << rowshift) + xorg - xbeam[l]
          if vispix[vbeam[l]]
            tile = ^(map + imap)
            if tile & OPAQUE_TILE
              vispix[l] = 0
            else
              vispix[l] = 1
              occluded  = 0
            fin
            if tile & LIT_TILE
              ^(viewmap + imap) =  tile | VIEWED_TILE
              screen.[ycentr-ybeam[l], xcentr-xbeam[l]] = tile & INV_TILE
              darkness = 0
            fin
          else
            vispix[l] = 0
          fin
          if l == dbeam[dist]
            if occluded
              break
            fin
            occluded = 1
            dist     = dist + 1
          fin
        next
        break
    wend
  next
  return darkness
end

//
// Update the map on screen to show all the pending changes.
//

export def updatemap()#0
  drawscreen(@emscreen, @emscreen2)
end

//
// Draw other entities
//

export def drawvisentity(xofst, yofst, tile, force)#0
  word x, y
  x = xcentr+xofst
  y = ycentr+yofst
  if force or screen.[y, x] < $80
    screen.[y, x] = tile
  fin
end

// SFTODO: SHOULD WE DO SOME LITTLE TOUCHES LIKE DISABLE CURSOR KEYS SO
// PRESSING THEM DOESN'T ENTER "USELESS" SCREEN COPY MODE, OR TWEAK THEM SO THEY
// CAN BE USED TO MOVE? MAYBE ALSO DISABLE ESCAPE KEY? (COULD TREAT ESCAPE LIKE
// "X" KEY, IF WE DID *FX229,1, THAT WOULD BE NICE I THINK)

//
// Print title page
//

conio:home()
while ^titlestr
  puts(titlestr)
  titlestr = titlestr + ^titlestr + 1
loop

//
// Miscellaneous Acorn initialisation. By doing this in this module's INIT
// instead of the ROGUE module's INIT (which might be more logical, all else
// being equal) this code will be discarded after it's executed.
//

//
// Initialise screen array
//

// Re-use map global to avoid needing to create a new one
for map = 0 to scrnheight
  screen[map] = @emscreen + 40 * map
next
map = 0

//
// Set up keyboard
// SFTODO: IDEALLY WE'D REVERT THESE CHANGES (AND ANY CURSOR CHANGES, IF THERE
// ARE ANY, WHICH THERE PROBABLY WON'T BE MOST OF TIME) ON EXIT - BUT THIS ISN'T
// CRITICAL
//

call(osbyte, osbyte_set_cursor_key_action, 1, 0, 0)
call(osbyte, osbyte_set_auto_repeat_delay, 0, 0, 0)

// SFTODO: MIGHT BE NICE TO MAKE CURSOR A FULL-HEIGHT ONE, GIVEN IT IS MAINLY
// USED TO HIGHLIGHT THE PLAYER CHARACTER IN MIDDLE OF MAP - PERHAPS ONLY DO
// THIS ONCE THE MAIN GAME STARTS, NOT HERE, SO WE DON'T HAVE THIS DURING NAME
// ENTRY. TO BE HONEST, I AM THINKING WE SHOULD DEFAULT TO HAVE CURSOR OFF AND
// JUST EXPLICITLY TURN IT ON WHEN WE WANT IT (WHEN WAITING FOR A USER KEYPRESS)
// WE COULD THEN ALSO SET IT TO FULL HEIGHT IFF WE ARE WAITING FOR A USER KEYPRESS
// ON THE MAP SCREEN WITH CURSOR ON OUR CHARACTER

//
// Warn if using mode 7
//

if call(osbyte, osbyte_read_char_and_mode, 0, 0, 0).2 == 7
  puts("\nWarning: you are playing in mode 7, you\n")
  puts("will not be able to tell which squares\n")
  puts("are illuminated.\n")
fin

done
