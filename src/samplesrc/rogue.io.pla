import cmdsys
    predef syscall, call, getc, putc, puts, putln
    predef memset, memcpy, modaddr
    predef heapmark, heapallocalign, heapalloc, heaprelease, heapavail
    predef stocr
    byte MACHID
end

predef puti // SFTODO TEMP
include "inc/acornc.plh"

const modkeep     = $2000
const modinitkeep = $4000

byte cmdsys = "cmdsys"

byte[] initstr
byte = " (        )\n"
byte = " )\\ )  ( /(  (\n"
byte = "(()/(  )\\()) )\\ )       (   (\n"
byte = " /(_))((_)\\ (()/(       )\\  )\\\n"
byte = "(_))    ((_) /(_))_  _ ((_)((_)\n"
byte = "| _ \\  / _ \\(_)) __|| | | || __|\n"
byte = "|   / | (_) | | (_ || |_| || _|\n"
byte = "|_|_\\  \\___/   \\___| \\___/ |___|\n"
byte = "\n"
byte = "       By Resman\n"
byte = "       Artwork by Seth Sternberger\n"
byte = ""
word titlestr = @initstr

//
// Machine specific routines
//

export word rnd, getkb, home, gotoxy, tone
export word open, read, close, newline

byte noapple1 = "APPLE 1 NOT SUPPORTED."

const ENV_REG = $FFDF

const SPEAKER = $C030

const a2rndnum = $4E // ZP location of RND
const a2rndl   = $4E
const a2rndh   = $4F

word iobuff

word a3rndnum = 12345
byte devcons

def acrnd
  a3rndnum = a3rndnum * 31421 + 6927
  return a3rndnum & $7FFF
end

def acgetkb
  byte c
  // It's unnecessary to do this every time but it's a convenient place to do
  // it.
  call(osbyte_set_cursor_key_action, 1, 0, 0, osbyte)
  call(osbyte_flush_buffer, buffer_keyboard, 0, 0, osbyte)
  c = getc()
  when c
    is 139
      c = $0B // Up Arrow
      break
    is 138
      c = $0A // Down Arrow
      break
    is 136
      c = $08 // Left Arrow
      break
    is 137
      c = $15 // Right Arrow
      break
  wend
  call(osbyte_set_cursor_key_action, 0, 0, 0, osbyte)
  return c
end

def actone(duration, pitch)
  byte block[osword_sound_block_size]
  block:0 = 1
  block:2 = -10
  block:4 = pitch
  block:6 = duration
  return call(osword_sound, @block, @block >> 8, 0, osword)
end

def a3rnd
  a3rndnum = (a3rndnum << 1) + a3rndnum + 123
  return *a3rndnum & $7FFF
end

def a2rnd
  *a2rndnum = (*a2rndnum << 1) + *a2rndnum + 123
  return *a2rndnum & $7FFF
end

def a2getkb
  return getc()
end

def a2tone(duration, delay)
  byte i

  while duration
    ^SPEAKER
    for i = 0 to delay
    next
    duration = duration - 1
  loop
end

def a3tone(duration, pitch)
  byte env

  env = ^ENV_REG
  ^ENV_REG = env | $C0
  a2tone(duration, pitch)
  ^ENV_REG = env
end

//
// Acorn file routines
//
// These could be written more easily using the facilities in acornos.plh but
// this file is currently multi-machine and I'd like to keep it that way;
// adding a dependency on the acornos module would stop it loading on an Apple.

def acerror(msg)
  byte error[128]
  byte i
  error[0] = 0
  error[1] = 0
  for i = 1 to ^msg
    error[i + 1] = (msg).[i]
  next
  error[^msg + 2] = 0
  call(0, 0, 0, 0, @error)
end

def acopen(path, access)
  byte handle
  byte path_cr[128]
  stocr(path, path_cr)
  handle = call(osfind_input, path_cr, path_cr >> 8, 0, osfind).0
  if handle == 0
    acerror("Can't open")
  fin
  devcons = 0 // we use this Apple /// location as a flag
  return handle
end

def acclose(handle)
  return call(osfind_close, 0, handle, 0, osfind)
end

def acread(handle, buff, len)
  word i, c, result
  const carry_flag = 1
  // We use devcons to record EOF; this is a bit of a hack, but it works for
  // the limited I/O this program performs.
  if devcons
    return 0
  fin
  i = 0
  c = 0
  while (len > 0) and ((c & $7F) <> $0D)
    result = call(0, 0, handle, 0, osbget)
    if result->3 & carry_flag
      devcons = 1
      return i
    fin
    ^buff = result->0
    buff++
    i++
    len--
  loop
  return i
end

def acnewline(refnum, emask, nlchar)
  // No-op; our custom acread() always behaves as required.
end

//
// ProDOS file routines
//

def a2open(path, access)
    byte params[6]

    params.0 = 3
    params:1 = path
    params:3 = heapallocalign($0400, 8, @iobuff)
    params.5 = 0
    syscall($C8, @params)
    return params.5
end
def a2close(refnum)
    byte params[2]

    if iobuff
    	heaprelease(iobuff)
    	iobuff = 0
    fin
    params.0 = 1
    params.1 = refnum
    return syscall($CC, @params)
end
def a2read(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    syscall($CA, @params)
    return params:6
end
def a2newline(refnum, emask, nlchar)
    byte params[4]

    params.0 = 3
    params.1 = refnum
    params.2 = emask
    params.3 = nlchar
    return syscall($C9, @params)
end

//
// SOS file routines
//

def a3open(path, access)
    byte params[7]

    params.0 = 4
    params:1 = path
    params.3 = 0
    params:4 = @access
    params.6 = 1
    syscall($C8, @params)
    return params.3
end
def a3close(refnum)
    byte params[2]

    params.0 = 1
    params.1 = refnum
    return syscall($CC, @params)
end
def a3read(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    syscall($CA, @params)
    return params:6
end
def a3newline(refnum, emask, nlchar)
    byte params[4]

    params.0 = 3
    params.1 = refnum
    params.2 = $FF
    params.3 = nlchar
    return syscall($C9, @params)
end

//
// Acorn console routines
//

def achome
  return putc(12)
end

def acgotoxy(ch, cv)
    putc(31)
    putc(ch)
    return putc(cv)
end

//
// Apple /// console routines
//

def dev_status(devnum, code, list)
  byte params[5]

  params.0 = 3
  params.1 = devnum
  params.2 = code
  params:3 = list
  return syscall($82, @params)
end
def a3keypressed
  byte count
  dev_status(devcons, 5, @count)
  return count
end

def a3getkb
  while not a3keypressed
    a3rndnum = a3rndnum + 123
  loop
  return getc()
end

def a3home
    return putc(28)
end

def a3gotoxy(ch, cv)
    putc(24)
    putc(ch)
    putc(25)
    return putc(cv)
end

//
// Apple ][ console routines
//

def a2home
    return call($FC58, 0, 0, 0, 0) // home()
end

def a2gotoxy(x, y)
    ^$24 = x + ^$20
    return call($FB5B, y + ^$22, 0, 0, 0)
end

export def puti(i)
  if i < 0; putc('-'); i = -i; fin
  if i < 10
    putc(i + '0')
  else
    puti(i / 10)
    putc(i % 10 + '0')
  fin
end

export def toupper(c)
  if c >= 'a' and c <= 'z'
    c = c - $20
  fin
  return c
end

//
// Set machine specific routines
//

when MACHID & $C8
  is $C8 // Acorn
    rnd     = @acrnd
    getkb   = @acgetkb
    home    = @achome
    gotoxy  = @acgotoxy
    tone    = @actone
    open    = @acopen
    read    = @acread
    close   = @acclose
    newline = @acnewline
    break
  is $08 // Apple 1
    puts(@noapple1)
    return -1
  is $C0 // Apple ///
    rnd     = @a3rnd
    getkb   = @a3getkb
    home    = @a3home
    gotoxy  = @a3gotoxy
    tone    = @a3tone
    devcons = modaddr(@cmdsys).5 // devcons variable from cmdsys
    open    = @a3open
    read    = @a3read
    close   = @a3close
    newline = @a3newline
    break
  otherwise // Apple ][
    rnd     = @a2rnd
    getkb   = @a2getkb
    home    = @a2home
    gotoxy  = @a2gotoxy
    tone    = @a2tone
    open    = @a2open
    read    = @a2read
    close   = @a2close
    newline = @a2newline
wend

//
// Print title page
//

home()
while ^titlestr
  puts(titlestr)
  titlestr = titlestr + ^titlestr + 1
loop

done
