include "inc/cmdsys.plh"
include "inc/acornos.plh"

include "inc/acornc.plh"

const modkeep     = $2000
const modinitkeep = $4000

byte cmdsys = "cmdsys"

byte[] initstr
byte = " (        )\n"
byte = " )\\ )  ( /(  (\n"
byte = "(()/(  )\\()) )\\ )       (   (\n"
byte = " /(_))((_)\\ (()/(       )\\  )\\\n"
byte = "(_))    ((_) /(_))_  _ ((_)((_)\n"
byte = "| _ \\  / _ \\(_)) __|| | | || __|\n"
byte = "|   / | (_) | | (_ || |_| || _|\n"
byte = "|_|_\\  \\___/   \\___| \\___/ |___|\n"
byte = "\n"
byte = "       By Resman\n"
byte = "       Artwork by Seth Sternberger\n"
byte = ""
word titlestr = @initstr

//
// Machine specific routines
//

export word rnd, getkb, home, gotoxy, tone
export word open, read, close, newline

word acrndnum = 12345
byte eofflag

def acrnd
  byte block[5]
  call(osword, osword_read_time, @block, @block >> 8, 0)
  acrndnum = acrndnum ^ block:0
  acrndnum = acrndnum * 31421 + 6927
  return acrndnum & $7FFF
end

def acgetkb
  byte c
  // It's unnecessary to do this every time but it's a convenient place to do
  // it.
  // TODO: If you press ESCAPE it gets stuck in an infinite loop; we probably
  // need to acknowledge it. Or should getc() do this?
  call(osbyte, osbyte_set_cursor_key_action, 1, 0, 0)
  call(osbyte, osbyte_flush_buffer, buffer_keyboard, 0, 0)
  c = getc()
  when c
    is 139
      c = $0B // Up Arrow
      break
    is 138
      c = $0A // Down Arrow
      break
    is 136
      c = $08 // Left Arrow
      break
    is 137
      c = $15 // Right Arrow
      break
  wend
  call(osbyte, osbyte_set_cursor_key_action, 0, 0, 0)
  return c
end

def actone(duration, pitch)
  byte block[osword_sound_block_size]
  block:0 = 1
  block:2 = -10
  block:4 = pitch
  block:6 = duration / 10
  return call(osword, osword_sound, @block, @block >> 8, 0)
end

//
// Acorn file routines
//

def acopen(path, access)
  return call_osfind_open(osfind_input, path)
end

def acclose(handle)
  return call(osfind, osfind_close, 0, handle, 0)
end

def acread(handle, buff, len)
  word i, c, result
  const carry_flag = 1
  // We use eofflag to record EOF; this is a bit of a hack, but it works for
  // the limited I/O this program performs.
  // TODO: Does it actually work? Superficially I suspect the second level
  // will fail to load as we never reset eofflag. Test it.
  if eofflag
    return 0
  fin
  i = 0
  c = 0
  while (len > 0) and ((c & $7F) <> $0D)
    c = call_osbget(handle)
    if c == eof
      eofflag = 1
      return i
    fin
    ^buff = c
    buff++
    i++
    len--
  loop
  return i
end

def acnewline(refnum, emask, nlchar)
  // No-op; our custom acread() always behaves as required.
  return 0
end

//
// Acorn console routines
//

def achome
  putc(12)
  return 0
end

def acgotoxy(ch, cv)
    putc(31)
    putc(ch)
    putc(cv)
    return 0
end

export def toupper(c)
  if c >= 'a' and c <= 'z'
    c = c - $20
  fin
  return c
end

//
// Set machine specific routines
//

when MACHID & $C8
  is $C8 // Acorn
    rnd     = @acrnd
    getkb   = @acgetkb
    home    = @achome
    gotoxy  = @acgotoxy
    tone    = @actone
    open    = @acopen
    read    = @acread
    close   = @acclose
    newline = @acnewline
    break
  otherwise
    puts("Unsupported")
    return -1
wend

//
// Print title page
//

achome()
while ^titlestr
  puts(titlestr)
  titlestr = titlestr + ^titlestr + 1
loop

done
