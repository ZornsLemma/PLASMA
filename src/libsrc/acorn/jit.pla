//
// PLASMA JIT bytecode compiler
//
include "inc/cmdsys.plh"
// SFTODO!? include "inc/cmdsysac.plh"
import cmdsysac // SFTODO TEMP HACK TO AVOID DUP CONSTANT DEF ERRORS
    predef oserror(n, msg)#0
end
include "vmsrc/acorn/plvmzp.plh"
include "vmsrc/acorn/vmconstants.plh"
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    byte callcount
    byte bytecodesize
end
//
// JIT compiler constants
//
const estkh8 = estkh << 8
const estkl8 = estkl << 8
const ifpl8 = ifpl << 8
const ifph8 = ifph << 8
const tmpl8 = tmpl << 8
const tmph8 = tmph << 8

// SFTODO: USE A CONSTANT FOR SAFETY MARGIN AND CALCUALTE CODEMAX USING IT - THAT WAY BOTH BUILDS WILL BE CONSISTENT AND IT'S BETTER DOCUMENTED
#ifndef PLAS128
    const codemax     = $F700 // SFTODO: PROBABLY 256 BYTES OF SAFETY MARGIN TO AVOID OVERWRITING TUBE "ROM" IS EXCESSIVE, BUT STICK WITH IT FOR NOW
#else
const codemax = $BF00 // SFTODO: SEMI-TEMP HACK FOR PLAS128 - NOTE THAT ON A MASTER WE HAVE HAZEL AT $C000 SO WE CAN'T JUST SET CODEMAX TO $C000 AND NOT CARE ABOUT WRITES PAST IT - ON A B/B+ WE COULD DO THIS, AND PERHAPS SHOULD - 256 BYTES OF SAFETY MARGIN IS PROB OTT BUT ACCEPT IT FOR NOW - IF WE CAN REDUCE THE SAFETY MARGIN THE APPEAL OF PUSHING RIGHT TO $C000 FOR B/B+ IS LESSENED AND THAT REDUCES SCOPE FOR SUBTLE BUGS ON CERTAIN MACHINES ONLY
#endif
//
// Bytecode interpreter entrypoints
//
// SFTODO: I HAD TO HACK THESE TO BE NON-CONST
word indirectentry
word directentry
//
// Copy bytecode DEF to main memory
//
#ifndef PLAS128
def defcpy(dstSFTODO, defptr)#0
    memcpy(dstSFTODO, defptr=>bytecodeaddr, defptr->bytecodesize)
end
#else
// SFTODO HACK FOR PLAS128, MASSIVE CODE DUPLICATION WITH IINTERP AND MEMXCPY(),
// MAYBE THIS WOULD LIVE IN CMD.PLA IN A JIT BUILD, NOT WORRYING ABOUT IT FOR
// NOW
asm memxcpySFTODONOTSUREWHATTOCALLTHIS(dst,src,size)#0
        RAMBANK = $400 ; SFTODO HACK TO AVOID PROBS INCLUDING acornc.inc - WE DONT HAVE PLAS128 DEFINITION IN PLACE HERE
        !SOURCE "vmsrc/acorn/plvmzp.inc"
	LDA	ESTKH,X
	ORA	ESTKL,X
	BEQ	MEMXCPYEX

	STY 	IPY

	;* This code must be kept consistent with IINTERP
	LDA	ESTKH+1,X
        ROL
        ROL
        ROL
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+1,X
	AND	#$BF
	ORA	#$80
	STA 	SRCH
	LDA	ESTKL+1,X
	STA	SRCL

	LDA	ESTKL+2,X
	STA	DSTL
	LDA	ESTKH+2,X
	STA	DSTH
	
	LDY	ESTKL,X
	BEQ	MEMXCPYLP
	INC 	ESTKH,X
	LDY	#$00
MEMXCPYLP 
	LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	MEMXCPYLP
	DEC	ESTKH,X
	BNE	MEMXCPYLP

	LDY	IPY
MEMXCPYEX
	INX
	INX
	INX
	RTS
end
def defcpy(dstSFTODO, defptr)#0
    memxcpySFTODONOTSUREWHATTOCALLTHIS(dstSFTODO, defptr=>bytecodeaddr, defptr->bytecodesize)
end
#endif
include "libsrc/jitcore.pla"
// Some TODOs from jitcore.pla:
                    // SFTODO: IS THIS IMPLEMENTATION OF CS GOING TO BE A
                    // PROBLEM IF MY PLAS128 JIT USES A SWR BANK TO HOLD THE
                    // JIT-GENERATED CODE? IF THE STRING GETS PASSED TO AN OS
                    // FUNCTION AND THEN TO ANOTHER PAGED ROM (EG A FILING
                    // SYSTEM) THE STRING MAY NO LONGER BE ACCESSIBLE. THIS IS
                    // *UNLIKELY* BUT IF SOMEONE WERE WRITING A PLASMA STRING
                    // RAW TO DISC USING OSGBPB IT COULD HAPPEN, I THINK.

                    // SFTODO: (COMMENT WAS ABOVE MUL/DIV/MOD/ETC) COULD I USE A SIMILAR APPROACH TO THE FOLLOWING
                    // TO RE-USE THE INTERPRETING VM'S CS OPCODE, IF THE
                    // EXISTING JIT CS OPCODE IMPLEMENTATION DOES CAUSE PROBLEMS
                    // AS NOTED IN OTHER SFTODO?
//
// Install JIT compiler
//
puts("SFTODO\n")
// This INIT code will be discarded once the module has been loaded, so we can
// afford to be verbose where it's helpful.
if *jitcomp
    puts("SFTODO1\n")
    if *jitcomp == 2
        puts("SFTODO2\n")
        oserror(18, "This VM doesn't support JIT; use PLASJIT or P128JIT.")
    fin
    puts("JITC already loaded\n")
    return 0
fin
*jitcomp        = @compiler
cmdsys.jitcount = 44
cmdsys.jitsize  = 96
indirectentry = *$0417 // SFTODO: HACK
directentry   = *$0415 // SFTODO: HACK
puts("JITC enabled\n")
puth(*jitcomp) // SFTODO TEMP
return modkeep
done
