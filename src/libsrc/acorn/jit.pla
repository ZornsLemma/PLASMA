//
// PLASMA JIT bytecode compiler
//
include "inc/cmdsys.plh"
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    byte callcount
    byte bytecodesize
end
//
// JIT compiler constants
//
// SFTODO TEMP NOTE - ACORN HAS ESTKH AT $50, ESTKL AT $60 - APPLE HAS ESTKH AT
// $C0, ESTKL AT $D0
const estkh8 = $5000
const estkh = $50
const estkl8 = $6000
const estkl = $60
// SFTODO TEMP NOTE - APPLE HAS IFPL AT $E0, IFPH AT $E1 - ACORN HAS IFPL AT $71, IFPH AT $72
const ifpl8 = $7100
const ifph8 = $7200
const jitcomp     = $0409
const jitcodeptr  = $040B
const codemax     = $F700 // SFTODO: TEMP HACK - NOTE THAT AMONG OTHER THINGS I SUSPECT (NOT CHECKED PROPERLY) THAT THE JIT CAN WRITE A FEW BYTES BEYOND THIS, SO WE EITHER NEED TO BE SURE THERE'S ROM AT CODEMAX OR MAKE IT ENOUGH BYTES BELOW THE ACTUAL TOP - OK, SO EVEN FOR THE HACK I'VE GOT F700 NOT F800 TO PLAY IT SAFE FOR THE MOMENT
//
// Bytecode interpreter entrypoints
//
// SFTODO: I HAD TO HACK THESE TO BE NON-CONST
word indirectentry
word directentry
//
// Copy bytecode DEF to main memory
//
def defcpy(dst, defptr)#0
    // SFTODO: I may need to implement this properly to make the JIT work on
    // PLAS128, but for my initial tube-only hack I can just memcpy(). I am not
    // going to try to avoid the copy in the first place because I suspect a
    // PLAS128-based JIT is the ultimate destination.
    memcpy(dst, defptr=>bytecodeaddr, defptr->bytecodesize)
    // SFTODO *$003C   = defptr=>bytecodeaddr
    // SFTODO *$003E   = *$003C + defptr->bytecodesize
    // SFTODO *$0042   = dst
    // SFTODO call($C311, 0, 0, 0, $04) // CALL XMOVE with carry clear (AUX->MAIN) and ints disabled
end
include "libsrc/acorn/jitcore.pla"
//
// Install JIT compiler
//
if *jitcomp
    return 0
fin
*jitcomp        = @compiler
cmdsys.jitcount = 44
cmdsys.jitsize  = 96
indirectentry = *$0417 // SFTODO: HACK
directentry   = *$0415 // SFTODO: HACK
puts("JITC enabled\n")
return modkeep
done
