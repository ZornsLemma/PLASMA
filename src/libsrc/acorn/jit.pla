//
// PLASMA JIT bytecode compiler
//
include "inc/cmdsys.plh"
// Normally we'd include "inc/cmdsysac.plh" to get this predef, but doing that
// would cause a clash because we also include vmsrc/acorn/vmconstants.plh.
// Normal code would not be including both files, so let's just accept this.
import cmdsysac
    predef oserror(n, msg)#0
end
include "vmsrc/acorn/plvmzp.plh"
#include "vmsrc/acorn/vmconstants.plh"
//
// Indirect interpreter DEFinition entrypoint
//
struc t_defentry
    byte interpjsr
    word interpaddr
    word bytecodeaddr
    byte callcount
    byte bytecodesize
end
//
// JIT compiler constants
//
const estkh8 = estkh << 8
const estkl8 = estkl << 8
const ifpl8 = ifpl << 8
const ifph8 = ifph << 8
const tmpl8 = tmpl << 8
const tmph8 = tmph << 8

// The JIT doesn't check for codeptr going past codemax after every single byte
// of code is generated, so we need to allow a safety margin to avoid
// overwriting anything after the end of the buffer. (On a B/B+ running PLAS128
// only, we have the OS ROM at the end of the buffer and could do without this
// safety margin, but taking advantage of that would require a separate JIT
// build and code in the VM to decide which to load, or codemax would have to be
// made a variable and that would probably bloat the JIT code - shrinking the
// JIT buffer on PLAS128 - more than we'd save. It just doesn't seem worth it
// for such a tiny gain.)
// SFTODO: Might be good to run some tests under emulator debugger with
// watchpoint on $C000 later on to verify this safety margin is enough in
// practice.
const codeoverflow = 32 // 23 would probably be enough but play it safe
#ifndef PLAS128
    const codemax = tuberamtop - codeoverflow
#else
    const codemax = $C000 - codeoverflow
#endif
//
// Bytecode interpreter entrypoints
//
// SFTODO: I HAD TO HACK THESE TO BE NON-CONST
word indirectentry
word directentry
//
// Copy bytecode DEF to main memory
//
#ifndef PLAS128
// "dst" is a constant from vmconstants.inc so we can't use it as a function
// parameter here.
def defcpy(dest, defptr)#0
    memcpy(dest, defptr=>bytecodeaddr, defptr->bytecodesize)
end
#else
// SFTODO HACK FOR PLAS128, MASSIVE CODE DUPLICATION WITH IINTERP AND MEMXCPY(),
// MAYBE THIS WOULD LIVE IN CMD.PLA IN A JIT BUILD, NOT WORRYING ABOUT IT FOR
// NOW
asm memxcpySFTODONOTSUREWHATTOCALLTHIS(dst,src,size)#0
        !SOURCE "vmsrc/acorn/plvmzp.inc"
        !SOURCE "vmsrc/acorn/vmconstants.inc"
	LDA	ESTKH,X
	ORA	ESTKL,X
	BEQ	MEMXCPYEX

	STY 	IPY

	;* This code must be kept consistent with IINTERP
	LDA	ESTKH+1,X
        ROL
        ROL
        ROL
	AND	#$03
	TAY
	LDA	RAMBANK,Y
	STA	$F4
	STA	$FE30

	LDA	ESTKH+1,X
	AND	#$BF
	ORA	#$80
	STA 	SRCH
	LDA	ESTKL+1,X
	STA	SRCL

	LDA	ESTKL+2,X
	STA	DSTL
	LDA	ESTKH+2,X
	STA	DSTH
	
	LDY	ESTKL,X
	BEQ	MEMXCPYLP
	INC 	ESTKH,X
	LDY	#$00
MEMXCPYLP 
	LDA	(SRC),Y
	STA	(DST),Y
	INY
	BNE	+
	INC	DSTH
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	MEMXCPYLP
	DEC	ESTKH,X
	BNE	MEMXCPYLP

	LDY	IPY
MEMXCPYEX
	INX
	INX
	INX
	RTS
end
def defcpy(dstSFTODO, defptr)#0
    memxcpySFTODONOTSUREWHATTOCALLTHIS(dstSFTODO, defptr=>bytecodeaddr, defptr->bytecodesize)
end
#endif
include "libsrc/jitcore.pla"
// Some TODOs from jitcore.pla:
                    // SFTODO: IS THIS IMPLEMENTATION OF CS GOING TO BE A
                    // PROBLEM IF MY PLAS128 JIT USES A SWR BANK TO HOLD THE
                    // JIT-GENERATED CODE? IF THE STRING GETS PASSED TO AN OS
                    // FUNCTION AND THEN TO ANOTHER PAGED ROM (EG A FILING
                    // SYSTEM) THE STRING MAY NO LONGER BE ACCESSIBLE. THIS IS
                    // *UNLIKELY* BUT IF SOMEONE WERE WRITING A PLASMA STRING
                    // RAW TO DISC USING OSGBPB IT COULD HAPPEN, I THINK.

                    // SFTODO: (COMMENT WAS ABOVE MUL/DIV/MOD/ETC) COULD I USE A SIMILAR APPROACH TO THE FOLLOWING
                    // TO RE-USE THE INTERPRETING VM'S CS OPCODE, IF THE
                    // EXISTING JIT CS OPCODE IMPLEMENTATION DOES CAUSE PROBLEMS
                    // AS NOTED IN OTHER SFTODO?
//
// Install JIT compiler
//
// This INIT code will be discarded once the module has been loaded, so we can
// afford to be verbose where it's helpful.
if *jitcomp
    if *jitcomp == 2
        oserror(errnojitsupport, "This VM doesn't support JIT; use PLASJIT or P128JIT.")
    fin
    puts("JITC already loaded\n")
    return 0
fin
*jitcomp        = @compiler
cmdsys.jitcount = 44
cmdsys.jitsize  = 96
indirectentry = *iinterpptr
directentry   = *interpptr
#ifdef PLAS128
    // cmd.pla initialises *jitcodeptr; it has access to xheap after the JIT
    // module has been loaded.
#else
    *jitcodeptr = tubejitheaptop
#endif
puts("JITC enabled\n")
return modkeep
done
