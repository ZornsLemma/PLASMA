// 32 bit (double word) arithmetic library
// SFTODO: SHOULD DITCH THIS IN FAVOUR OF UPSTREAM INT32 LIBRARY

// TODO: This code has not been heavily tested and may be buggy!

// TODO: Lots of common bits of code, can I arrange to e.g. BNE between
// different asm functions to share code?

// void dword_add(dword *result, const dword *lhs, const dword *rhs)
export asm dword_add(result, lhs, rhs)#0
    !SOURCE "vmsrc/plvmzp.inc"

    LDA ESTKL+2,X
    STA DSTL
    LDA ESTKH+2,X
    STA DSTH
    LDA ESTKL+1,X
    STA SRCL
    LDA ESTKH+1,X
    STA SRCH
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    INX
    INX
    INX
    STX ESP

    LDY #0
    LDX #3
    CLC
-   LDA (SRC),Y
    ADC (TMP),Y
    STA (DST),Y
    INY
    DEX
    BPL -

    LDX ESP
    RTS
end

// void dword_sub(dword *result, const dword *lhs, const dword *rhs)
// TODO: This is almost identical to dword_add, should they share code?
export asm dword_sub(result, lhs, rhs)#0
    // SFTODO: Do we really need this !SOURCE to be repeated?
    !SOURCE "vmsrc/plvmzp.inc"

    LDA ESTKL+2,X
    STA DSTL
    LDA ESTKH+2,X
    STA DSTH
    LDA ESTKL+1,X
    STA SRCL
    LDA ESTKH+1,X
    STA SRCH
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    INX
    INX
    INX
    STX ESP

    LDY #0
    LDX #3
    SEC
-   LDA (SRC),Y
    SBC (TMP),Y
    STA (DST),Y
    INY
    DEX
    BPL -

    LDX ESP
    RTS
end

// void dword_mul(dword *result, const dword *lhs, const dword *rhs)
// Based on the code at http://6502.org/source/integers/32muldiv.htm
// TODO: Is there any faster code available?
// TODO: Should we expose the high 32 bits of the result? Possibly via a
// separate function? It might be nicer if we can calculate faster and
// not generate the high 32 bits.
export asm dword_mul(result, lhs, rhs)#0
    MULR  = SCRATCH
    MULND = SCRATCH+4
    PROD  = SCRATCH+8

    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    LDY #3
-   LDA (TMP),Y
    STA MULR,Y
    DEY
    BPL -

    LDA ESTKL+1,X
    STA TMPL
    LDA ESTKH+1,X
    STA TMPH
    LDY #3
--  LDA (TMP),Y
    STA MULND,Y
    DEY
    BPL --

    STX ESP

MULTIPLY:  lda     #$00
           sta     PROD+4   ;Clear upper half of
           sta     PROD+5   ;product
           sta     PROD+6
           sta     PROD+7
           ldx     #$20     ;Set binary count to 32
SHIFT_R:   lsr     MULR+3   ;Shift multiplyer right
           ror     MULR+2
           ror     MULR+1
           ror     MULR
           bcc     ROTATE_R ;Go rotate right if c = 0
           lda     PROD+4   ;Get upper half of product
           clc              ; and add multiplicand to
           adc     MULND    ; it
           sta     PROD+4
           lda     PROD+5
           adc     MULND+1
           sta     PROD+5
           lda     PROD+6
           adc     MULND+2
           sta     PROD+6
           lda     PROD+7
           adc     MULND+3
ROTATE_R:  ror              ;Rotate partial product
           sta     PROD+7   ; right
           ror     PROD+6
           ror     PROD+5
           ror     PROD+4
           ror     PROD+3
           ror     PROD+2
           ror     PROD+1
           ror     PROD
           dex              ;Decrement bit count and
           bne     SHIFT_R  ; loop until 32 bits are

    LDX ESP
    INX
    INX
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    INX
    LDY #3
--- LDA PROD,Y
    STA (TMP),Y
    DEY
    BPL ---
    RTS
end

// void dword_div(dword *quotient, dword *remainder, const dword *lhs, const dword *rhs)
// quotient or remainder may be 0 to not return that value
// Based on the code at http://6502.org/source/integers/32muldiv.htm
// TODO: Is there any faster code available?
// TODO: No thought given to signedness considerations
export asm dword_div(quotient, remainder, lhs, rhs)#0
    DVDQUO = SCRATCH
    DVDR   = SCRATCH+4
    DMULR  = SCRATCH+12
    ADDDP  = TMPL

    STX ESP

    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    LDY #3
-   LDA (TMP),Y
    STA DVDR,Y
    LDA #0
    STA DVDR+4,Y
    DEY
    BPL -

    LDA ESTKL+1,X
    STA TMPL
    LDA ESTKH+1,X
    STA TMPH
    LDY #3
--  LDA (TMP),Y
    STA DVDQUO,Y
    DEY
    BPL --

DIVIDE:    ldy     #$20       ;Set bit length
DO_NXT_BIT: asl    DVDQUO
           rol     DVDQUO+1
           rol     DVDQUO+2
           rol     DVDQUO+3
           rol     DVDR+4
           rol     DVDR+5
           rol     DVDR+6
           rol     DVDR+7
           ldx     #$00
           lda     #$04
           sta     ADDDP
           sec
SUBT:      lda     DVDR+4,x   ;Subtract divider from
           sbc     DVDR,x     ; partial dividend and
           sta     DMULR,x    ; save
           inx
           dec     ADDDP
           bne     SUBT
           bcc     NXT        ;Branch to do next bit
           inc     DVDQUO     ; if result = or -
           ldx     #$04       ;Put subtractor result
RSULT:     lda     DMULR-1,x  ; into partial dividend
           sta     DVDR+3,x
           dex
           bne     RSULT
NXT:       dey
           bne     DO_NXT_BIT

    LDX ESP

    LDA ESTKL+2,X
    STA TMPL
    LDA ESTKH+2,X
    STA TMPH
    ORA TMPL
    BEQ NOREMAINDER
    LDY #3
--- LDA DVDR+4,Y
    STA (TMP),Y
    DEY
    BPL ---
NOREMAINDER

    LDA ESTKL+3,X
    STA TMPL
    LDA ESTKH+3,X
    STA TMPH
    ORA	TMPL
    BEQ NOQUOTIENT
    LDY #3
---- LDA DVDQUO,Y
    STA (TMP),Y
    DEY
    BPL ----
NOQUOTIENT

    ;* TODO: We could put an INX inside the previous LDY #3 loop and get rid of
    ;* these
    INX
    INX
    INX
    INX
    RTS
end

// TODO: Maybe get rid of dword_inc() and dword_dec() and export a dword_one
// variable with a value of 1? Note that you *can* export variables - testlib
// does it - you just mustn't declare them with 'predef'

// void dword_inc(dword *n)
export asm dword_inc(n)#0
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    INX

    LDY #0
    LDA (TMP),Y
    CLC
    ADC #1
    STA (TMP),Y
    BCC DONEINC
-   SEC
    INY
    LDA (TMP),Y
    ADC #0
    STA (TMP),Y
    BCC DONEINC
    CPY #3 ; will clear carry
    BNE -
DONEINC
    RTS
end

// void dword_dec(dword *n)
export asm dword_dec(n)#0
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    INX

    LDY #0
    LDA (TMP),Y
    SEC
    SBC #1
    STA (TMP),Y
    BCS DONEDEC
-   INY
    LDA (TMP),Y
    SBC #0
    STA (TMP),Y
    BCS DONEDEC
    CPY #3 ; will clear carry
    BNE -
DONEDEC
    RTS
end

// void dword_fromuword(dword *lhs, word rhs)
export asm dword_fromuword(lhs, rhs)#0
    LDA ESTKL+1,X
    STA TMPL
    LDA ESTKH+1,X
    STA TMPH
    LDY #0
    LDA ESTKL,X
    STA (TMP),Y
    INY
    LDA ESTKH,X
    STA (TMP),Y
    LDA #0
    INY
    STA (TMP),Y
    INY
    STA (TMP),Y
    INX
    INX
    RTS
end

// bool dword_isuword(const dword *p)
export asm dword_isuword(p)#1
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    LDY #2
    LDA (TMP),Y
    BNE NOTUWORD
    INY
    LDA (TMP),Y
    BNE NOTUWORD
    LDA #$FF
    !BYTE $2C ; BIT abs; skips next two bytes
NOTUWORD
    LDA #0
    STA ESTKL,X
    STA ESTKH,X
    RTS
end

// word dword_touword(const dword *p)
export asm dword_touword(p)#1
    LDA ESTKL,X
    STA TMPL
    LDA ESTKH,X
    STA TMPH
    LDY #0
    LDA (TMP),Y
    STA ESTKL,X
    INY
    LDA (TMP),Y
    STA ESTKH,X
    RTS
end

// bool dword_isugt(const dword *lhs, const dword *rhs)
export asm dword_isugt(lhs, rhs)#1
    LDA ESTKL+1,X
    LDY ESTKL,X
    STY ESTKL+1,X
    STA ESTKL,X
    LDA ESTKH+1,X
    LDY ESTKH,X
    STY ESTKH+1,X
    STA ESTKH,X
    ; fall through to dword_isult
end

// bool dword_isult(const dword *lhs, const dword *rhs)
export asm dword_isult(lhs, rhs)#1
    LDA ESTKL+1,X
    STA SRCL
    LDA ESTKH+1,X
    STA SRCH
    LDA ESTKL,X
    STA DSTL
    LDA ESTKH,X
    STA DSTH

    LDY #3
-   LDA (SRC),Y
    CMP (DST),Y
    BCC ISTRUE
    BNE ISFALSE
    DEY
    BPL -
ISFALSE
    LDA #0
    !BYTE $2C ; BIT abs; skips next two bytes
ISTRUE
    LDA #$FF
    
    INX
    STA ESTKL,X
    STA ESTKH,X
    RTS
end

// bool dword_isuge(const dword *lhs, const dword *rhs)
export asm dword_isuge(lhs, rhs)#1
    LDA ESTKL+1,X
    STA SRCL
    LDA ESTKH+1,X
    STA SRCH
    LDA ESTKL,X
    STA DSTL
    LDA ESTKH,X
    STA DSTH

    LDY #3
-   LDA (SRC),Y
    CMP (DST),Y
    BCC ISFALSE
    BNE ISTRUE
    DEY
    BPL -
    BMI ISTRUE
end

// void dword_adduword(dword *result, const dword *lhs, word rhs)
// TODO: rewrite in assembler?
export def dword_adduword(result, lhs, rhs)#0
    byte rhs_dword[4]
    dword_fromuword(@rhs_dword, rhs)
    dword_add(result, lhs, @rhs_dword)
end

// vi: sts=4 sw=4
