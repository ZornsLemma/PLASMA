// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"
include "vmsrc/acorn/plvmzp.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word setfileinfo
    word geteof
    word seteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word rename
    word newline
    word online
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acgetfileinfo(path, fileinfo), acsetfileinfo(path, fileinfo), acgeteof(refnum), acseteof(refnum, eofl, eofh), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acrename(oldpath, newpath)
predef acnewline(refnum, emask, nlchar)
predef aconline(unit, buf)
predef acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acgetfileinfo, @acsetfileinfo, @acgeteof, @acseteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy, @acrename
word = @acnewline
word = @aconline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES
word SFTODOHACK
word SFTODOHACK2

//
// I/O buffers SFTODO RENAME THIS COMMENTED SECTION?
//
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
const MAX_IOBUFS = 4
const IOBUF_MAX_SIZE = 256 // SFTODO: Rename IOBUF_SIZE? MAX implies variability...
byte iobuf0[IOBUF_MAX_SIZE]
struc t_iobuf
    word s_addr    // Pointer to IOBUF_MAX_SIZE bytes of space or 0
    byte s_handle  // Acorn OS file handle or 0
    byte s_size    // Bytes used at s_addr
    byte s_index   // Current position within s_addr
    byte s_flags   // Flags
    byte s_emask   // newline mode emask (0 = disabled)
    byte s_nlchar  // newline mode nlchar
end
const FLAG_DIRTY = $01 // Buffer contains data not yet written to disk
const FLAG_EOF   = $02 // EOF reached
const FLAG_EMPTY = $80 // Buffer is empty
word iobuf_array[t_iobuf * MAX_IOBUFS / 2] = @iobuf0

// This implementation is in assembler to avoid the overhead of doing the
// newline() checks for every byte in PLASMA code (acwrite() is able to defer
// most of its bulk operations to machine code via memcpy()) but it's not really
// performance critical and this code is optimised mainly for size.
predef fillbuf()#0
asm acread(refnum, buf, len)#1
    !SOURCE "vmsrc/plvmzp.inc"
    ; SFTODO: Strictly speaking, we can't assume SCRATCH remains valid across our call to
    ; fillbuf(), but in practice we can get away with it. (call() uses SRC, so
    ; that's why we don't use SRC and DST.)
    IOBUF = SCRATCH ; 2 bytes
    LEN = SCRATCH+2 ; 2 bytes
    IOBUFZP = SCRATCH+4 ; 8 bytes
    ; STOP = SCRATCH+12 ; 1 byte SFTODO MOVE OUTBUF DOWN TO FILL GAP
    OUTBUF = SCRATCH+13 ; 2 bytes
    S_ADDR = 0
    S_SIZE = 3
    S_INDEX = 4
    S_FLAGS = 5
    S_EMASK = 6
    S_NLCHAR = 7
    FLAG_EMPTY = $80
    FLAG_EOF = $02

    LDY ESTKL+2,X ; REFNUM
    DEY ; SFTODO: IF WE USED IOBUF_ARRAY-8 AS THE BASE, WE COULD AVOID THIS DEY
    TYA
    ASL
    ASL
    ASL
    ; CLC - pre-shift A value should have been <= MAX_IOBUFS
    ADC #$FF ; TODO IOBUF_ARRAY LOW
    STA IOBUF
    LDA #$FF ; TODO IOBUF_ARRAY HIGH
    ADC #0
    STA IOBUF+1

    LDY #S_NLCHAR
IOBUFTOZPLOOP
    LDA (IOBUF),Y
    STA IOBUFZP,Y
    DEY
    BPL IOBUFTOZPLOOP

    LDA ESTKL+1,X
    STA OUTBUF
    LDA ESTKH+1,X
    STA OUTBUF+1

    LDA ESTKL,X
    STA LEN
    LDA ESTKH,X
    STA LEN+1

LENLOOP
    LDA LEN
    ORA LEN+1
    BEQ LENLOOPDONE

    LDA IOBUFZP+S_FLAGS
    BEQ FLAGSCLEAR
    BPL NOTEMPTY
    LDA #0
    STA IOBUFZP+S_INDEX
    ; SFTODO JSR $FFFF ; SFTODO FILLBUF
    !BYTE $20 ; JSR
    word @fillbuf
    LDA IOBUFZP+S_FLAGS
NOTEMPTY
    AND #FLAG_EOF ; SFTODO IF WE MADE FLAG_EOF=$01 WE COULD LSR A AND TEST WITH BCC/BCS
    BNE LENLOOPDONE
FLAGSCLEAR

    LDA LEN
    BNE +
    DEC LEN+1
+   DEC LEN

    LDY IOBUFZP+S_INDEX
    LDA (IOBUFZP+S_ADDR),Y
    INY
    STY IOBUFZP+S_INDEX
    CPY IOBUFZP+S_SIZE
    BNE INDEXNESIZE
    PHA
    LDY #FLAG_EMPTY
    LDA IOBUFZP+S_SIZE
    BEQ SETFLAG
    LDY #FLAG_EOF
SETFLAG
    STY IOBUFZP+S_FLAGS
    PLA
INDEXNESIZE
    LDY #0
    STA (OUTBUF),Y
    INC OUTBUF
    BNE +
    INC OUTBUF+1
+

    LDY IOBUFZP+S_EMASK
    BEQ LENLOOP
    AND IOBUFZP+S_EMASK
    CMP IOBUFZP+S_NLCHAR
    BNE LENLOOP

LENLOOPDONE

    LDY #S_FLAGS
ZPTOIOBUFLOOP
    LDA IOBUFZP,Y
    STA (IOBUF),Y
    DEY
    BPL ZPTOIOBUFLOOP

    ; SFTODO: NEED TO SET PERR = 0

    SEC
    LDA ESTKL,X
    SBC LEN
    STA ESTKL+2,X
    LDA ESTKH,X
    SBC LEN+1
    STA ESTKH+2,X
    INX
    INX
    RTS
    // SFTODO EXPERIMENT
word @PERR
end

def acgetpfx(path)
    // SFTODO: I *think* the 'prefix' is the Apple equivalent of the 'current directory', but
    // I am not sure. For now let's just not support this and investigate later; we need to do
    // something that works with hierarchical and non-hierarchical file systems. It may be that
    // we can get away without supporting this and leave the Acorn filesystem to manage its
    // own concept of current directory.
    ^path = 0
    return path
end

def acsetpfx(path)
    // SFTODO: See acgetpfx()
    return path
end

def acgetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acsetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acgeteof(refnum)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

def acseteof(refnum, eofl, eofh)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

// SFTODO: Can't help feeling this could be rewritten to be clearer, e.g. let the
// PLASMA compiler work out the start position of iobuf_array[i] for us?
def aciobufs(iobufs)
    byte i
    word iobuf, freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
                iobuf = @iobuf_array + i
                if not iobuf=>s_addr
                    //SFTODOputs("ALLOC")
                    // SFTODO: Note that if heapalloc() fails, we will silently
                    // allocate fewer buffers than requested. This might be OK
                    // but it perhaps deserves a comment.
                    iobuf=>s_addr = heapalloc(IOBUF_MAX_SIZE)
                    // SFTODO: This is a copy of Apple II code, but I'm not sure
                    // it's right. Surely we should decrement iobufs even if
                    // iobuf=>s_addr is non-0, as we *have* a buffer and that
                    // counts?
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
            iobuf = @iobuf_array + i
            iobuf=>s_addr = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

// SFTODONOW: THIS WILL NEED TO RETURN SOME KIND OF ERROR INDICATION AND WE MUST BE
// SURE TO CHECK IT - IT WILL PROBABLY NEED TO USE throw()/except()
// SFTODO: THIS HAS ONLY ONE CALLER, *BUT* SINCE THE FINAL VERSION WILL PROBABLY
// WANT TO USE EXCEPT()/THROW() WE KEEP IT SEPARATE SO A FINAL ASSEMBLY LANGUAGE
// IMPLEMENTATION CAN CALL BACK INTO PLASM TO HANDLE THAT FIDDLY STUFF
def fillbuf()#0
    const iobufzp = scratch + 4 // IOBUFZP from acread()
    byte block[osgbpb_block_size]
    //SFTODOputs("FILLBUF"); puti(iobuf); putln()

    block.0 = iobufzp->s_handle
    block:1 = iobufzp=>s_addr
    block:3 = 0
    block:5 = IOBUF_MAX_SIZE
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    iobufzp->s_size = IOBUF_MAX_SIZE - block:5 // only care about low byte
    iobufzp->s_flags = (block:5 == IOBUF_MAX_SIZE) ?? FLAG_EOF :: 0
    perr = 0 // SFTODO: maybe this doesn't need to set perr itself
end

// SFTODONOW: THIS WILL EVENTUALLY NEED TO RETURN AN ERROR INDICATOR WHICH CALLER
// MUST CHECK
def flushbuf(iobuf, size)#0
    byte block[osgbpb_block_size]

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0
    block:5 = size
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!? MAYBE THIS DOESN'T NEED TO SET PERR ITSELF
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i
    word iobuf
    
    // SFTODO: SET PERR ON VARIOUS PATHS?
//SFTODOputs("FOO2 ")
//SFTODOputi(iobuf_array[0])
    for i = 0 to MAX_IOBUFS-1
        iobuf = @iobuf_array + i*t_iobuf
        //SFTODOputs("i "); puti(i); puts(" "); puti(iobuf=>s_addr); puts(" "); puti(iobuf->s_handle);putln()
        if iobuf=>s_addr and not iobuf->s_handle
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            iobuf->s_handle = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            if not iobuf->s_handle
                return 0
            fin
            iobuf->s_emask = 0
            // SFTODO: PERM COMMENT IF TRUE - we indicate starting state of
            // 'need to fill buffer' by setting index > size and index == 2
            iobuf->s_index = 0
            iobuf->s_size = 0
            iobuf->s_flags = FLAG_EMPTY
            return i + 1 // 0 indicates failure, so have to add 1
        fin
    next
    //SFTODOputs("OPENFAIL")
    return 0
end

def acclose(refnum)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    // We allow the same file to be closed multiple times (the Apple II
    // implementation seems to allow this), but if you try to read() or write()
    // after closing that will have undefined results.
    if iobuf->s_handle
        if iobuf->s_flags & FLAG_DIRTY
            flushbuf(iobuf, iobuf->s_size)
        fin
        call(osfind, osfind_close, 0, iobuf->s_handle, 0)
        iobuf->s_handle = 0
        perr = 0
        return perr
    fin
    perr = $45
    return perr
end

def acwrite(refnum, buf, len)
    word iobuf, origlen, buffer, chunk_size
    byte size

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    origlen = len
    buffer = iobuf=>s_addr
    size = iobuf->s_size

    while len > 0
        chunk_size = IOBUF_MAX_SIZE - size
        if chunk_size > len
            chunk_size = len
        fin
        memcpy(buffer + size, buf, chunk_size)
        buf = buf + chunk_size
        len = len - chunk_size
        size = size + chunk_size

        // SFTODO: NEXT LINE (AND MAYBE OTHERS) MAY FAIL DUE TO OPTIMISER
        // WIDENING SOME "BYTE" OPERATIONS - ASSUMING WE DECIDE TO KEEP THIS
        // BEHAVIOUR AND DOCUMENT IT, THIS CODE NEEDS TO BE WRITTEN TO COPE (AND
        // PUT COMMENTS IN) - OF COURSE WE COULD SIMPLY USE 'WORD' INSTEAD OF
        // 'BYTE' IF WE KNOW THIS ISN'T GOING TO BE CONVERTED TO ASM AND WON'T
        // BENEFIT FROM BYTE MUCH/AT ALL ANYWAY
        if size == 0 // i.e. effectively IOBUF_MAX_SIZE
            flushbuf(iobuf, IOBUF_MAX_SIZE)
            iobuf->s_flags = 0
        else
            iobuf->s_flags = FLAG_DIRTY
        fin
    loop

    iobuf->s_size = size
    return origlen // SFTODONOW NEEDS TO RETURN SMALLER VALUE IF ERROR OCCURS
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    if type == $0F
        // ENHANCEMENT: This is an attempt to create a directory, which we don't
        // currently support.
        perr = $4B // unsupported storage_type; not perfect error but it will do
    else
        stocr(path, @pathcr)

        // I believe the Apple II ProDOS implementation will return error $47 if
        // asked to create a file which already exists, so we do the same.
        refnum = call(osfind, osfind_input, @pathcr, @pathcr >> 8, 0).0
        if refnum <> 0
            perr = $47 // duplicate filename
        else
            refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
            perr = 0
        fin
        call(osfind, osfind_close, 0, refnum, 0)
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0
    return perr
end

def acrename(oldpath, newpath)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acnewline(refnum, emask, nlchar)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf
    iobuf->s_emask = emask
    iobuf->s_nlchar = nlchar
    perr = 0
    return perr
end

def aconline(unit, buf)
    // SFTODO: I haven't checked what this would actually do; we can possibly
    // implement it but for now we can get away without it.
    perr = $27 // IOERR
    return perr
end

// This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27 // IOERR
    return perr
end

//SFTODOputs("FOO")
//SFTODOputi(iobuf_array[0])

SFTODOHACK=@acread
for SFTODOHACK2=0 to 1 // SFTODO: WOULD BE 'to 3' IF WE DIDN'T USE THE EXPERIMENTAL 'word in asm' HACK
    while ^SFTODOHACK <> $FF
        //putb(^SFTODOHACK)        
        SFTODOHACK++
    loop
    if SFTODOHACK2==0
        ^SFTODOHACK = @iobuf_array
    elsif SFTODOHACK2==1
        ^SFTODOHACK = @iobuf_array >> 8
    elsif SFTODOHACK2==2
        ^SFTODOHACK = @fillbuf
    else
        ^SFTODOHACK = @fillbuf >> 8
    fin
    SFTODOHACK++
    SFTODOHACK2++
next

done
