// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"
include "vmsrc/acorn/plvmzp.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word setfileinfo
    word geteof
    word seteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word rename
    word newline
    word online
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acdummy2(a, b), acgeteof(refnum), acseteof(refnum, eofl, eofh), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acnewline(refnum, emask, nlchar)
predef aconline(unit, buf)
predef acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acdummy2, @acdummy2, @acgeteof, @acseteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy, @acdummy2
word = @acnewline
word = @aconline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES - ACTUALLY MAYBE I SHOULD NOT BE USING APPLE-COMPATIBLE VALUES, BECAUSE WHEN/IF I START WRAPPING THINGS WITH SETJMP TO TRAP ACORN ERRORS FROM FILESYSTEMS I MAY WANT TO RETURN THE ACORN ERROR CODES
word SFTODOHACK
word SFTODOHACK2

//
// I/O buffers
//
const MAX_IOBUFS = 4
const IOBUF_MAX_SIZE = 256 // SFTODO: Rename IOBUF_SIZE? MAX implies variability...
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
byte iobuf0[IOBUF_MAX_SIZE]
struc t_iobuf
    word s_addr    // Pointer to IOBUF_MAX_SIZE bytes of space or 0
    byte s_handle  // Acorn OS file handle or 0
    byte s_size    // Bytes used at s_addr (0 means 256 iff s_flags <> FLAG_EMPTY)
    byte s_index   // Current position within s_addr
    byte s_flags   // Flags
    byte s_emask   // newline mode emask (0 = disabled)
    byte s_nlchar  // newline mode nlchar
end
const FLAG_DIRTY = $01 // Buffer contains data not yet written to disk
const FLAG_EOF   = $02 // EOF reached
const FLAG_EMPTY = $80 // Buffer is empty
word iobuf_array[t_iobuf * MAX_IOBUFS / 2] = @iobuf0

// This implementation is in assembler to avoid the overhead of doing the
// newline() checks for every byte in PLASMA code (acwrite() is able to defer
// most of its bulk operations to machine code via memcpy()) but it's not really
// performance critical and this code is optimised mainly for size.
predef fillbuf()#0
asm acread(refnum, buf, len)#1
    !SOURCE "vmsrc/plvmzp.inc"
    IOBUF = SCRATCH ; 2 bytes
    LEN = SCRATCH+2 ; 2 bytes
    IOBUFZP = SCRATCH+4 ; 8 bytes
    OUTBUF = SCRATCH+12 ; 2 bytes

    ; Assembly equivalents of some PLASMA constants above; these obviously need
    ; to be kept in sync. We also implicitly assume that t_iobuf is 8.
    S_ADDR = 0
    S_SIZE = 3
    S_INDEX = 4
    S_FLAGS = 5
    S_EMASK = 6
    S_NLCHAR = 7
    FLAG_EMPTY = $80
    FLAG_EOF = $02

    ; Store the address of the relevant t_iobuf structure at IOBUF for ease of
    ; access.
    LDY ESTKL+2,X ; REFNUM
    TYA
    ASL
    ASL
    ASL
    ; CLC - pre-shift A value should have been <= MAX_IOBUFS
    ADC #$FF ; lo(@iobuf_array - t_iobuf)
    STA IOBUF
    LDA #$FF ; hi(@iobuf_array - t_iobuf)
    ADC #0
    STA IOBUF+1

    ; Copy our t_iobuf structure into zero page for ease of access; apart from
    ; saving continually tweaking Y to access different members via (IOBUF),Y,
    ; this also makes it possible to access the data at S_ADDR using
    ; (IOBUFZP+S_ADDR),Y addressing.
    LDY #S_NLCHAR
IOBUFTOZPLOOP
    LDA (IOBUF),Y
    STA IOBUFZP,Y
    DEY
    BPL IOBUFTOZPLOOP

    ; Copy the other function arguments into zero page; we need to use
    ; (OUTBUF),Y addressing and we need a working copy of the length so we can
    ; decrement it and stop when we hit zero.
    LDA ESTKL+1,X
    STA OUTBUF
    LDA ESTKH+1,X
    STA OUTBUF+1
    LDA ESTKL,X
    STA LEN
    LDA ESTKH,X
    STA LEN+1

    ; Main loop; we go round this copying a byte at a time into OUTBUF until
    ; 1) we've read the specified number of bytes, or
    ; 2) we've hit EOF, or
    ; 3) we've hit a newline (if configured)
READLOOP
    ; Stop if we've read the specified number of bytes.
    LDA LEN
    ORA LEN+1
    BEQ READLOOPDONE

    ; Check the flags. They're probably clear so we check that first to avoid
    ; unnecessary delays. If the empty flag is set we need to call fillbuf(),
    ; which will either fill the buffer or set the EOF flag. The EOF flag might
    ; already be set from a previous call; either way, if the EOF flag is set
    ; we obviously can't read any more. (The dirty flag is irrelevant here;
    ; the fileio interface doesn't really support reading and writing on the
    ; same file.)
    LDA IOBUFZP+S_FLAGS
    BEQ FLAGSCLEAR
    BPL NOTEMPTY ; S_EMPTY == $80
    LDA #0
    STA IOBUFZP+S_INDEX
    ; SFTODO JSR $FFFF ; SFTODO FILLBUF
    !BYTE $20 ; JSR
    word @fillbuf
    LDA IOBUFZP+S_FLAGS
NOTEMPTY
    AND #FLAG_EOF ; SFTODO IF WE MADE FLAG_EOF=$01 WE COULD LSR A AND TEST WITH BCC/BCS
    BNE READLOOPDONE
FLAGSCLEAR

    ; Decrement LEN by 1.
    LDA LEN
    BNE +
    DEC LEN+1
+   DEC LEN

    ; Copy a byte from the iobuf to OUTBUF and increment S_INDEX and OUTBUF. If
    ; S_INDEX now matches S_SIZE we've consumed all the data in the iobuf; if
    ; the iobuf didn't contain a full 256 bytes (S_SIZE of 0) we must have hit
    ; EOF, otherwise we just set the empty flag so the next byte read will call
    ; fillbuf().
    LDY IOBUFZP+S_INDEX
    LDA (IOBUFZP+S_ADDR),Y
    INY
    STY IOBUFZP+S_INDEX
    CPY IOBUFZP+S_SIZE
    BNE INDEXNESIZE
    PHA
    LDY #FLAG_EMPTY
    LDA IOBUFZP+S_SIZE
    BEQ SETFLAG
    LDY #FLAG_EOF
SETFLAG
    STY IOBUFZP+S_FLAGS
    PLA
INDEXNESIZE
    LDY #0
    STA (OUTBUF),Y
    INC OUTBUF
    BNE +
    INC OUTBUF+1
+

    ; Carry on reading, unless the newline feature is enabled and we just read
    ; a newline.
    LDY IOBUFZP+S_EMASK
    BEQ READLOOP
    AND IOBUFZP+S_EMASK
    CMP IOBUFZP+S_NLCHAR
    BNE READLOOP

READLOOPDONE
    ; Copy the zero page t_iobuf back into iobuf_array so our changes aren't
    ; lost.
    LDY #S_FLAGS
ZPTOIOBUFLOOP
    LDA IOBUFZP,Y
    STA (IOBUF),Y
    DEY
    BPL ZPTOIOBUFLOOP

    ; SFTODO: NEED TO SET PERR = 0

    ; The return value is the number of bytes read, i.e. the original 'len'
    ; argument minus our zero page LEN (which started off as a copy of 'len' and
    ; got decremented every time we read a byte).
    SEC
    LDA ESTKL,X
    SBC LEN
    STA ESTKL+2,X
    LDA ESTKH,X
    SBC LEN+1
    STA ESTKH+2,X
    INX
    INX
    RTS
    // SFTODO EXPERIMENT
word @PERR
end

def acgetpfx(path)
    // ENHANCEMENT: Not supported yet. I think this is the Apple equivalent of
    // the Acorn concept of the 'current directory', and we're probably as well
    // to let the Acorn filesystem manage this itself. However, if we started
    // to emulate more of the Apple functionality in this file this might turn
    // out to be relevant.
    ^path = 0
    perr = 0
    return path
end

def acsetpfx(path)
    // ENHANCEMENT: See acgetpfx()
    perr = 0
    return path
end

def acdummy2(path, fileinfo)
    // ENHANCEMENT: Not supported yet
    perr = $01
    return perr
end

def acgeteof(refnum)
    // ENHANCEMENT: Not supported yet
    return 0
end

def acseteof(refnum, eofl, eofh)
    // ENHANCEMENT: Not supported yet
    return 0
end

// SFTODO: Can't help feeling this could be rewritten to be clearer
def aciobufs(iobufs)
    byte i
    word iobuf, freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
                iobuf = @iobuf_array + i
                if not iobuf=>s_addr
                    //SFTODOputs("ALLOC")
                    // SFTODO: Note that if heapalloc() fails, we will silently
                    // allocate fewer buffers than requested. This might be OK
                    // but it perhaps deserves a comment.
                    iobuf=>s_addr = heapalloc(IOBUF_MAX_SIZE)
                    // We copy the Apple II implementation here; the idea seems
                    // to be that if you call fileio:iobufalloc(2) twice, you
                    // end up with four buffers allocated, not that each call
                    // independently ensures there are two buffers allocated and
                    // the second call is therefore a no-op. SFTODO: Actually I'm
                    // not too sure that is how the Apple II code works. Let's wait and see
                    // if Dave has any comments on issue #60.
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
            iobuf = @iobuf_array + i
            iobuf=>s_addr = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

// SFTODONOW: THIS WILL NEED TO RETURN SOME KIND OF ERROR INDICATION AND WE MUST BE
// SURE TO CHECK IT - IT WILL PROBABLY NEED TO USE throw()/except()
// SFTODO: THIS HAS ONLY ONE CALLER, *BUT* SINCE THE FINAL VERSION WILL PROBABLY
// WANT TO USE EXCEPT()/THROW() WE KEEP IT SEPARATE SO A FINAL ASSEMBLY LANGUAGE
// IMPLEMENTATION CAN CALL BACK INTO PLASM TO HANDLE THAT FIDDLY STUFF
def fillbuf()#0
    const iobufzp = scratch + 4 // IOBUFZP from acread()
    byte block[osgbpb_block_size]
    //SFTODOputs("FILLBUF"); puti(iobuf); putln()

    block.0 = iobufzp->s_handle
    block:1 = iobufzp=>s_addr
    block:3 = 0
    block:5 = IOBUF_MAX_SIZE
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    iobufzp->s_size = IOBUF_MAX_SIZE - block:5 // we only care about the low byte
    iobufzp->s_flags = (block:5 == IOBUF_MAX_SIZE) ?? FLAG_EOF :: 0
    perr = 0 // SFTODO: maybe this doesn't need to set perr itself
end

// SFTODONOW: THIS WILL EVENTUALLY NEED TO RETURN AN ERROR INDICATOR WHICH CALLER
// MUST CHECK
def flushbuf(iobuf, size)#0
    byte block[osgbpb_block_size]

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0
    block:5 = size
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!? MAYBE THIS DOESN'T NEED TO SET PERR ITSELF
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i
    word iobuf
    
    // SFTODO: SET PERR ON VARIOUS PATHS
//SFTODOputs("FOO2 ")
//SFTODOputi(iobuf_array[0])
    for i = 0 to MAX_IOBUFS-1
        iobuf = @iobuf_array + i*t_iobuf
        //SFTODOputs("i "); puti(i); puts(" "); puti(iobuf=>s_addr); puts(" "); puti(iobuf->s_handle);putln()
        if iobuf=>s_addr and iobuf->s_handle == 0
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            iobuf->s_handle = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            if iobuf->s_handle == 0
                return 0
            fin
            iobuf->s_emask = 0
            iobuf->s_index = 0
            iobuf->s_size = 0
            iobuf->s_flags = FLAG_EMPTY
            return i + 1 // 0 indicates failure, so have to add 1
        fin
    next
    //SFTODOputs("OPENFAIL")
    return 0
end

def acclose(refnum)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    // SFTODO: It's not necessarily a problem, but we don't initialise
    // iobuf_array so if you call close() on a refnum not previously returned
    // by open() it may try to close an arbitrary file handle. Think about it -
    // perhaps INIT should set all the handles to 0? Would this still leave a
    // "hole"? In reality you simply shouldn't be doing this, but I could
    // vaguely see cases where code is trying to clean up and wants to close
    // everything "to be safe".
    if iobuf->s_handle <> 0
        if iobuf->s_flags & FLAG_DIRTY
            flushbuf(iobuf, iobuf->s_size)
        fin
        call(osfind, osfind_close, 0, iobuf->s_handle, 0)
        iobuf->s_handle = 0
        perr = 0
        return perr
    fin
    perr = $45
    return perr
end

def acwrite(refnum, buf, len)
    word iobuf, origlen, buffer, chunk_size
    byte size
    // SFTODO: NEED TO SET PERR ON VARIOUS PATHS

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    origlen = len
    // SFTODO: GET RID OF 'BUFFER' (IT'S ONLY USED ONCE) AND JUST USE iobuf=>s_addr INLINE? CHECK GENERATED CODE TO SEE IF IT IS MUCH SMALLER/FASTER
    buffer = iobuf=>s_addr // SFTODO RENAME 'buffer' - BIT CONFUSING GIVEN WE HAVE 'buf' IN ARGS
    size = iobuf->s_size

    while len > 0
        chunk_size = IOBUF_MAX_SIZE - size
        if chunk_size > len
            chunk_size = len
        fin
        memcpy(buffer + size, buf, chunk_size)
        buf = buf + chunk_size
        len = len - chunk_size
        size = size + chunk_size

        // SFTODO: NEXT LINE (AND MAYBE OTHERS) MAY FAIL DUE TO OPTIMISER
        // WIDENING SOME "BYTE" OPERATIONS - ASSUMING WE DECIDE TO KEEP THIS
        // BEHAVIOUR AND DOCUMENT IT, THIS CODE NEEDS TO BE WRITTEN TO COPE (AND
        // PUT COMMENTS IN) - OF COURSE WE COULD SIMPLY USE 'WORD' INSTEAD OF
        // 'BYTE' IF WE KNOW THIS ISN'T GOING TO BE CONVERTED TO ASM AND WON'T
        // BENEFIT FROM BYTE MUCH/AT ALL ANYWAY
        if size == 0 // i.e. effectively IOBUF_MAX_SIZE
            flushbuf(iobuf, IOBUF_MAX_SIZE)
            iobuf->s_flags = 0
        else
            iobuf->s_flags = FLAG_DIRTY
        fin
    loop

    iobuf->s_size = size
    return origlen // SFTODONOW NEEDS TO RETURN SMALLER VALUE IF ERROR OCCURS
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    if type == $0F
        // ENHANCEMENT: This is an attempt to create a directory, which we don't
        // currently support.
        perr = $4B // unsupported storage_type; not perfect error but it will do
    else
        stocr(path, @pathcr)

        // I believe the Apple II ProDOS implementation will return error $47 if
        // asked to create a file which already exists, so we do the same.
        refnum = call(osfind, osfind_input, @pathcr, @pathcr >> 8, 0).0
        if refnum <> 0
            perr = $47 // duplicate filename
        else
            refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
            perr = 0
        fin
        call(osfind, osfind_close, 0, refnum, 0)
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0
    return perr
end

def acnewline(refnum, emask, nlchar)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf
    iobuf->s_emask = emask
    iobuf->s_nlchar = nlchar
    perr = 0
    return perr
end

def aconline(unit, buf)
    // ENHANCEMENT: Not supported yet
    perr = $27 // IOERR
    return perr
end

// ENHANCEMENT: This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27 // IOERR
    return perr
end

SFTODOHACK=@acread
for SFTODOHACK2=0 to 1 // SFTODO: WOULD BE 'to 3' IF WE DIDN'T USE THE EXPERIMENTAL 'word in asm' HACK
    while ^SFTODOHACK <> $FF
        //putb(^SFTODOHACK)        
        SFTODOHACK++
    loop
    if SFTODOHACK2==0
        ^SFTODOHACK = @iobuf_array - t_iobuf
    elsif SFTODOHACK2==1
        ^SFTODOHACK = (@iobuf_array - t_iobuf) >> 8
    elsif SFTODOHACK2==2
        ^SFTODOHACK = @fillbuf
    else
        ^SFTODOHACK = @fillbuf >> 8
    fin
    SFTODOHACK++
    SFTODOHACK2++
next

done
