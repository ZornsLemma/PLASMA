// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word geteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word newline
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acgetfileinfo(path, fileinfo), acgeteof(refnum), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acnewline(refnum, emask, nlchar), acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acgetfileinfo, @acgeteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy
word = @acnewline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES
word SFTODOHACK
word SFTODOHACK2

//
// I/O buffers SFTODO RENAME THIS COMMENTED SECTION?
//
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
const MAX_IOBUFS = 4
const IOBUF_MAX_SIZE = 256
byte iobuf0[IOBUF_MAX_SIZE]
struc t_iobuf
    word s_addr    // Pointer to IOBUF_MAX_SIZE bytes of space or 0
    byte s_handle  // Acorn OS file handle or 0
    byte s_size    // Bytes used at s_addr
    byte s_index   // Current position within s_addr
    byte s_flags   // Flags
    byte s_emask   // newline mode emask (0 = disabled)
    byte s_nlchar  // newline mode nlchar
end
const FLAG_DIRTY = $01 // Buffer contains data not yet written to disk
const FLAG_EOF   = $02 // EOF reached
const FLAG_EMPTY = $80 // Buffer is empty
// SFTODO: struct version gives 14856 bytes free in compiler compared to 14851
// free in older version, so it isn't "expensive" - current flags rewrite is
// now at 14865, now 14869 - now with the crude version of the assembler read(),
// 14875 bytes free, which is reassuring as (ignoring the minor penalty for
// assembler code on PLAS128 where it can't live in AUX memory) it suggestes the
// assembler version is not significantly bloating the module. Now 14905 bytes
// free. Now 14913 bytes free.
word iobuf_array[t_iobuf * MAX_IOBUFS / 2] = @iobuf0

// This implementation is in assembler to avoid the overhead of doing the
// newline() checks for every byte in PLASMA code (acwrite() is able to defer
// most of its bulk operations to machine code via memcpy()) but it's not really
// performance critical and this code is optimised mainly for size.
predef fillbuf(iobuf)#2
asm acread(refnum, buf, len)
    !SOURCE "vmsrc/plvmzp.inc"
    ; SFTODO: Strictly speaking, we can't assume SCRATCH remains valid across our call to
    ; fillbuf(), but in practice we can get away with it. (call() uses SRC, so
    ; that's why we don't use SRC and DST.)
    IOBUF = SCRATCH ; 2 bytes
    LEN = SCRATCH+2 ; 2 bytes
    IOBUFZP = SCRATCH+4 ; 8 bytes
    STOP = SCRATCH+12 ; 1 byte
    OUTBUF = SCRATCH+13 ; 2 bytes
    S_ADDR = 0
    S_SIZE = 3
    S_INDEX = 4
    S_FLAGS = 5
    S_EMASK = 6
    S_NLCHAR = 7
    FLAG_EMPTY = $80
    FLAG_EOF = $02

    LDY ESTKL+2,X ; REFNUM
    DEY
    TYA
    ASL
    ASL
    ASL
    ; CLC - pre-shift A value should have been <= MAX_IOBUFS
    ADC #$FF ; TODO IOBUF_ARRAY LOW
    STA IOBUF
    LDA #$FF ; TODO IOBUF_ARRAY HIGH
    ADC #0
    STA IOBUF+1

    LDY #S_NLCHAR
IOBUFTOZPLOOP
    LDA (IOBUF),Y
    STA IOBUFZP,Y
    DEY
    BPL IOBUFTOZPLOOP

    LDA ESTKL+1,X
    STA OUTBUF
    LDA ESTKH+1,X
    STA OUTBUF+1

    LDA ESTKL,X
    STA LEN
    LDA ESTKH,X
    STA LEN+1

    LDA #0 ; SFTODO Surely we have a 0 in a register we can save elsewhere in setup?
    STA STOP
    ; SFTODO If nothing else we could change LDA#xx:ADC#0 above to LDA#0:ADC#xx
    ; the we could store the 0 from accumulator into STOP.

LENLOOP
    LDA STOP
    BNE LENLOOPDONE
    LDA LEN
    ORA LEN+1
    BEQ LENLOOPDONE

    LDA IOBUFZP+S_FLAGS
    BEQ FLAGSCLEAR
    BPL NOTEMPTY
    LDA #0
    STA IOBUFZP+S_INDEX
    DEX
    LDA IOBUF
    STA ESTKL,X
    LDA IOBUF+1
    STA ESTKH,X
    ; SFTODO JSR $FFFF ; SFTODO FILLBUF
    !BYTE $20 ; JSR
    word @fillbuf
    ; SFTODO
    LDA ESTKL,X
    STA IOBUFZP+S_FLAGS
    LDA ESTKL+1,X
    STA IOBUFZP+S_SIZE
    INX
    INX
NOTEMPTY
    LDA IOBUFZP+S_FLAGS
    AND #FLAG_EOF ; SFTODO IF WE MADE FLAG_EOF=$01 WE COULD LSR A AND TEST WITH BCC/BCS
    BNE LENLOOPDONE
FLAGSCLEAR

DATAANDLENLOOP
    LDA LEN
    BNE +
    DEC LEN+1
+   DEC LEN

    LDY IOBUFZP+S_INDEX
    LDA (IOBUFZP+S_ADDR),Y
    INY
    STY IOBUFZP+S_INDEX
    LDY #0
    STA (OUTBUF),Y

    INC OUTBUF
    BNE +
    INC OUTBUF+1
+

    LDY IOBUFZP+S_EMASK
    BEQ NOTEMASK
    AND IOBUFZP+S_EMASK
    CMP IOBUFZP+S_NLCHAR
    BNE NOTEMASK
    LDA #1
    STA STOP
NOTEMASK

    LDA IOBUFZP+S_SIZE
    CMP IOBUFZP+S_INDEX
    BNE INDEXNESIZE
    LDY #FLAG_EMPTY
    LDA IOBUFZP+S_SIZE
    BEQ SETFLAG
    LDY #FLAG_EOF
SETFLAG
    STY IOBUFZP+S_FLAGS
    CLC
    BCC LENLOOP
INDEXNESIZE
    LDA STOP
    BNE LENLOOPDONE
    LDA LEN
    ORA LEN+1
    BNE DATAANDLENLOOP

LENLOOPDONE

    LDY #S_FLAGS
ZPTOIOBUFLOOP
    LDA IOBUFZP,Y
    STA (IOBUF),Y
    DEY
    BPL ZPTOIOBUFLOOP

    ; SFTODO: NEED TO SET PERR = 0

    SEC
    LDA ESTKL,X
    SBC LEN
    STA ESTKL+2,X
    LDA ESTKH,X
    SBC LEN+1
    STA ESTKH+2,X
    INX
    INX
    RTS
    // SFTODO EXPERIMENT
word @PERR
end

def acgetpfx(path)
    // SFTODO: I *think* the 'prefix' is the Apple equivalent of the 'current directory', but
    // I am not sure. For now let's just not support this and investigate later; we need to do
    // something that works with hierarchical and non-hierarchical file systems. It may be that
    // we can get away without supporting this and leave the Acorn filesystem to manage its
    // own concept of current directory.
    ^path = 0
    return path
end

def acsetpfx(path)
    // SFTODO: See acgetpfx()
    return path
end

def acgetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acgeteof(refnum)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

def aciobufs(iobufs)
    byte i
    word iobuf, freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
                iobuf = @iobuf_array + i
                if not iobuf=>s_addr
                    //SFTODOputs("ALLOC")
                    iobuf=>s_addr = heapalloc(IOBUF_MAX_SIZE)
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
            iobuf = @iobuf_array + i
            iobuf=>s_addr = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

// SFTODONOW: THIS WILL NEED TO RETURN SOME KIND OF ERROR INDICATION AND WE MUST BE
// SURE TO CHECK IT - IT WILL PROBABLY NEED TO USE throw()/except()
// SFTODO: THIS HAS ONLY ONE CALLER, *BUT* SINCE THE FINAL VERSION WILL PROBABLY
// WANT TO USE EXCEPT()/THROW() WE KEEP IT SEPARATE SO A FINAL ASSEMBLY LANGUAGE
// IMPLEMENTATION CAN CALL BACK INTO PLASM TO HANDLE THAT FIDDLY STUFF
def fillbuf(iobuf)#2
    byte block[osgbpb_block_size]
    //SFTODOputs("FILLBUF"); puti(iobuf); putln()

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0 // SFTODO: almost certainly fine/correct
    block:5 = IOBUF_MAX_SIZE
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO: maybe this doesn't need to set perr itself
    if block:5 == IOBUF_MAX_SIZE // EOF
        return 0, FLAG_EOF
    fin
    // SFTODO: Final implementation may not need the & $FF, e.g. if this is
    // called from assembler code which just ignores the high byte.
    return ((IOBUF_MAX_SIZE - block:5) & $FF), 0
end

// SFTODONOW: THIS WILL EVENTUALLY NEED TO RETURN AN ERROR INDICATOR WHICH CALLER
// MUST CHECK
def flushbuf(iobuf, size)#0
    byte block[osgbpb_block_size]

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0 // SFTODO?! almost certainly fine/correct
    block:5 = size
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!? MAYBE THIS DOESN'T NEED TO SET PERR ITSELF
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i
    word iobuf
    
    // SFTODO: SET PERR ON VARIOUS PATHS?
//SFTODOputs("FOO2 ")
//SFTODOputi(iobuf_array[0])
    for i = 0 to MAX_IOBUFS-1
        iobuf = @iobuf_array + i*t_iobuf
        //SFTODOputs("i "); puti(i); puts(" "); puti(iobuf=>s_addr); puts(" "); puti(iobuf->s_handle);putln()
        if iobuf=>s_addr and not iobuf->s_handle
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            iobuf->s_handle = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            if not iobuf->s_handle
                return 0
            fin
            iobuf->s_emask = 0
            // SFTODO: PERM COMMENT IF TRUE - we indicate starting state of
            // 'need to fill buffer' by setting index > size and index == 2
            iobuf->s_index = 0
            iobuf->s_size = 0
            iobuf->s_flags = FLAG_EMPTY
            return i + 1 // 0 indicates failure, so have to add 1
        fin
    next
    //SFTODOputs("OPENFAIL")
    return 0
end

def acclose(refnum)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    // We allow the same file to be closed multiple times (the Apple II
    // implementation seems to allow this), but if you try to read() or write()
    // after closing that will have undefined results.
    if iobuf->s_handle
        if iobuf->s_flags & FLAG_DIRTY
            flushbuf(iobuf, iobuf->s_size)
        fin
        call(osfind, osfind_close, 0, iobuf->s_handle, 0)
        iobuf->s_handle = 0
        perr = 0
        return perr
    fin
    perr = $45
    return perr
end

//asm SFTODOSKETCHREAD(refnum, buf, len)
//    STRUCTPTR = SCRATCH ; 2 bytes
//    LEN = SCRATCH+2 ; 2 bytes
//    INDEX = SCRATCH+4 ; 1 byte
//    ; SFTODO Pretending we have struct-based data and we've got our address in
//    ; STRUCTPTR
//    ; SFTODO Pretending buf argument is in DST
//    ; SFTODO Pretending len argument is in LEN
//    ; SFTODO Pretending index struct elem copied to INDEX
//    ; SFTODO Pretending ADDR is pointer to iobuf_addr
//
//LOOP1
//    LDA LEN
//    ORA LEN+1
//    BEQ LOOP1DONE
//    ; SFTODO WE COULD WORK WITH A 'LOCAL' ZP COPY OF FLAGS IF IT WOULD HELP
//    LDY #FLAGSOFFSET
//    LDA (STRUCTPTR),Y
//    BPL NOTSPECIALFLAG
//    SFTODOHANDLE WHAT IS INDEX=2/3 CASE IN PLASMA CODE
//NOTSPECIALFLAG
//LOOP2
//    LDA LEN
//    BNE +
//    DEC LEN+1
//+   DEC LEN
//    LDY INDEX
//    LDA (ADDR),Y
//    INY
//    STY INDEX
//    LDY #0 ; SFTODO: OR WE COULD KEEP X=0 AND USE STA (ZP,X) IN NEXT LINE?
//    STA (DST),Y
//    INC DST
//    BNE +
//    INC DST+1
//+   LDY EMASK
//    BEQ NOTNEWLINEMODE
//    AND EMASK
//    CMP NLCHAR
//    BEQ NEWLINEMATCH
//NOTNEWLINEMODE
//    CPY SIZE
//    BNE INDEXNESIZE
//    SFTODODOSTUFF
//    JMP LOOP1
//INDEXNESIZE
//    LDA LEN
//    ORA LEN+1
//    BNE LOOP2
//
//    
//    
//DONE
//    SFTODO
//end

// SFTODONOW: PROBABLY WANT TO REWRITE AT LEAST THE CORE PART OF THIS IN ASSEMBLER
// LATER ON, OF COURSE (AND SAME FOR acwrite())
// SFTODO: DO I NEED TO BE CLEVER TO ALLOW READ AND WRITE ON THE SAME OPEN FILE?
//def acreadSFTODOOLD(refnum, buf, len)
//    word iobuf, origlen, buffer
//    byte index, size, flags, emask, nlchar, stop, c
//
//    iobuf = @iobuf_array + (refnum-1)*t_iobuf
//
//    origlen = len
//
//    buffer = iobuf=>s_addr
//    index = iobuf->s_index
//    size = iobuf->s_size
//    flags = iobuf->s_flags
//    emask = iobuf->s_emask
//    nlchar = iobuf->s_nlchar
//
//    while len <> 0
//        if flags
//            if flags & FLAG_EMPTY
//                index = 0
//                size, flags = fillbuf(iobuf)
//                // This may have set flags to EOF, which is why the following
//                // 'if' is not 'elsif'.
//            fin
//            if flags & FLAG_EOF
//                break 
//            fin
//        fin
//
//        stop = FALSE
//        repeat
//
//            // SFTODO: In PLASMA it would probably be more efficient to set
//            // buffer = buffer + index at start and just do ^buffer here, but
//            // when this gets translated to assembly index will be the Y
//            // register so this will be the natural way to express it.
//            c = ^(buffer + index)
//            ^buf = c
//            //putc('X'); putc(c) // SFTODO
//            buf++
//            len--
//            index++
//
//            if emask <> 0 and ((c & emask) == nlchar)
//                stop = TRUE
//                break
//            fin
//        until len == 0 or index == size
//
//        if index == size
//            // We've exhausted our buffer.
//            if size <> 0
//                // The last fillbuf() read less than IOBUF_MAX_SIZE bytes, so we
//                // know any subsequent read would return 0 bytes and we're therefore
//                // at EOF now.
//                flags = FLAG_EOF
//            else
//                // The last fillbuf() read IOBUF_MAX_SIZE bytes, so we want to try
//                // another read.
//                flags = FLAG_EMPTY
//            fin
//        fin
//
//        if stop or len == 0 // SFTODO: CAN'T WE MAKE THIS THE WHILE CONDITION?
//            break
//        fin
//    loop
//
//    iobuf->s_index = index
//    iobuf->s_size = size
//    iobuf->s_flags = flags
//
//    perr = 0 // SFTODO: SHOULD WE EVER RETURN WITH perr = $4C (EOF)?
//    return origlen - len
//end

def acwrite(refnum, buf, len)
    word iobuf, origlen, buffer, chunk_size
    byte size

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    origlen = len
    buffer = iobuf=>s_addr
    size = iobuf->s_size

    while len > 0
        chunk_size = IOBUF_MAX_SIZE - size
        if chunk_size > len
            chunk_size = len
        fin
        memcpy(buffer + size, buf, chunk_size)
        buf = buf + chunk_size
        len = len - chunk_size
        size = size + chunk_size

        // SFTODO: NEXT LINE (AND MAYBE OTHERS) MAY FAIL DUE TO OPTIMISER
        // WIDENING SOME "BYTE" OPERATIONS - ASSUMING WE DECIDE TO KEEP THIS
        // BEHAVIOUR AND DOCUMENT IT, THIS CODE NEEDS TO BE WRITTEN TO COPE (AND
        // PUT COMMENTS IN) - OF COURSE WE COULD SIMPLY USE 'WORD' INSTEAD OF
        // 'BYTE' IF WE KNOW THIS ISN'T GOING TO BE CONVERTED TO ASM AND WON'T
        // BENEFIT FROM BYTE MUCH/AT ALL ANYWAY
        if size == 0 // i.e. effectively IOBUF_MAX_SIZE
            flushbuf(iobuf, IOBUF_MAX_SIZE)
            iobuf->s_flags = 0
        else
            iobuf->s_flags = FLAG_DIRTY
        fin
    loop

    iobuf->s_size = size
    return origlen // SFTODONOW NEEDS TO RETURN SMALLER VALUE IF ERROR OCCURS
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    stocr(path, @pathcr)

    // SFTODO: I am not sure if this should truncate a file which doesn't exist;
    // currently it will, because that's what osfind_output does. I don't know
    // what the Apple implementation will do in this case.
    refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
    if refnum == 0
        // SFTODO: Can this happen? Let's assume it can for now. We failed to
        // create the file.
        perr = 1 // SFTODO!?
    else
        // We successfully created the file; now close the handle.
        // SFTODO: This is a bit inefficient and might add to the sluggishness
        // of file I/O, especially on a real disc. Not sure we can do much about
        // it, but just possibly we could keep the file open in anticipation of
        // a subsequent fileio:open() with the same path.
        call(osfind, osfind_close, 0, refnum, 0)
        perr = 0
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0
    return perr
end

def acnewline(refnum, emask, nlchar)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf
    iobuf->s_emask = emask
    iobuf->s_nlchar = nlchar
    perr = 0
    return perr
end

// This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27 // IOERR
    return perr
end

//SFTODOputs("FOO")
//SFTODOputi(iobuf_array[0])

SFTODOHACK=@acread
for SFTODOHACK2=0 to 3
    while ^SFTODOHACK <> $FF
        SFTODOHACK++
    loop
    if SFTODOHACK2==0
        ^SFTODOHACK = @iobuf_array
    elsif SFTODOHACK2==1
        ^SFTODOHACK = @iobuf_array >> 8
    elsif SFTODOHACK2==2
        ^SFTODOHACK = @fillbuf
    else
        ^SFTODOHACK = @fillbuf >> 8
    fin
    SFTODOHACK2++
next

done
