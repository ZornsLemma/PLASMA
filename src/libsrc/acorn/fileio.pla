// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

// SFTODO: I THINK I ACTUALLY DON'T WANT OR NEED THIS
const MODE_UNKNOWN = 0
const MODE_READ = 1
const MODE_WRITE = 2

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word geteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word newline
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acgetfileinfo(path, fileinfo), acgeteof(refnum), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acnewline(refnum, emask, nlchar), acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acgetfileinfo, @acgeteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy
word = @acnewline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES

//
// I/O buffers
//
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
// SFTODO: WE MAY WANT TO HAVE AN ARRAY OF STRUCTS HERE, RATHER THAN SEPARATE
// ARRAYS FOR EACH - THIS IS ARGUABLY CLEANER, AND I ALSO SUSPECT IT WOULD BE
// MORE CONVENIENT WHEN CONVERTING TO ASSEMBLER AS WE'D JUST PASS THE SINGLE
// STRUCT ADDRESS POINTER IN
const MAX_IOBUFS = 4
const IOBUF_MAX_SIZE = 256
byte iobuf0[IOBUF_MAX_SIZE]
byte iobuf_ref[MAX_IOBUFS]
byte iobuf_emask[MAX_IOBUFS]
byte iobuf_nlchar[MAX_IOBUFS]
word iobuf_addr[MAX_IOBUFS] = @iobuf0
byte iobuf_size[MAX_IOBUFS]
byte iobuf_index[MAX_IOBUFS] // SFTODO NOT SURE, FEELING MY WAY HERE
byte iobuf_mode[MAX_IOBUFS] // SFTODO: PROB DON'T NEED THIS

def acgetpfx(path)
    // SFTODO: I *think* the 'prefix' is the Apple equivalent of the 'current directory', but
    // I am not sure. For now let's just not support this and investigate later; we need to do
    // something that works with hierarchical and non-hierarchical file systems. It may be that
    // we can get away without supporting this and leave the Acorn filesystem to manage its
    // own concept of current directory.
    ^path = 0
    return path
end

def acsetpfx(path)
    // SFTODO: See acgetpfx()
    return path
end

def acgetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acgeteof(refnum)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

def aciobufs(iobufs)
    byte i
    word freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = 1 to MAX_IOBUFS-1
                if not iobuf_addr[i]
                    iobuf_addr[i] = heapalloc(IOBUF_MAX_SIZE)
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = 1 to MAX_IOBUFS-1
            iobuf_addr[i] = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

// SFTODO: THIS WILL NEED TO RETURN SOME KIND OF ERROR INDICATION AND WE MUST BE
// SURE TO CHECK IT - IT WILL PROBABLY NEED TO USE throw()/except()
// SFTODO: NOTE THE ARGUMENT IS A 0-BASED INDEX
// SFTODO: THIS COULD POSSIBLY RETURN iobuf_index[i], iobuf_size[i] - IT *MAY*
// BE HANDY FOR CALLERS
def fillbuf(i)#2
    byte block[osgbpb_block_size]

    block.0 = iobuf_ref[i]
    block:1 = iobuf_addr[i]
    block:3 = 0 // SFTODO?!
    block:5 = IOBUF_MAX_SIZE
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!?
    // SFTODO: MAYBE THIS DOESN'T NEED TO SET IOBUF_{INDEX,SIZE}, THE CALLER MAY
    // ALWAYS BE ABLE TO JUST SET ITS LOCAL INDEX/SIZE VARAIBLES USING OUR
    // RETURN VALUES
    if block:5 == IOBUF_MAX_SIZE // EOF
        return 3, 1
    fin
    return 0, ((IOBUF_MAX_SIZE - block:5) & $FF)
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i
    
    for i = 0 to MAX_IOBUFS-1
        if iobuf_addr[i] and not iobuf_ref[i]            
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            iobuf_ref[i] = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            iobuf_emask[i] = 0
            iobuf_mode[i] = MODE_UNKNOWN
            // SFTODO: IT DOESN'T REALLY MAKE SENSE TO CALL FILLBUF() HERE,
            // SINCE WE MAY BE GOING TO WRITE() TO THE FILE - WE PROBABLY GET
            // AWAY WITH IT MOST OF TIME IN PRACTICE AS WE WILL BE WRITING TO AN
            // EMPTY FILE, BUT IT'S NOT REALLY RIGHT
            // SFTODO fillbuf(i) // SFTODO: error handling
            // SFTODO: PERM COMMENT IF TRUE - we indicate starting state of
            // 'need to fill buffer' by setting index > size
            iobuf_index[i] = 2; iobuf_size[i] = 1
            return i + 1 // 0 indicates failure, so have to add 1
            // SFTODO: It just may be cheaper to makes the arrays 1 bigger and
            // waste the 0th element; think about it when code settles down
            // anyway. (We'd waste memory there, but save on code to adjust the
            // index between 1-based and 0-based here and in other functions.)
            // Or maybe we can use an adjusted base address
        fin
    next
    return 0
end

def acclose(refnum)
    refnum--
    if iobuf_ref[refnum]
        // SFTODO: This probably needs to flush the buffer if there are any
        // writes which we haven't yet sent to the file!
        call(osfind, osfind_close, 0, iobuf_ref[refnum], 0)
        iobuf_ref[refnum] = 0
        perr = 0 // SFTODO?
        return perr
    fin
    perr = $45
    return perr
end

// SFTODO: PROBABLY WANT TO REWRITE AT LEAST THE CORE PART OF THIS IN ASSEMBLER
// LATER ON, OF COURSE (AND SAME FOR acwrite())
// SFTODO: DO I NEED TO BE CLEVER TO ALLOW READ AND WRITE ON THE SAME OPEN FILE?
def acread(refnum, buf, len)
    word origlen, buffer
    byte index, size, emask, nlchar, stop, c

    refnum--

    origlen = len

    buffer = iobuf_addr[refnum]
    index = iobuf_index[refnum] // SFTODO: MAKE SURE TO WRITE BACK TO iobuf_index LATER
    size = iobuf_size[refnum]
    emask = iobuf_emask[refnum]
    nlchar = iobuf_nlchar[refnum]

    // SFTODO: IT WOULD BE GOOD IF INDEX AND SIZE COULD BE BYTES NOT WORDS (ESP
    // WITH A VIEW TO CONVERTING TO ASSEMBLER) - WE CAN PROBABLY INDICATE THE
    // TWO SPECIAL CASES OF "NO READ YET" AND "EOF" BY HAVING INDEX > SIZE AND
    // MAYBE HAVING THE VALUE OF INDEX INDICATE WHICH OF THE TWO CASES IT IS. WE
    // WOULD ALSO PROBABLY WANT TO FUDGE THINGS SO A SIZE OF 0 INDICATES 256
    // BYTES, WHICH MIGHT BE A BIT AWKWARD IN TERMS OF COMPARISONS (AT LEAST IN
    // PLASMA; IT MAY BE NATURALISH IN ASSEMBLER)

    // SFTODO: so maybe we say that except temporarily within this function, we
    // SFTODO

    while len <> 0
        if size <> 0 and index > size // SFTODO MUST USE UNSIGNED COMPARISON - WHAT WILL PLASM DO HERE FOR BYTES?
            if index == 2 // buffer needs to be filled
                index, size = fillbuf(refnum)
                // This may have set index > size and index == 3 to indicate
                // EOF, which is why the following 'if' is not 'elsif'. We know
                // index == 0 otherwise, so there's no chance of
                // misinterpreting index == 3 indicating an index of 3 into the
                // buffer.
            fin
            if index == 3 // EOF
                break 
            fin
        fin

        stop = FALSE
        repeat
            // SFTODO: In PLASMA it would probably be more efficient to set
            // buffer = buffer + index at start and just do ^buffer here, but
            // when this gets translated to assembly index will be the Y
            // register so this will be the natural way to express it.
            c = ^(buffer + index)
            ^buf = c
            buf++
            len--
            index++

            if emask <> 0 and ((c & emask) == nlchar)
                stop = TRUE
                break
            fin
        until len == 0 or index == size

        if index == size
            if size <> 0
                // The last fillbuf() read less than IOBUF_MAX_SIZE bytes, so we
                // know any subsequent read would return 0 bytes and we're therefore
                // at EOF now.
                index = 3; size = 1
            else
                // The last fillbuf() read IOBUF_MAX_SIZE bytes, so we want to try
                // another read.
                index = 2; size = 1
            fin
        fin

        if stop or len == 0
            break
        fin
    loop

    iobuf_index[refnum] = index
    iobuf_size[refnum] = size

    perr = 0 // SFTODO!?
    return origlen - len
end

// SFTODO: NEEDS TO USE A BUFFER BUT THIS SHOULD WORK IN MEANTIME SO I CAN
// CONCENTRATE ON GETTING READ WORKING
def acwrite(refnum, buf, len)
    byte block[osgbpb_block_size]

    block.0 = iobuf_ref[refnum - 1]
    block:1 = buf
    block:3 = 0 // SFTODO?!
    block:5 = len
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!?
    return len - block:5 // return number of bytes written
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    stocr(path, @pathcr)

    // SFTODO: I am not sure if this should truncate a file which doesn't exist;
    // currently it will, because that's what osfind_output does. I don't know
    // what the Apple implementation will do in this case.
    refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
    if refnum == 0
        // SFTODO: Can this happen? Let's assume it can for now. We failed to
        // create the file.
        perr = 1 // SFTODO!?
    else
        // We successfully created the file; now close the handle.
        // SFTODO: This is a bit inefficient and might add to the sluggishness
        // of file I/O, especially on a real disc. Not sure we can do much about
        // it, but just possibly we could keep the file open in anticipation of
        // a subsequent fileio:open() with the same path.
        call(osfind, osfind_close, 0, refnum, 0)
        perr = 0 // SFTODO!?
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0 // SFTODO!?
    return perr
end

def acnewline(refnum, emask, nlchar)
    refnum--
    iobuf_emask[refnum] = emask
    iobuf_nlchar[refnum] = nlchar
    perr = 0 // SFTODO!?
    return perr
end

// This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27 // IOERR
    return perr
end
