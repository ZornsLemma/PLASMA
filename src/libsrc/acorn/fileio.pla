// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word geteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word newline
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acgetfileinfo(path, fileinfo), acgeteof(refnum), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acnewline(refnum, emask, nlchar), acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acgetfileinfo, @acgeteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy
word = @acnewline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES

//
// I/O buffers SFTODO RENAME THIS COMMENTED SECTION?
//
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
const MAX_IOBUFS = 4
const IOBUF_MAX_SIZE = 256
byte iobuf0[IOBUF_MAX_SIZE]
struc t_iobuf
    word s_addr    // Pointer to IOBUF_MAX_SIZE bytes of space or 0
    byte s_handle  // Acorn OS file handle or 0
    byte s_size    // Bytes used at s_addr
    byte s_index   // Current position within s_addr
    byte s_flags   // Flags
    byte s_emask   // newline mode emask (0 = disabled)
    byte s_nlchar  // newline mode nlchar
end
const FLAG_DIRTY = $01
const FLAG_EOF   = $02
const FLAG_EMPTY = $04
// SFTODO: struct version gives 14856 bytes free in compiler compared to 14851
// free in older version, so it isn't "expensive" - current flags rewrite is
// now at 14865
word iobuf_array[t_iobuf * MAX_IOBUFS / 2] = @iobuf0

def acgetpfx(path)
    // SFTODO: I *think* the 'prefix' is the Apple equivalent of the 'current directory', but
    // I am not sure. For now let's just not support this and investigate later; we need to do
    // something that works with hierarchical and non-hierarchical file systems. It may be that
    // we can get away without supporting this and leave the Acorn filesystem to manage its
    // own concept of current directory.
    ^path = 0
    return path
end

def acsetpfx(path)
    // SFTODO: See acgetpfx()
    return path
end

def acgetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acgeteof(refnum)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

def aciobufs(iobufs)
    byte i
    word iobuf, freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
                iobuf = @iobuf_array + i
                if not iobuf=>s_addr
                    //SFTODOputs("ALLOC")
                    iobuf=>s_addr = heapalloc(IOBUF_MAX_SIZE)
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = t_iobuf to (MAX_IOBUFS-1)*t_iobuf step t_iobuf
            iobuf = @iobuf_array + i
            iobuf=>s_addr = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

// SFTODONOW: THIS WILL NEED TO RETURN SOME KIND OF ERROR INDICATION AND WE MUST BE
// SURE TO CHECK IT - IT WILL PROBABLY NEED TO USE throw()/except()
// SFTODO: NOTE THE ARGUMENT IS A 0-BASED INDEX
// SFTODO: THIS HAS ONLY ONE CALLER, *BUT* SINCE THE FINAL VERSION WILL PROBABLY
// WANT TO USE EXCEPT()/THROW() WE KEEP IT SEPARATE SO A FINAL ASSEMBLY LANGUAGE
// IMPLEMENTATION CAN CALL BACK INTO PLASM TO HANDLE THAT FIDDLY STUFF
def fillbuf(iobuf)#2
    byte block[osgbpb_block_size]
    //SFTODOputs("FILLBUF")

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0 // SFTODO: almost certainly fine/correct
    block:5 = IOBUF_MAX_SIZE
    block:7 = 0
    call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO: maybe this doesn't need to set perr itself
    if block:5 == IOBUF_MAX_SIZE // EOF
        return 3, 1
    fin
    return 0, ((IOBUF_MAX_SIZE - block:5) & $FF)
end

// SFTODO: ARG IS 0-BASED
// SFTODONOW: THIS WILL EVENTUALLY NEED TO RETURN AN ERROR INDICATOR WHICH CALLER
// MUST CHECK
def flushbuf(iobuf, size)#0
    byte block[osgbpb_block_size]

    block.0 = iobuf->s_handle
    block:1 = iobuf=>s_addr
    block:3 = 0 // SFTODO?! almost certainly fine/correct
    block:5 = size
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!? MAYBE THIS DOESN'T NEED TO SET PERR ITSELF
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i
    word iobuf
    
//SFTODOputs("FOO2 ")
//SFTODOputi(iobuf_array[0])
    for i = 0 to MAX_IOBUFS-1
        iobuf = @iobuf_array + i*t_iobuf
        //SFTODOputs("i "); puti(i); puts(" "); puti(iobuf=>s_addr); puts(" "); puti(iobuf->s_handle);putln()
        if iobuf=>s_addr and not iobuf->s_handle
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            iobuf->s_handle = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            iobuf->s_emask = 0
            // SFTODO: PERM COMMENT IF TRUE - we indicate starting state of
            // 'need to fill buffer' by setting index > size and index == 2
            iobuf->s_index = 0
            iobuf->s_size = 0
            iobuf->s_flags = FLAG_EMPTY
            return i + 1 // 0 indicates failure, so have to add 1
            // SFTODONOW: It just may be cheaper to makes the arrays 1 bigger and
            // waste the 0th element; think about it when code settles down
            // anyway. (We'd waste memory there, but save on code to adjust the
            // index between 1-based and 0-based here and in other functions.)
            // Or maybe we can use an adjusted base address
        fin
    next
    //SFTODOputs("OPENFAIL")
    return 0
end

def acclose(refnum)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    // We allow the same file to be closed multiple times (the Apple II
    // implementation seems to allow this), but if you try to read() or write()
    // after closing that will have undefined results.
    if iobuf->s_handle
        if iobuf->s_flags & FLAG_DIRTY
            flushbuf(iobuf, iobuf->s_size)
        fin
        call(osfind, osfind_close, 0, iobuf->s_handle, 0)
        iobuf->s_handle = 0
        perr = 0
        return perr
    fin
    perr = $45
    return perr
end

//asm SFTODOSKETCHREAD(refnum, buf, len)
//    STRUCTPTR = SCRATCH ; 2 bytes
//    LEN = SCRATCH+2 ; 2 bytes
//    INDEX = SCRATCH+4 ; 1 byte
//    ; SFTODO Pretending we have struct-based data and we've got our address in
//    ; STRUCTPTR
//    ; SFTODO Pretending buf argument is in DST
//    ; SFTODO Pretending len argument is in LEN
//    ; SFTODO Pretending index struct elem copied to INDEX
//    ; SFTODO Pretending ADDR is pointer to iobuf_addr
//
//LOOP1
//    LDA LEN
//    ORA LEN+1
//    BEQ LOOP1DONE
//    ; SFTODO WE COULD WORK WITH A 'LOCAL' ZP COPY OF FLAGS IF IT WOULD HELP
//    LDY #FLAGSOFFSET
//    LDA (STRUCTPTR),Y
//    BPL NOTSPECIALFLAG
//    SFTODOHANDLE WHAT IS INDEX=2/3 CASE IN PLASMA CODE
//NOTSPECIALFLAG
//LOOP2
//    LDA LEN
//    BNE +
//    DEC LEN+1
//+   DEC LEN
//    LDY INDEX
//    LDA (ADDR),Y
//    INY
//    STY INDEX
//    LDY #0 ; SFTODO: OR WE COULD KEEP X=0 AND USE STA (ZP,X) IN NEXT LINE?
//    STA (DST),Y
//    INC DST
//    BNE +
//    INC DST+1
//+   LDY EMASK
//    BEQ NOTNEWLINEMODE
//    AND EMASK
//    CMP NLCHAR
//    BEQ NEWLINEMATCH
//NOTNEWLINEMODE
//    CPY SIZE
//    BNE INDEXNESIZE
//    SFTODODOSTUFF
//    JMP LOOP1
//INDEXNESIZE
//    LDA LEN
//    ORA LEN+1
//    BNE LOOP2
//
//    
//    
//DONE
//    SFTODO
//end

// SFTODONOW: PROBABLY WANT TO REWRITE AT LEAST THE CORE PART OF THIS IN ASSEMBLER
// LATER ON, OF COURSE (AND SAME FOR acwrite())
// SFTODO: DO I NEED TO BE CLEVER TO ALLOW READ AND WRITE ON THE SAME OPEN FILE?
def acread(refnum, buf, len)
    word iobuf, origlen, buffer
    byte index, size, emask, nlchar, stop, c

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    origlen = len

    buffer = iobuf=>s_addr
    index = iobuf->s_index
    size = iobuf->s_size
    emask = iobuf->s_emask
    nlchar = iobuf->s_nlchar

    while len <> 0
        if iobuf->s_flags
            if iobuf->s_flags & FLAG_EMPTY
                iobuf->s_flags = 0
                index, size = fillbuf(iobuf)
                // This may have set flags to EOF, which is why the following
                // 'if' is not 'elsif'.
            fin
            if iobuf->s_flags & FLAG_EOF
                break 
            fin
        fin

        stop = FALSE
        repeat

            // SFTODO: In PLASMA it would probably be more efficient to set
            // buffer = buffer + index at start and just do ^buffer here, but
            // when this gets translated to assembly index will be the Y
            // register so this will be the natural way to express it.
            c = ^(buffer + index)
            ^buf = c
            //putc('X'); putc(c) // SFTODO
            buf++
            len--
            index++

            if emask <> 0 and ((c & emask) == nlchar)
                stop = TRUE
                break
            fin
        until len == 0 or index == size

        if index == size
            if size <> 0
                // The last fillbuf() read less than IOBUF_MAX_SIZE bytes, so we
                // know any subsequent read would return 0 bytes and we're therefore
                // at EOF now.
                iobuf->s_flags = FLAG_EOF
            else
                // The last fillbuf() read IOBUF_MAX_SIZE bytes, so we want to try
                // another read.
                iobuf->s_flags = FLAG_EMPTY
            fin
        fin

        if stop or len == 0
            break
        fin
    loop

    iobuf->s_index = index
    iobuf->s_size = size

    perr = 0 // SFTODO: SHOULD WE EVER RETURN WITH perr = $4C (EOF)?
    return origlen - len
end

def acwrite(refnum, buf, len)
    word iobuf, origlen, buffer, chunk_size
    byte size

    iobuf = @iobuf_array + (refnum-1)*t_iobuf

    origlen = len
    buffer = iobuf=>s_addr
    size = iobuf->s_size

    while len > 0
        chunk_size = IOBUF_MAX_SIZE - size
        if chunk_size > len
            chunk_size = len
        fin
        memcpy(buffer + size, buf, chunk_size)
        buf = buf + chunk_size
        len = len - chunk_size
        size = size + chunk_size

        // SFTODO: NEXT LINE (AND MAYBE OTHERS) MAY FAIL DUE TO OPTIMISER
        // WIDENING SOME "BYTE" OPERATIONS - ASSUMING WE DECIDE TO KEEP THIS
        // BEHAVIOUR AND DOCUMENT IT, THIS CODE NEEDS TO BE WRITTEN TO COPE (AND
        // PUT COMMENTS IN) - OF COURSE WE COULD SIMPLY USE 'WORD' INSTEAD OF
        // 'BYTE' IF WE KNOW THIS ISN'T GOING TO BE CONVERTED TO ASM AND WON'T
        // BENEFIT FROM BYTE MUCH/AT ALL ANYWAY
        if size == 0 // i.e. effectively IOBUF_MAX_SIZE
            flushbuf(iobuf, IOBUF_MAX_SIZE)
            iobuf->s_flags = 0
        else
            iobuf->s_flags = FLAG_DIRTY
        fin
    loop

    iobuf->s_size = size
    return origlen // SFTODONOW NEEDS TO RETURN SMALLER VALUE IF ERROR OCCURS
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    stocr(path, @pathcr)

    // SFTODO: I am not sure if this should truncate a file which doesn't exist;
    // currently it will, because that's what osfind_output does. I don't know
    // what the Apple implementation will do in this case.
    refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
    if refnum == 0
        // SFTODO: Can this happen? Let's assume it can for now. We failed to
        // create the file.
        perr = 1 // SFTODO!?
    else
        // We successfully created the file; now close the handle.
        // SFTODO: This is a bit inefficient and might add to the sluggishness
        // of file I/O, especially on a real disc. Not sure we can do much about
        // it, but just possibly we could keep the file open in anticipation of
        // a subsequent fileio:open() with the same path.
        call(osfind, osfind_close, 0, refnum, 0)
        perr = 0
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0
    return perr
end

def acnewline(refnum, emask, nlchar)
    word iobuf

    iobuf = @iobuf_array + (refnum-1)*t_iobuf
    iobuf->s_emask = emask
    iobuf->s_nlchar = nlchar
    perr = 0
    return perr
end

// This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27 // IOERR
    return perr
end

//SFTODOputs("FOO")
//SFTODOputi(iobuf_array[0])
done
