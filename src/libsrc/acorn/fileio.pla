// Acorn implementation of fileio API

// http://www.easy68k.com/paulrsm/6502/PDOS8TRM.HTM looks like a good reference
// for Apple ProDOS.

// SFTODO: When we make OS calls, we probably need to wrap them in code which
// uses setjmp() on *errjb (saving the previous value) so we can return an error
// code to the caller instead of allowing any OS errors to escape. This may also
// require considering if we can continue to share the same page for the command
// line and errors - I think the plasm compiler will support this (it copies the
// command line arguments away before it uses them, so any error wouldn't
// trample on them) but perhaps this is error prone.

include "inc/cmdsys.plh"
include "inc/cmdsysac.plh"
include "inc/acornc.plh"

// SFTODO: This is a hack, it needs to be 255 or 256 bytes and that means we
// need to use callalloca to allocate a temporary buffer. But for now let's just
// go with this until things are otherwise working.
const maxpathlen = 128

//
// External interface
//
struc t_fileio
    word getpfx
    word setpfx
    word getfileinfo
    word geteof
    word iobufalloc
    word open
    word close
    word read
    word write
    word create
    word destroy
    word newline
    word readblock
    word writeblock
end

//
// Predefined functions
//
predef acgetpfx(path), acsetpfx(path), acgetfileinfo(path, fileinfo), acgeteof(refnum), aciobufs(iobufs), acopen(path), acclose(refnum)
predef acread(refnum, buf, len), acwrite(refnum, buf, len), accreate(path, type, aux), acdestroy(path)
predef acnewline(refnum, emask, nlchar), acblock(unit, buf, block)

//
// Exported function table.
//
word fileio[]
word = @acgetpfx, @acsetpfx, @acgetfileinfo, @acgeteof, @aciobufs, @acopen, @acclose
word = @acread, @acwrite, @accreate, @acdestroy
word = @acnewline
word = @acblock // readblock
word = @acblock // writeblock

//
// Globally accessible error code
//
export byte perr // SFTODO MAKE SURE I UPDATE THIS AS APPROPRIATE AND WITH APPLE-COMPATIBLE VALUES

//
// I/O buffers
//
// We always support at least one I/O buffer without needing to call
// iobufalloc(); this is consistent with the Apple implementation. 
// SFTODO: WE MAY WANT TO HAVE AN ARRAY OF STRUCTS HERE, RATHER THAN SEPARATE
// ARRAYS FOR EACH - THIS IS ARGUABLY CLEANER, AND I ALSO SUSPECT IT WOULD BE
// MORE CONVENIENT WHEN CONVERTING TO ASSEMBLER AS WE'D JUST PASS THE SINGLE
// STRUCT ADDRESS POINTER IN
const MAX_IOBUFS = 4
const IOBUF_SIZE = 256
byte iobuf0[IOBUF_SIZE]
byte iobuf_ref[MAX_IOBUFS]
byte iobuf_emask[MAX_IOBUFS]
byte iobuf_nlchar[MAX_IOBUFS]
word iobuf_addr[MAX_IOBUFS] = @iobuf0
word iobuf_index[MAX_IOBUFS] // SFTODO NOT SURE, FEELING MY WAY HERE

// SFTODO: MASSIVE HACK - VERY WASTEFUL OF RAM IF NOTHING ELSE - DELETE ONCE
// FINISHED REWRITING CODE AS WE NOW HOAVE IOBUF_{REF,EMASK}
byte newline_emask[256]
byte newline_nlchar[256]

def acgetpfx(path)
    // SFTODO: I *think* the 'prefix' is the Apple equivalent of the 'current directory', but
    // I am not sure. For now let's just not support this and investigate later; we need to do
    // something that works with hierarchical and non-hierarchical file systems. It may be that
    // we can get away without supporting this and leave the Acorn filesystem to manage its
    // own concept of current directory.
    ^path = 0
    return path
end

def acsetpfx(path)
    // SFTODO: See acgetpfx()
    return path
end

def acgetfileinfo(path, fileinfo)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    perr = $01
    return perr
end

def acgeteof(refnum)
    // SFTODO: We can almost certainly implement this but we can get away
    // without it for now.
    return 0
end

def aciobufs(iobufs)
    byte i
    word freebuf

    freebuf = heapmark()

    if iobufs > MAX_IOBUFS
        iobufs = MAX_IOBUFS
    fin
    if iobufs
        iobufs-- // Subtract off always-allocated I/O buffer (iobuf0)
        if iobufs
            for i = 1 to MAX_IOBUFS-1
                if not iobuf_addr[i]
                    iobuf_addr[i] = heapalloc(IOBUF_SIZE)
                    iobufs--
                    if not iobufs
                        return freebuf
                    fin
                fin
            next
            return freebuf
        fin
    else
        for i = 1 to MAX_IOBUFS-1
            iobuf_addr[i] = 0 // Free I/O buffers if 0 passed in
        next
    fin
    return 0
end

def acopen(path)
    byte pathcr[maxpathlen]
    byte i, refnum
    
    for i = 0 to MAX_IOBUFS-1
        if iobuf_addr[i] and not iobuf_ref[i]            
            stocr(path, @pathcr)
            // We use osfind_update; this allows both read and write access but won't
            // create a file which doesn't already exist. fileio::create() is provided
            // to create new files prior to opening them.
            refnum = call(osfind, osfind_update, @pathcr, @pathcr >> 8, 0).0
            iobuf_ref[i] = refnum
            iobuf_emask[i] = 0
            iobuf_index[i] = 0
            iobuf_size[i] = -1
            return i + 1 // 0 indicates failure, so have to add 1
            // SFTODO: It just may be cheaper to makes the arrays 1 bigger and
            // waste the 0th element; think about it when code settles down
            // anyway. (We'd waste memory there, but save on code to adjust the
            // index between 1-based and 0-based here and in other functions.)
            // SFTODO: WE SHOULD QUITE POSSIBLY FILL THE BUFFER WITH AN INITIAL
            // READ HERE - THE DRIVE MOTOR IS RUNNING AND IT'S A REASONABLE
            // GUESS WE INTEND TO READ FROM THE FILE GIVEN WE JUST OPENED IT,
            // AND THIS WOULD ALSO AVOID THE NEED FOR A WAY TO RECORD 'WE DO NOT
            // YET HAVE ANYTHING READ INTO THE BUFFER'
        fin
    next
    return 0
end

def acclose(refnum)
    --refnum
    if iobuf_ref[refnum]
        // SFTODO: This probably needs to flush the buffer if there are any
        // writes which we haven't yet sent to the file!
        call(osfind, osfind_close, 0, iobuf_ref[refnum], 0)
        iobuf_ref[refnum] = 0
        perr = 0 // SFTODO?
        return perr
    fin
    perr = $45
    return perr
end

// SFTODO: PROBABLY WANT TO REWRITE AT LEAST THE CORE PART OF THIS IN ASSEMBLER
// LATER ON, OF COURSE (AND SAME FOR acwrite())
// SFTODO: DO I NEED TO BE CLEVER TO ALLOW READ AND WRITE ON THE SAME OPEN FILE?
def acread(refnum, buf, len)
    --refnum

    count = 0
    buffer = iobuf_addr[refnum]
    index = iobuf_index[refnum] // SFTODO: MAKE SURE TO WRITE BACK TO iobuf_index LATER
    size = iobuf_size[refnum]
    emask = iobuf_emask[refnum]
    nlchar = iobuf_nlchar[refnum]

    // SFTODO: IT WOULD BE GOOD IF INDEX AND SIZE COULD BE BYTES NOT WORDS (ESP
    // WITH A VIEW TO CONVERTING TO ASSEMBLER) - WE CAN PROBABLY INDICATE THE
    // TWO SPECIAL CASES OF "NO READ YET" AND "EOF" BY HAVING INDEX > SIZE AND
    // MAYBE HAVING THE VALUE OF INDEX INDICATE WHICH OF THE TWO CASES IT IS. WE
    // WOULD ALSO PROBABLY WANT TO FUDGE THINGS SO A SIZE OF 0 INDICATES 256
    // BYTES, WHICH MIGHT BE A BIT AWKWARD IN TERMS OF COMPARISONS (AT LEAST IN
    // PLASMA; IT MAY BE NATURALISH IN ASSEMBLER)

    while len > 0
        while len > 0 and index < size // SFTODO NOTE SPECIAL CASE index < size OF 0 < -1 IF/WHEN CONVERT TO
        // ASSEMBLER - THIS OCCURS WHEN FILE HAS JUST BEEN OPENED
            c = buffer[index]
            ^buf = c
            buf++
            // SFTODO: POSSIBLY WE DON'T NEED COUNT - WE CAN RECORD THE ORIGINAL
            // LEN AND *MAYBE* (IF WE DON'T FORCE IT TO 0 TO BREAK OUT OF THE
            // NESTED LOOPS) COUNT = ORIGLEN-FINALLEN - THAT WAY WE SAVE ON WORK
            // INSIDE THIS INNER LOOP
            count++
            len--
            index++

            if emask != 0 and ((c & emask) == nlchar)
                len = 0
                break // SFTODO: ACTUALLY REDUNDANT?
            fin
        loop

        if len == 0
            perr = 0 // SFTODO!?
            return count
        fin

        // SFTODO: This way of recording EOF is probably fine, but think about
        // it later - we don't want to make another call to OSGBPB as it will
        // (probably; I haven't checked) provoke an OS "EOF" error. Actually,
        // this might not work - if we try to read 40 bytes and there are only
        // 30 bytes, that *might* be supposed to notify us of EOF and a
        // subsequent OSGBPB will generate EOF OS error instead of returning 0
        // bytes read. Even if that works reliably, ideally we wouldn't make a
        // second OSGBPB call in that case anyway - but by using size == -1 to
        // track this we can't record it. Maybe size < IOBUF_SIZE should
        // indicate EOF? OK, am trying that - but we need to have a way to
        // indicate buffer is empty because we haven't read yet, so I am using
        // -1 for that.
        if size < IOBUF_SIZE and size != -1
            perr = 0 // SFTODO?
            return 0
        fin

        // SFTODO REFILL THE BUFFER - TRY TO READ IOBUF_SIZE BYTES
        index = 0
        size = SFTODO
    loop

    perr = 0 // SFTODO!?
    return count





// SFTODO OLD BELOW HERE
    byte block[osgbpb_block_size]
    byte emask
    byte nlchar
    word linelen
    word result
    byte c

    // SFTODO: Do we need to check if we've already seen EOF and just return 0
    // if so? I think otherwise a subsequent read could cause an OS EOF error.
    // I don't know how the Apple implementation would behave in this case; in
    // practice the self-hosted PLASMA compiler at least never tries to do this.
    // SFTODO: This implementation is ridiculous, but it should work - can look
    // into optimising speed and space later on. (Note that the fileio API
    // doesn't seem to offer any seek options, which should simplify buffering
    // internally when using newline mode to read a file line by line.)
    emask = newline_emask[refnum]
    if emask <> 0
        nlchar = newline_nlchar[refnum]
        linelen = 0
        while linelen < len
            // SFTODO: At the very least we should be using machine code to call
            // OSBGET. There's an implementation in acornos.plh. But would
            // probably write this whole fn in assembler, and/or use a different
            // strategy.
            result = call(osbget, 0, 0, refnum, 0)
            if result->3 & 1 // SFTODO: MAGIC NUMBER - WE ARE TESTING C - BUT IF THIS LIVES WE WILL USE ASSEMBLER ANYWAY
                break
            fin
            c = result->0
            ^buf = c
            buf++
            linelen++
            if (c & emask) == nlchar
                break
            fin
        loop
        perr = 0 // SFTODO!?
        return linelen
    else
        block.0 = refnum
        block:1 = buf
        block:3 = 0 // SFTODO?!
        block:5 = len
        block:7 = 0
        call(osgbpb, osgbpb_read_ignoring_new_ptr, @block, @block >> 8, 0)
        // SFTODO: eof[refnum] = (block:5 <> 0) - unless we will query this via some
        // other OS interface
        perr = 0 // SFTODO!?
        return len - block:5 // return number of bytes read
    fin
end

// SFTODO: NEEDS TO USE A BUFFER BUT THIS SHOULD WORK IN MEANTIME SO I CAN
// CONCENTRATE ON GETTING READ WORKING
def acwrite(refnum, buf, len)
    byte block[osgbpb_block_size]

    block.0 = iobuf_ref[refnum - 1]
    block:1 = buf
    block:3 = 0 // SFTODO?!
    block:5 = len
    block:7 = 0
    call(osgbpb, osgbpb_write_ignoring_new_ptr, @block, @block >> 8, 0)
    perr = 0 // SFTODO!?
    return len - block:5 // return number of bytes written
end

def accreate(path, type, aux)
    byte pathcr[maxpathlen]
    byte refnum

    stocr(path, @pathcr)

    // SFTODO: I am not sure if this should truncate a file which doesn't exist;
    // currently it will, because that's what osfind_output does. I don't know
    // what the Apple implementation will do in this case.
    refnum = call(osfind, osfind_output, @pathcr, @pathcr >> 8, 0).0
    if refnum == 0
        // SFTODO: Can this happen? Let's assume it can for now. We failed to
        // create the file.
        perr = 1 // SFTODO!?
    else
        // We successfully created the file; now close the handle.
        // SFTODO: This is a bit inefficient and might add to the sluggishness
        // of file I/O, especially on a real disc. Not sure we can do much about
        // it, but just possibly we could keep the file open in anticipation of
        // a subsequent fileio:open() with the same path.
        call(osfind, osfind_close, 0, refnum, 0)
        perr = 0 // SFTODO!?
    fin
    return perr
end

def acdestroy(path)
    byte block[osfile_block_size]
    byte pathcr[maxpathlen]

    stocr(path, @pathcr)
    block:0 = @pathcr
    // SFTODO: This will return with A=0 if the object does not exist - do we
    // want to treat that as an error or not?
    call(osfile, osfile_delete_object, @block, @block >> 8, 0)
    perr = 0 // SFTODO!?
    return perr
end

def acnewline(refnum, emask, nlchar)
    newline_emask[refnum] = emask
    newline_nlchar[refnum] = nlchar
    perr = 0 // SFTODO!?
    return perr
end

// This function looks potentially lethal and the Apple I and ///
// implementations don't support it either. It would also probably require
// different code for DFS and ADFS. Let's hold off on this until a pressing
// use case comes up.
def acblock(unit, buf, block)
    perr = $27  // IOERR
    return perr
end
