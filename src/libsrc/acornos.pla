include "inc/cmdsys.plh"

const osfind_addr = $FFCE

// TODO: TEMP
byte hexchar[]    = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'

// oscli_cr(command_as_cr_string)
// TODO: Just use standard call() function?
asm oscli_cr
    BBC=1
    !SOURCE "vmsrc/plvmzp.inc"
    STX ESP
    LDY ESTKH,X
    LDA ESTKL,X
    TAX
    JSR $FFF7
    LDX	ESP
    RTS
end

// TODO: Inefficient, possibly rewrite in assembler
def stocr(str, cr)
    byte len, c
    len = ^str
    (cr).[len] = 13
    while len
	c = (str).[len]
	len = len - 1
	(cr).[len] = c
    loop
end

// oscli(str)
export def oscli(str)
    byte cr[200] // TODO: can we just allocate exactly required space?
    stocr(str, @cr)
    oscli_cr(@cr)
end

export def osfind_open(a, filename)
    byte cr[200] // TODO: can we just allocate exactly required space?
    stocr(filename, @cr)
    return call(a, @cr, @cr >> 8, 0, osfind_addr).0
end

// TODO: It's *probably* slightly smaller and definitely a bit faster to
// hand-roll assembly wrappers instead of using call(); perhaps do this
// once the API has settled down.
export def osfind_close(handle)
    call(0, 0, handle, 0, osfind_addr)
end

// TODO: Might be worth coding this in assembly for performance
export def osbget(handle)
    word result
    result = call(0, 0, handle, 0, $FFD7)
    if result->3 & 1
	return -1
    else
	return result->0
    fin
end

// vi: sts=4 sw=4
