PLASM = ./plasm
PLVMZP = vmsrc/plvmzp.inc

PLASMOBJS = toolsrc/plasm.c toolsrc/parse.c toolsrc/lex.c toolsrc/codegen.c
PLASMINCS = toolsrc/plasm.h toolsrc/tokens.h toolsrc/symbols.h toolsrc/lex.h toolsrc/parse.h toolsrc/codegen.h

# Compiled PLASMA modules go into $(REL); the intermediate assembly files go into
# $(RELINT). These are port-specific - even if the source is common to all ports,
# it may contain assembly language which references zero page addresses that vary
# between ports.
REL = rel/$(PORT)/
RELINT = $(REL)int/ # intermediate

# Assumption: we won't have two source files with the same name unless they are alternate
# versions for different ports. The pay off for this is that we can use VPATH to locate
# source files without any fuss, and we can just put all the compiled modules into a flat
# directory structure.

ALLSRC = $(SAMPLESRC) $(LIBSRC)
ALLOBJ = $(addprefix $(REL),$(patsubst %.pla,%.plm,$(ALLSRC)))

VPATH = toolsrc/$(PORT):toolsrc:libsrc/$(PORT):libsrc:samplesrc/$(PORT):samplesrc

rel/$(PORT)/%.plm: %.pla $(PLVMZP) $(PLASM)
	$(eval INT := $(addsuffix .s,$(addsuffix $(basename $(notdir $<)),$(RELINT))))
	$(PLASM) -AMOW < $< > $(INT)
	acme --setpc 4094 -o $@ $(INT)

$(PLVMZP):
	cd vmsrc && ln -sf $(PORT)/plvmzp.inc plvmzp.inc

#
# PLASMA compiler: plasm
#

$(PLASM): $(PLASMOBJS) $(PLASMINCS)
	cc $(PLASMOBJS) -o $(PLASM)

$(PLASMAPLASM): toolsrc/plasm.pla toolsrc/lex.pla toolsrc/parse.pla toolsrc/codegen.pla toolsrc/codeseq.plh $(PLVMZP) $(PLASM)

$(CODEOPT): toolsrc/codeopt.pla toolsrc/codeseq.plh


.PHONY: clean
clean: cleanport
	rm -f $(PLASM)
	rm -f $(PLVMZP)
	rm -rf rel


# These variables are assigned using ::= so they are simply expanded and the shell
# command will be executed immediately, before any rules are evaluated.
FORCERMPLVMZP ::= $(shell rm -f $(PLVMZP))
FORCEREL ::= $(shell mkdir -p $(REL))
FORCERELINT ::= $(shell mkdir -p $(RELINT))
