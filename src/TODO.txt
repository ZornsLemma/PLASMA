Sandbox

Add ability to dump memory free to PLASMA executable by issuing a command? (to
allow seeing how resident modules take up space) (Possibly just keep my
relocation of the memory free output from the startup banner to the prompt as a
permanent feature; this perhaps makes more sense on the BBC, where changing
mode and so forth can have a big impact on the free memory)

I started from the Apple I version; maybe port over features from the Apple II VM
and/or "redo" the port using the Apple II version to start with

Ability to build a standalone executable which runs from main RAM or sideways
ROM, so a PLASMA-implemented program can be used by a user without them knowing
or caring it's running on the PLASMA VM - though possibly the auto-start
facility is sufficient for main RAM use (this doesn't address the ROM case)

A language ROM version would have some value; this would free up more main RAM
for data and/or non-shadow screen on machines without a second processor
(PLAS128 doesn't help here). If running from sideways RAM the free space in the
bank could be made available to the running program - it would "nearly" be
suitable for use for code or data, although it would be paged out by the OS
during some OS calls so it would be brittle to allow it to be accessed
implicitly via the stack frame or heapalloc. We could have a "heapYalloc" but
that's perhaps a bit specialised. The alternative would be to use the remaining
space for bytecodes (PLAS128-style), and then we could fall back to allocating
bytecode space from main RAM if necessary (or if we're running from ROM).
Probably best to leave development of such a version until PLAS32 and PLAS128
are "finished" to avoid complexity of fixing bugs in three different places.
(An alternative possibility would be to pre-load some useful libraries as
resident modules, e.g. ACORNOS, into the sideways ROM so they're available
without importing them from disc into RAM. However, without a significant
quantity of well-tested, "frozen" libtrary code, there's not much value in
doing this, and it also raises the nasty possibility of needing to version
modules so you don't get stuck with v1 of FOO in the ROM when there's v2 of FOO
with some new feature you need on the disc.)

PLAS128 using 4x16K sideways RAM banks could *still* potentially page in a
fifth 16K bank when not fetching from "instruction space". This space couldn't
transparently be used for the normal heap or the frame stack because any
attempt to make an OS call using space allocated there could fail if another
ROM is temporarily paged in (most obviously a filing system). However, it could
be made available as a separate heap (say allocyheap() - not allocxheap(), as
that is the private heap used for the 64K data space) and code could call that
if it knows it will use the space returned for non-OS-call purposes. If
allocyheap() could fall back to using the normal heap if there is no 'Y' heap,
a program could with minimal extra effort be written to take advantage of this
extra 16K iff it's available. (You'd probably need to mark and release both the
normal and Y heaps at the same time, and releasing the Y heap would be a no-op
if it was actually just forwarding requests on to the normal heap.)

I'm not entirely happy with the idea, but it might be possible to have a small
separate heap explicitly for use with OS calls. Then it would be possible to
allow the "normal" heap to grow into sideways RAM (either a fifth bank in
PLAS128, or the one-and-only bank in the currently nonexistent language ROM
version) and it wouldn't cause any problems. I'd guess the parameter stack
should always remain in main RAM so local storage can be used to make OS calls
too. (Essentially, this idea is "offer the OS-safe guarantee only when code
asks for it", rather than the opposite "offer the OS-safe guarantee by default
and possibly offer a separate non-safe option for code to use if it wants".)

It might be possible to do something with the B+ special private 12K

On a 6502 second processor, we could relocate ourselves down to &500 (say)
instead of OSHWM=&800 if we aren't using all of the language workspace from
&400-&800 - though if we can productively use that space for something else it
would be best, since otherwise we are "wasting" that space on non-2P machines,
or we say "it's available for user code" and then that code is no longer
compatible with PLASMA-on-2P. Perhaps the best bet would be a deque-style
symbol table and we put the first block of the symbol table in the 2-3 pages of
this space we aren't using for other things.

A vim syntax highlighting mode for PLASMA code might be nice

It would probably be possible to produce a Matchbox co-pro specific version
which uses bank-switching PLAS128-style on the second processor.

Can we get any use out of the new ability to define the number of return values
of a PLASMA function? We could potentially save a bit of code by specifying 0
return values in some places.

It might be possible/easy to support cmorley's "OS RAM" module to allow larger
programs/data. One possibility which occurs to me is for the sideways ROM/RAM
version to detect a) first writable "high" location b) last writable "high"
location (allowing for such combinations as "ROM only" (-> no high RAM), "2nd
processor" (high RAM from &A800 or wherever "ROM" ends to &F800), "sideways
RAM" (high ram from &A800-ish to &C000), "OS RAM" (high ram from &C000 to
&FC00-ish), "sideways RAM+OS RAM" (high ram from &A800-ish to &FC00-ish) - the
detection would be easy to do in a modular fashion I think) and then that extra
RAM would automatically be available for bytecodes. Obviously this isn't the
most flexible as it doesn't allow data to be located in the new "OS RAM", but
it's one easy-ish possibility.

Can we optimise things like "ISGT:BRTRU XXX" to "BRGT XXX"? Check first to see that this doesn't happen already, but poking around the compiler I suspect it doesn't.

Might be worth trying to tweak the compiler to prefer to put constant
multipliers on the "rhs", so that if we teach the peephole optimiser to do "CB
2:MUL:ADD"->"IDXW" there's more chance of it being triggers. Not sure if it's
worth it but perhaps depends how hard it is. We could potentially even special
case the constant 2 in the compiler tweak to minimise impact. This is the last
remaining optimisation (in practice) of those implementated in optimise.py that
I am dubious about being able to implement in the compiler's non-hacky peephole
optimiser - optimise.py is quite sophisticated here and forms an expression
tree to allow it to reshuffle parts of the expression if that helps.

Use new "specify number of parameters and return type" support on standard
functions? At least on the Acorn-specific ones. Have done this for oserror() as
an initial foray.

Standalone version - *Possibly* we should cope if the main program returns, but arguably we shouldn't - the application is effectively a new language, so ther only sensible way to exit is to issue a * command and that's down to the app/its user. We should perhaps restart the program if this happens rather than hanging or crashing badly, but if it's difficult or it means keeping a lot of extra code around (e.g. a RET at the end of every _INIT, not that that's very expensive) then don't get too hung up about it.

Standalone version - 32cmd.a contains some crap which just isn't needed and could probably be relatively trivially made conditionally compiled in a "productionised" version of this. Possibly not exhaustive list:
- the symbol table with all its associated constants and symbol lookup/insertion code
- the string constants to support the (manually deleted) "init" code which handles the prompt loop
- loadmod()/execmod()
- dcitos() is probably redundant
- syscall()?
- prbyte()/prword()
- readfile()/high_order_address()
- strip*()
- modechange()

Standalone version - A "productionised" version would ideally do a topological sort on the dependencies of the modules being "linked" to make sure it links them in an acceptable order (this matters as the _INIT code must be executed in a suitable order). I think this is doable if we output a machine-readable comment in the compiler output in lieu of the equivalent "I am module X" and "I depend on module Y" binary data in a module.

Include the git revision/label as a string at the end of the executable (after the relocation data, if any) - that way it wouldn't take any memory up at runtime but would be visible on disc

I think you can load-execute-and-discard modules from other modules using modexec() etc library functions. Have a play with them - perhaps right a three module (base, "sort", "display") silly example where the base heap allocates a small array of ints and fills it with random data, then repeatedly calls sort (which does a single pass of bubble sort) and display (which shows the current state of the array) until finished. This might also test/prompt the addition of some means of getting the return value from a module; the "sort" module could return number of swaps done so base can tell when the sort is finished.

Possibly we could optimise foo = foo + 256 so it loads the high byte using LLB, INCR, then saves high byte using LLB - and similarly for foo = foo - 256. In fact, I guess as a general thing addition or subtracting of anythng where the low byte is 0 can be turned into a high byte operation, and then probably other peephole optimisation would automatically take care of using INCR/DECR if we are just adding or subtracting 1.

I don't think the optimiser handles things like 'foo = bar() + 2 + 3'; the 2 + 3 can obviously be folded to a 5 but this doesn't seem to happen.
