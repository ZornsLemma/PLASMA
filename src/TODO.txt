Sandbox

Add ability to dump memory free to PLASMA executable by issuing a command? (to
allow seeing how resident modules take up space) (Possibly just keep my
relocation of the memory free output from the startup banner to the prompt as a
permanent feature; this perhaps makes more sense on the BBC, where changing
mode and so forth can have a big impact on the free memory)

Ability to build a standalone sideways language ROM

A language ROM version would have some value; this would free up more main RAM
for data and/or non-shadow screen on machines without a second processor
(PLAS128 doesn't help here). If running from sideways RAM the free space in the
bank could be made available to the running program - it would "nearly" be
suitable for use for code or data, although it would be paged out by the OS
during some OS calls so it would be brittle to allow it to be accessed
implicitly via the stack frame or heapalloc. We could have a "heapYalloc" but
that's perhaps a bit specialised. The alternative would be to use the remaining
space for bytecodes (PLAS128-style), and then we could fall back to allocating
bytecode space from main RAM if necessary (or if we're running from ROM).
Probably best to leave development of such a version until PLAS32 and PLAS128
are "finished" to avoid complexity of fixing bugs in three different places.
(An alternative possibility would be to pre-load some useful libraries as
resident modules, e.g. ACORNOS, into the sideways ROM so they're available
without importing them from disc into RAM. However, without a significant
quantity of well-tested, "frozen" library code, there's not much value in
doing this, and it also raises the nasty possibility of needing to version
modules so you don't get stuck with v1 of FOO in the ROM when there's v2 of FOO
with some new feature you need on the disc.)

PLAS128 using 4x16K sideways RAM banks could *still* potentially page in a
fifth 16K bank when not fetching from "instruction space". This space couldn't
transparently be used for the normal heap or the frame stack because any
attempt to make an OS call using space allocated there could fail if another
ROM is temporarily paged in (most obviously a filing system). However, it could
be made available as a separate heap (say allocyheap() - not allocxheap(), as
that is the private heap used for the 64K data space) and code could call that
if it knows it will use the space returned for non-OS-call purposes. If
allocyheap() could fall back to using the normal heap if there is no 'Y' heap,
a program could with minimal extra effort be written to take advantage of this
extra 16K iff it's available. (You'd probably need to mark and release both the
normal and Y heaps at the same time, and releasing the Y heap would be a no-op
if it was actually just forwarding requests on to the normal heap.)

I'm not entirely happy with the idea, but it might be possible to have a small
separate heap explicitly for use with OS calls. Then it would be possible to
allow the "normal" heap to grow into sideways RAM (either a fifth bank in
PLAS128, or the one-and-only bank in the currently nonexistent language ROM
version) and it wouldn't cause any problems. I'd guess the parameter stack
should always remain in main RAM so local storage can be used to make OS calls
too. (Essentially, this idea is "offer the OS-safe guarantee only when code
asks for it", rather than the opposite "offer the OS-safe guarantee by default
and possibly offer a separate non-safe option for code to use if it wants".)

It might be possible to do something with the B+ special private 12K; a lightly
tweaked version of PLAS128 could treat it almost trivially as a 12K bank of
sideways RAM. I think such a version would be designed for a B+64K only (though
of course would work on a B+128K). Although I suppose if we made the 12K
private RAM the "last" RAM bank (preferring to pick full 16K banks first), we'd
just add 12K to the AUX size instead of 16K for that bank and it would all
"just work". I am not sure this is a high priority, and I'm a bit reluctant to
auto-detect and auto-use the 12K private RAM in case something else (e.g. the
B+ ROMmable version of MMFS) is using it; unlike a sideways RAM bank where
there's the OS ROM table, it's not really possible to simply and reliably test
if the private 12K is free for us or not.

A vim syntax highlighting mode for PLASMA code might be nice

It would probably be possible to produce a Matchbox co-pro specific version
which uses bank-switching PLAS128-style on the second processor.

Can we get any use out of the new ability to define the number of return values
of a PLASMA function? We could potentially save a bit of code by specifying 0
return values in some places.

It might be possible/easy to support cmorley's "OS RAM" module to allow larger
programs/data. One possibility which occurs to me is for the sideways ROM/RAM
version to detect a) first writable "high" location b) last writable "high"
location (allowing for such combinations as "ROM only" (-> no high RAM), "2nd
processor" (high RAM from &A800 or wherever "ROM" ends to &F800), "sideways
RAM" (high ram from &A800-ish to &C000), "OS RAM" (high ram from &C000 to
&FC00-ish), "sideways RAM+OS RAM" (high ram from &A800-ish to &FC00-ish) - the
detection would be easy to do in a modular fashion I think) and then that extra
RAM would automatically be available for bytecodes. Obviously this isn't the
most flexible as it doesn't allow data to be located in the new "OS RAM", but
it's one easy-ish possibility. (Not necessarily the optimal approach, but we
could potentially also use the B+'s private 12K here by detecting if we're
running as a language ROM in that 12K and setting the upper RAM boundary to
&8000+12K.)

Might be worth trying to tweak the compiler to prefer to put constant
multipliers on the "rhs", so that if we teach the peephole optimiser to do "CB
2:MUL:ADD"->"IDXW" there's more chance of it being triggers. Not sure if it's
worth it but perhaps depends how hard it is. We could potentially even special
case the constant 2 in the compiler tweak to minimise impact. This is the last
remaining optimisation (in practice) of those implementated in optimise.py that
I am dubious about being able to implement in the compiler's non-hacky peephole
optimiser - optimise.py is quite sophisticated here and forms an expression
tree to allow it to reshuffle parts of the expression if that helps.

Standalone version - A "productionised" version would ideally do a topological sort on the dependencies of the modules being "linked" to make sure it links them in an acceptable order (this matters as the _INIT code must be executed in a suitable order). I think this is doable if we output a machine-readable comment in the compiler output in lieu of the equivalent "I am module X" and "I depend on module Y" binary data in a module.

Include the git revision/label as a string at the end of the executable (after the relocation data, if any) - that way it wouldn't take any memory up at runtime but would be visible on disc

I don't think the optimiser handles things like 'foo = bar() + 2 + 3'; the 2 + 3 can obviously be folded to a 5 but this doesn't seem to happen. (Similar thing happens with trailing '*'; I suspect it applies to other operators too.)

It may be that the NOP_CODE I introduced in the optimiser to support remove_writes() could be used to good effect to simplify other existing bits of the optimiser code, allowing the fiddly 'delete opcode' logic to occur in just one place.

A 'reverse subtraction' opcode just might be useful; the thing to do would be
to try to add support to the peephole optimiser to try it out (it effectively
makes subtraction a commutative operation for the purposes of switching opcodes
round to possibly allow more use of DLB/DLW, for example)

Write a test program to check divmod() gives the right result in all cases

Can the peephole optimiser replace 'CALL divmod' with a DIVMOD opcode?

rogue.io.pla is now somewhat out of sync with upstream; I should probably look
into porting conio and using that. For now I have just left the older version
of the code in this port.

I think there were some invalid optimisations removed by upstream between merge5 and merge6; it would be good to look at what those were and if they were potentially desirable optimisations, look at allowing them to be reinstated.

Looking at the Youtube video of PLASMA, the lighted area in ROGUE should be shown in reverse video. This doesn't happen in this port - not sure if this is a new feature or something which I lost in my port.

Apple II version auto-patches in support for 65C02 instructions - I should look at enabling that for the Acorn port

Should I stop printing "PLASMA 01.00" (or whatever) every time an error occurs at the prompt? It wasn't really deliberate and doesn't add much, and makes stuff scroll off the screen unnecessarily.

It might be a good idea to produce "crunched" (no comment) versions of the inc/*.plh files for use with the self-hosting compiler to save disc space and speed up compilation

The PLASM self-hosted compiler sometimes seems to leave files open if an OS error occurs - can't blam eit because these currently throw() right out of its code into the main VM. However, one way or another it would be good if I could fix this up (if I do make fileio use except() to catch OS errors and turn them into error return values it would probably work, but I am dithering about doing that as it might effectively throw away useful information for the user)

Assuming I eventually port the JIT, make sure to port the 'sysflags nojitc' in various library modules from the Apple code (and add it to any Acorn-only code where it's appropriate)

See Dave's e-mail 15/05/18 - I could probably use his idea and have the heap start at the 'init' code, provided I arrange that any code which needs to do a heap allocation lives in a separate function. When running on a second processor this couldn't be done as we need to be able to re-init on BREAK, but that's probably fine - the 2P case is already handled differently for some other need-the-code-to-be-available-on-BREAK issue, I think.

Could the code density be improved with 8-bit displacement branch opcodes? Would need an optimiser capable of generating these. There are quite a few different branch instructions so may not be very practical, but maybe a few branch instructions account for most of the branches.

Self-hosted optimiser has assumption that no memory-mapped hardware exists above $D000; this will need fixing for Acorn port.

Random thought, possibly incoherent: if we guarantee EXTERNAL symbols come before ENTRY symbols in ESD, could we use that to discard ENTRY symbols from the symbol table once the module has been loaded and fixed up??

Suspect this is a duplicate - is there any possibility of speeding self-hosted compiler start time by making the "split-off" part of it stay memory resident after being loaded? We might need to do something to reinitialise any global variables each time. It does occur to me a different split which leaves the data/asm module in the caller module would sidestep the need for this reinitialisation, but I *suspect* (not tried it) that would prevent most things moving into the callee module at all and therefore the split would not be good enough for PLAS128 and even on tube the callee module would be so small the saving of having it resident would not be worth it.
- there may be something in this, but note that a huge part of the split self-hosted compiler startup time seems to be resolving symbols (not probed this in detail) after it starts up, there's a noticeable no-disk-activity pause which the non-split compiler doesn't have.
- it may be that tweaking the splitter to stop splitting earlier would help, given our actual constraint is main RAM needed to load the modules, not actually the split bytecode size

Is there any chance the plasmatool optimised self-hosted compiler will have a module small enough to load into PLAS128 without splitting? Annoyingly, while the bytecode is almost certainly small enough (the split version of the compiler runs with a single 16K bank), we need 24K-ish of free main RAM to *load* the module, and even on a Master with PAGE at &E00 and HIMEM at &8000 we don't have that much.

What happens if a modkeep module is JITted during execution of a non-modkeep module? Won't the JITted machine code be freed when the non-modkeep module ends but the deftbl entries will continue to point to that JITted code? Not tried this, just a thought. See what Apple does - maybe modkeep modules are marked ineligible for jitting explicitly or implicitly. Ask Dave if ultimately unsure.

Any chance I could speed up the PLASMA compiler a bit by modifying it to do equivalent of *SAVE on the output buffer? I haven't checked the code and it may be doing some dynamic generation of the output, just a thought.

A samplesrc program to print out command line arguments and their indices, one line at a time, would probably be useful for testing and a nice demo of how to use the arg parsing.

Would it be possible to modify the cross-compiler to allow asm fragments in the middle of bytecode functions? I think it would just have to emit a NATV opcode before the asm and then a JSR INTERP at the end of it. I guess this probably wouldn't work on PLAS128 (or Apple equivalent), and it wouldn't work with JIT either (though you could be forced to declare 'sysflags nojitc' to enable these asm fragments, which would sidestep that issue) - the PLAS128 thing is probably a killer though.

Could we optimise (probably in plasmatool) and recognise non-exported functions which are called only once and inline them? I suspect this might get tricky, since you'd have to make sure e.g. any early return from the inlined function went to the right place. Is it possible/helpful to use ENTER/LEAVE within a function??

Misc JIT thoughts:
- t_defentry is two bytes (7 vs 5) larger to support JIT; I'm reluctant to either make the size a variable instead of a constant or to waste two bytes per definition when not using the JIT in order to make it possible to have a "universal" VM. It might be possible to have a 'deftbl2' allocated to hold the extra two bytes only on demand (it would cross-correlate with 'deftbl' by array index) but I suspect that could get fiddly and might bloat the VM anyway.
- JIT seems to requre some additional space in page 4 to communicate between bits of code with, and this is also the sort of thing which isn't trivial to dynamically change in a single VM binary - OK, having a rough poke at the code, this in itself might be doable without too much complication or VM bloat (we'd just put these "last" and have the first symbol table chunk start on top of the JIT addresses in page 4 if no JIT loaded)
- cmd.pla will need systemflags support to handle nojitc option, that may want to be conditionally included only in a JIT-capable VM but it might not be so large we couldn't tolerate it in a single VM binary
- adddef() is also different for JIT
- I'm perhaps overly sensitive but given how relatively scarce memory is on say an unexpanded B/B+64K I am really trying to keep the core VM size down all the time. It *might* be possible to make a single VM which supports JIT and not JIT efficiently, but I suspect it's going to be a couple of hundred bytes larger - not much, but not nothing on a 32K B. While having multiple binaries built with conditional compilation is potentially confusing, from a PLASMA system dev perspective it's also probably less confusing than trying to have a binary which does the right thing in all cases with/without JIT.
- I have also been toying with creating separate builds (probably not right now) which use CMOS instructions. I'm reluctant to copy the Apple II approach of patching the binary at run time, because it feels error prone to me and it doesn't save any space, just speeds things up - that's fine on the Apple II where memory is plentiful, but not so much on the Acorn machines. OK, it's only a few bytes, but as I say there is a "convenience of system dev" argument for conditional compilation rather than clever patching at runtime. Actually having had a quick look at the plvmjit02.s file the way the CMOS code is patched in is relatively readable, and I do already have the concept of discardable initialisation code, so maybe I should consider doing this for CMOS. It's also the case the CMOS machines generally have more RAM of some form or another, so the code-size saving is not all that critical, though it would be nice to have.
- The trouble is we're getting a bit of an explosion of versions. {JIT,no JIT}x{NMOS,CMOS}x{flat,sideways RAM} is 8 versions. This isn't necessarily terrible but a hypothetical user has to know which one to choose. The trouble is so many of those combinations are useful. An unexpanded machine wants flat NMOS no-JIT, but a second processor wants flat CMOS with either JIT or no-JIT; the second processor has enough RAM for the JIT to be usable but not such plentiful RAM (especially since it's otherwise the largest data space available on any Acorn configuration, and we don't want to force the user to have a JIT burning some of it up) that we always want it. Any machine can have sideways RAM so we can't segregate NMOS/CMOS there. Just possibly we could drop the "no JIT, sideways RAM" version, but Dave's latest e-mail to me implies the JIT might be subtly buggy so it does seem a shame to force it on. Also a machine with only 16K SWR can usefully use the sideways RAM version, whereas the JIT takes 16K of sideways RAM by itself. (And if you want to run the self-hosted compiler, for example, no JIT requires 32K sideways RAM and the JIT pushes that up to 48K.)
- Actually as part of the above I had been considering splitting off a separate "HIPLASMA" rather than have the standard flat PLASMA be capable of taking advantage of second processor, but maybe this doesn't buy me very much. It would potentially allow me to load the VM at the top of memory where a language would normally reside, but I'm not sure that's a huge win. Perhaps the main advantage of a "HIPLASMA" is it would be one small place where we could just assume CMOS is supported, but that wouldn't stop the need to explain the NMOS/CMOS distinction in all other cases (and if I'm writing conditional compilation stuff to be able to build a CMOS-using HIPLASMA then I want the same functionality to be available to other machines that would benefit).
- I think in the short term I might forget about CMOS and push on with a four way split, but it is perhaps best to think this through a bit more now.
- FWIW the flat JIT version is pretty much HIPLASMA. Maybe not though. JIT is about 8K of bytecode, say we want a minimum 4K JIT buffer. M128 has about 21.75K free at flat PLASMA prompt. More like 19K if we had PAGE at &1900. Take off 12K for the JIT and its' buffer and we're down to 7K, and this is in shadow mode. So on a plain B in mode 7 we're down to 6K. I suppose for a small program or a play around - and it is a cool feature - the JIT is just about usable, and it's probably the case that making the flat PLASMA relocate itself (which it has to do anyway) and work on tube and non-tube isn't really a big pain - I've already got the code too, it's just if it blocks anything, and I don't think it really does. LATER: I think (check) JIT requires code buffer to be in high 32K so we maybe can't have JIT for non-tube flat PLASMA
- Right now I'm not sure if we might not want separate JIT versions for PLASMA and PLAS128, but if we do I think they would be confined to the libsrc/acorn/jit.pla code not the core JIT; the PLAS128-inspired CS hack to jitcore is equally valid if unnecessary on the flat JIT, and while slower it is fractionally shorter. It may be I should move the CS opcode handling into a helper fn and have that live in the platform-specific source file not the main one; it's not ideal but I might be able to persuade Dave to take that change upstream if we do ever end up with a merged repo containing the Acorn port.
- In an ideal world it might be possible for the user to specify the amount of memory set aside for the JIT buffer on flat PLASMA (on PLAS128 it's natural for it to take the rest of the 16K bank after the JIT bytecode has loaded), but as we have to set the space aside on VM startup this would have to be a command line option to *PLASMA itself.
- hmm, codemax in jit is a constant and that doesn't sit well with flat JIT working on both tube and non-tube. I could make codemax a non-constant, I don't think it would be a particularly intrusive change and while it might slow the JIT down slightly I don't think it would be huge. This would also give me the ability for the jit.pla file's INIT code to set codemax to $C000 on a non-tube B/B+, taking advantage of the fact the OS ROM starts at $C000.
