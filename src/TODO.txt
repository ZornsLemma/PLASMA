Sandbox

Add ability to dump memory free to PLASMA executable by issuing a command? (to
allow seeing how resident modules take up space) (Possibly just keep my
relocation of the memory free output from the startup banner to the prompt as a
permanent feature; this perhaps makes more sense on the BBC, where changing
mode and so forth can have a big impact on the free memory)

Ability to build a standalone sideways language ROM

A language ROM version would have some value; this would free up more main RAM
for data and/or non-shadow screen on machines without a second processor
(PLAS128 doesn't help here). If running from sideways RAM the free space in the
bank could be made available to the running program - it would "nearly" be
suitable for use for code or data, although it would be paged out by the OS
during some OS calls so it would be brittle to allow it to be accessed
implicitly via the stack frame or heapalloc. We could have a "heapYalloc" but
that's perhaps a bit specialised. The alternative would be to use the remaining
space for bytecodes (PLAS128-style), and then we could fall back to allocating
bytecode space from main RAM if necessary (or if we're running from ROM).
Probably best to leave development of such a version until PLAS32 and PLAS128
are "finished" to avoid complexity of fixing bugs in three different places.
(An alternative possibility would be to pre-load some useful libraries as
resident modules, e.g. ACORNOS, into the sideways ROM so they're available
without importing them from disc into RAM. However, without a significant
quantity of well-tested, "frozen" libtrary code, there's not much value in
doing this, and it also raises the nasty possibility of needing to version
modules so you don't get stuck with v1 of FOO in the ROM when there's v2 of FOO
with some new feature you need on the disc.)

PLAS128 using 4x16K sideways RAM banks could *still* potentially page in a
fifth 16K bank when not fetching from "instruction space". This space couldn't
transparently be used for the normal heap or the frame stack because any
attempt to make an OS call using space allocated there could fail if another
ROM is temporarily paged in (most obviously a filing system). However, it could
be made available as a separate heap (say allocyheap() - not allocxheap(), as
that is the private heap used for the 64K data space) and code could call that
if it knows it will use the space returned for non-OS-call purposes. If
allocyheap() could fall back to using the normal heap if there is no 'Y' heap,
a program could with minimal extra effort be written to take advantage of this
extra 16K iff it's available. (You'd probably need to mark and release both the
normal and Y heaps at the same time, and releasing the Y heap would be a no-op
if it was actually just forwarding requests on to the normal heap.)

I'm not entirely happy with the idea, but it might be possible to have a small
separate heap explicitly for use with OS calls. Then it would be possible to
allow the "normal" heap to grow into sideways RAM (either a fifth bank in
PLAS128, or the one-and-only bank in the currently nonexistent language ROM
version) and it wouldn't cause any problems. I'd guess the parameter stack
should always remain in main RAM so local storage can be used to make OS calls
too. (Essentially, this idea is "offer the OS-safe guarantee only when code
asks for it", rather than the opposite "offer the OS-safe guarantee by default
and possibly offer a separate non-safe option for code to use if it wants".)

It might be possible to do something with the B+ special private 12K

A vim syntax highlighting mode for PLASMA code might be nice

It would probably be possible to produce a Matchbox co-pro specific version
which uses bank-switching PLAS128-style on the second processor.

Can we get any use out of the new ability to define the number of return values
of a PLASMA function? We could potentially save a bit of code by specifying 0
return values in some places.

It might be possible/easy to support cmorley's "OS RAM" module to allow larger
programs/data. One possibility which occurs to me is for the sideways ROM/RAM
version to detect a) first writable "high" location b) last writable "high"
location (allowing for such combinations as "ROM only" (-> no high RAM), "2nd
processor" (high RAM from &A800 or wherever "ROM" ends to &F800), "sideways
RAM" (high ram from &A800-ish to &C000), "OS RAM" (high ram from &C000 to
&FC00-ish), "sideways RAM+OS RAM" (high ram from &A800-ish to &FC00-ish) - the
detection would be easy to do in a modular fashion I think) and then that extra
RAM would automatically be available for bytecodes. Obviously this isn't the
most flexible as it doesn't allow data to be located in the new "OS RAM", but
it's one easy-ish possibility. (Not necessarily the optimal approach, but we
could potentially also use the B+'s private 12K here by detecting if we're
running as a language ROM in that 12K and setting the upper RAM boundary to
&8000+12K.)

Might be worth trying to tweak the compiler to prefer to put constant
multipliers on the "rhs", so that if we teach the peephole optimiser to do "CB
2:MUL:ADD"->"IDXW" there's more chance of it being triggers. Not sure if it's
worth it but perhaps depends how hard it is. We could potentially even special
case the constant 2 in the compiler tweak to minimise impact. This is the last
remaining optimisation (in practice) of those implementated in optimise.py that
I am dubious about being able to implement in the compiler's non-hacky peephole
optimiser - optimise.py is quite sophisticated here and forms an expression
tree to allow it to reshuffle parts of the expression if that helps.

Standalone version - A "productionised" version would ideally do a topological sort on the dependencies of the modules being "linked" to make sure it links them in an acceptable order (this matters as the _INIT code must be executed in a suitable order). I think this is doable if we output a machine-readable comment in the compiler output in lieu of the equivalent "I am module X" and "I depend on module Y" binary data in a module.

Include the git revision/label as a string at the end of the executable (after the relocation data, if any) - that way it wouldn't take any memory up at runtime but would be visible on disc

I don't think the optimiser handles things like 'foo = bar() + 2 + 3'; the 2 + 3 can obviously be folded to a 5 but this doesn't seem to happen. (Similar thing happens with trailing '*'; I suspect it applies to other operators too.)

It may be that the NOP_CODE I introduced in the optimiser to support remove_writes() could be used to good effect to simplify other existing bits of the optimiser code, allowing the fiddly 'delete opcode' logic to occur in just one place.

A 'reverse subtraction' opcode just might be useful; the thing to do would be
to try to add support to the peephole optimiser to try it out (it effectively
makes subtraction a commutative operation for the purposes of switching opcodes
round to possibly allow more use of DLB/DLW, for example)

Write a test program to check divmod() gives the right result in all cases

Can the peephole optimiser replace 'CALL divmod' with a DIVMOD opcode?

Can/should I replace my longjmp()/setjmp() with the new upstream
throw()/except() in libsrc/longjmp.pla?

rogue.io.pla is now somewhat out of sync with upstream; I should probably look
into porting conio and using that. For now I have just left the older version
of the code in this port.
