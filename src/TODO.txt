Sandbox

Add ability to dump memory free to PLASMA executable by issuing a command? (to
allow seeing how resident modules take up space) (Possibly just keep my
relocation of the memory free output from the startup banner to the prompt as a
permanent feature; this perhaps makes more sense on the BBC, where changing
mode and so forth can have a big impact on the free memory)

Ability to build a standalone sideways language ROM

A language ROM version would have some value; this would free up more main RAM
for data and/or non-shadow screen on machines without a second processor
(PLAS128 doesn't help here). If running from sideways RAM the free space in the
bank could be made available to the running program - it would "nearly" be
suitable for use for code or data, although it would be paged out by the OS
during some OS calls so it would be brittle to allow it to be accessed
implicitly via the stack frame or heapalloc. We could have a "heapYalloc" but
that's perhaps a bit specialised. The alternative would be to use the remaining
space for bytecodes (PLAS128-style), and then we could fall back to allocating
bytecode space from main RAM if necessary (or if we're running from ROM).
Probably best to leave development of such a version until PLAS32 and PLAS128
are "finished" to avoid complexity of fixing bugs in three different places.
(An alternative possibility would be to pre-load some useful libraries as
resident modules, e.g. ACORNOS, into the sideways ROM so they're available
without importing them from disc into RAM. However, without a significant
quantity of well-tested, "frozen" libtrary code, there's not much value in
doing this, and it also raises the nasty possibility of needing to version
modules so you don't get stuck with v1 of FOO in the ROM when there's v2 of FOO
with some new feature you need on the disc.)

PLAS128 using 4x16K sideways RAM banks could *still* potentially page in a
fifth 16K bank when not fetching from "instruction space". This space couldn't
transparently be used for the normal heap or the frame stack because any
attempt to make an OS call using space allocated there could fail if another
ROM is temporarily paged in (most obviously a filing system). However, it could
be made available as a separate heap (say allocyheap() - not allocxheap(), as
that is the private heap used for the 64K data space) and code could call that
if it knows it will use the space returned for non-OS-call purposes. If
allocyheap() could fall back to using the normal heap if there is no 'Y' heap,
a program could with minimal extra effort be written to take advantage of this
extra 16K iff it's available. (You'd probably need to mark and release both the
normal and Y heaps at the same time, and releasing the Y heap would be a no-op
if it was actually just forwarding requests on to the normal heap.)

I'm not entirely happy with the idea, but it might be possible to have a small
separate heap explicitly for use with OS calls. Then it would be possible to
allow the "normal" heap to grow into sideways RAM (either a fifth bank in
PLAS128, or the one-and-only bank in the currently nonexistent language ROM
version) and it wouldn't cause any problems. I'd guess the parameter stack
should always remain in main RAM so local storage can be used to make OS calls
too. (Essentially, this idea is "offer the OS-safe guarantee only when code
asks for it", rather than the opposite "offer the OS-safe guarantee by default
and possibly offer a separate non-safe option for code to use if it wants".)

It might be possible to do something with the B+ special private 12K

A vim syntax highlighting mode for PLASMA code might be nice

It would probably be possible to produce a Matchbox co-pro specific version
which uses bank-switching PLAS128-style on the second processor.

Can we get any use out of the new ability to define the number of return values
of a PLASMA function? We could potentially save a bit of code by specifying 0
return values in some places.

It might be possible/easy to support cmorley's "OS RAM" module to allow larger
programs/data. One possibility which occurs to me is for the sideways ROM/RAM
version to detect a) first writable "high" location b) last writable "high"
location (allowing for such combinations as "ROM only" (-> no high RAM), "2nd
processor" (high RAM from &A800 or wherever "ROM" ends to &F800), "sideways
RAM" (high ram from &A800-ish to &C000), "OS RAM" (high ram from &C000 to
&FC00-ish), "sideways RAM+OS RAM" (high ram from &A800-ish to &FC00-ish) - the
detection would be easy to do in a modular fashion I think) and then that extra
RAM would automatically be available for bytecodes. Obviously this isn't the
most flexible as it doesn't allow data to be located in the new "OS RAM", but
it's one easy-ish possibility. (Not necessarily the optimal approach, but we
could potentially also use the B+'s private 12K here by detecting if we're
running as a language ROM in that 12K and setting the upper RAM boundary to
&8000+12K.)

Might be worth trying to tweak the compiler to prefer to put constant
multipliers on the "rhs", so that if we teach the peephole optimiser to do "CB
2:MUL:ADD"->"IDXW" there's more chance of it being triggers. Not sure if it's
worth it but perhaps depends how hard it is. We could potentially even special
case the constant 2 in the compiler tweak to minimise impact. This is the last
remaining optimisation (in practice) of those implementated in optimise.py that
I am dubious about being able to implement in the compiler's non-hacky peephole
optimiser - optimise.py is quite sophisticated here and forms an expression
tree to allow it to reshuffle parts of the expression if that helps.

Standalone version - A "productionised" version would ideally do a topological sort on the dependencies of the modules being "linked" to make sure it links them in an acceptable order (this matters as the _INIT code must be executed in a suitable order). I think this is doable if we output a machine-readable comment in the compiler output in lieu of the equivalent "I am module X" and "I depend on module Y" binary data in a module.

Include the git revision/label as a string at the end of the executable (after the relocation data, if any) - that way it wouldn't take any memory up at runtime but would be visible on disc

I don't think the optimiser handles things like 'foo = bar() + 2 + 3'; the 2 + 3 can obviously be folded to a 5 but this doesn't seem to happen. (Similar thing happens with trailing '*'; I suspect it applies to other operators too.)

It may be that the NOP_CODE I introduced in the optimiser to support remove_writes() could be used to good effect to simplify other existing bits of the optimiser code, allowing the fiddly 'delete opcode' logic to occur in just one place.

A 'reverse subtraction' opcode just might be useful; the thing to do would be
to try to add support to the peephole optimiser to try it out (it effectively
makes subtraction a commutative operation for the purposes of switching opcodes
round to possibly allow more use of DLB/DLW, for example)

Write a test program to check divmod() gives the right result in all cases

Can the peephole optimiser replace 'CALL divmod' with a DIVMOD opcode?

Can/should I replace my longjmp()/setjmp() with the new upstream
throw()/except() in libsrc/longjmp.pla?

rogue.io.pla is now somewhat out of sync with upstream; I should probably look
into porting conio and using that. For now I have just left the older version
of the code in this port.

I think there were some invalid optimisations removed by upstream between merge5 and merge6; it would be good to look at what those were and if they were potentially desirable optimisations, look at allowing them to be reinstated.

Looks like there is now a self-hosted PLASMA compiler, I should take a look at porting that.

Looking at the Youtube video of PLASMA, the lighted area in ROGUE should be shown in reverse video. This doesn't happen in this port - not sure if this is a new feature or something which I lost in my port.

Apple II version auto-patches in support for 65C02 instructions - I should look at enabling that for the Acorn port

Should I stop printing "PLASMA 01.00" (or whatever) every time an error occurs at the prompt? It wasn't really deliberate and doesn't add much, and makes stuff scroll off the screen unnecessarily.

We probably eventually want to build multiple SSDs rather than tweaking skel.beebasm manually to put the stuff of current interest onto the SSD

I think if you write code like 'if blah break fin' the generated bytecode can do
'BRFLS A:BRNCH B:.A' - if so (this is a quick note, not checked) the optimiser
could be taught to turn that into 'BRTRU B' - might be difficult given it
depends on 'seeing' the label A

It might be a good idea to produce "crunched" (no comment) versions of the inc/*.plh files for use with the self-hosting compiler to save disc space and speed up compilation

I think PLASM (the self-hosted compiler) doesn't work on PLAS128 because the main module is too large to fit into a 16K bank. Can I do something about this? I don't *think* it's easy to remove the 15.xK limitation on each module, but think about it. It may however be fairly easy to split a chunk of the compiler into a separate module. (Do pay attention to how much, if any, negative impact such a split has on compiler load time on second processor where the current PLASM module fits fine.)

I should possibly add the name of the module which isn't found to the VM output when recursive module loading fails to find a file. You *can* work around it by loading the MODNAME example, but it's a bit clunky.

We could probably re-use the three bytes at the start of the VM code which do "JMP VMINIT" - I don't think (but check) they are ever used after the first start up, even on a second processor when you press BREAK. Their address will change as the executable is relocated so cmd.pla can't know this address, but the core assembly VM can. We could possibly use this as JMPTMP - we'd have to patch the JMP up to be a JMP indirect, but we could probably do that in the discarded code at the end of the VM, so we would save these three bytes overall.

The PLASM self-hosted compiler sometimes seems to leave files open if an OS error occurs - can't blam eit because these currently throw() right out of its code into the main VM. However, one way or another it would be good if I could fix this up (if I do make fileio use except() to catch OS errors and turn them into error return values it would probably work, but I am dithering about doing that as it might effectively throw away useful information for the user)

Assuming I eventually port the JIT, make sure to port the 'sysflags nojitc' in various library modules from the Apple code (and add it to any Acorn-only code where it's appropriate)

Could we introduce some mechanism to allow constants to be shared between asm and PLASMA code? The VM source code has some duplication of constants, e.g. Apple II 'jitmod' address. Perhaps this might be as simple as a preprocessor which is run during the build to extract suitably labelled constants from ACME code and emit a trivial file suitable for including from PLASMA code.

See Dave's e-mail 15/05/18 - I could probably use his idea and have the heap start at the 'init' code, provided I arrange that any code which needs to do a heap allocation lives in a separate function. When running on a second processor this couldn't be done as we need to be able to re-init on BREAK, but that's probably fine - the 2P case is already handled differently for some other need-the-code-to-be-available-on-BREAK issue, I think.

Could the code density be improved with 8-bit displacement branch opcodes? Would need an optimiser capable of generating these. There are quite a few different branch instructions so may not be very practical, but maybe a few branch instructions account for most of the branches.

Self-hosted optimiser has assumption that no memory-mapped hardware exists above $D000; this will need fixing for Acorn port.



Short term notes:
- can I avoid use of dinterp()/iinterp()/jitinterp() functions in cmd.pla?
- (slighly related) use of *$415 and *$417 to communicate dinterp()/iinterp() to JIT could probably be tidier
- make JIT conditionally compiled
- PLAS128 JIT - apart from technical issues, am I going to have four binaries or can I provide any sensible defaults? I suspect there's no clear right answer (it varies depending on what the program to be run needs - data memory, code memory, speed) but think about it.
- I don't have JMPTMP at a fixed address (unlike Apple II), there is a hack in the JIT to handle this, can I fix this better? Quite happy not to have it at a fixed address if I can do it without hacks...
